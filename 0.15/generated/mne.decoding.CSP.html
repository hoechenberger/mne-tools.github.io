<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>mne.decoding.CSP &#8212; MNE 0.15 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.15',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <script type="text/javascript" src="../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flag-icon.css" type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  <link rel="canonical" href="https://mne.tools/stable/index.html" />
</head>
  <body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.15</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Install</a></li>
                <li><a href="../documentation.html">Documentation</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../auto_examples/index.html">Examples</a></li>
                <li><a href="../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-primary navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.15
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
    <li><a href="https://mne-tools.github.io/stable/index.html">v0.15 (stable)</a></li>
    <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
    <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
    <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
    <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.decoding.CSP</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="mne-decoding-csp">
<h1>mne.decoding.CSP<a class="headerlink" href="#mne-decoding-csp" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.decoding.CSP">
<em class="property">class </em><code class="descclassname">mne.decoding.</code><code class="descname">CSP</code><span class="sig-paren">(</span><em>n_components=4</em>, <em>reg=None</em>, <em>log=None</em>, <em>cov_est='concat'</em>, <em>transform_into='average_power'</em>, <em>norm_trace=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/decoding/csp.py#L21-L588"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP" title="Permalink to this definition">¶</a></dt>
<dd><p>M/EEG signal decomposition using the Common Spatial Patterns (CSP).</p>
<p>This object can be used as a supervised decomposition to estimate
spatial filters for feature extraction in a 2 class decoding problem.
CSP in the context of EEG was first described in [1]; a comprehensive
tutorial on CSP can be found in [2]. Multiclass solving is implemented
from [3].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n_components</strong> : int, defaults to 4</p>
<blockquote>
<div><p>The number of components to decompose M/EEG signals.
This number should be set by cross-validation.</p>
</div></blockquote>
<p><strong>reg</strong> : float | str | None, defaults to None</p>
<blockquote>
<div><p>if not None, allow regularization for covariance estimation
if float, shrinkage covariance is used (0 &lt;= shrinkage &lt;= 1).
if str, optimal shrinkage using Ledoit-Wolf Shrinkage (‘ledoit_wolf’)
or Oracle Approximating Shrinkage (‘oas’).</p>
</div></blockquote>
<p><strong>log</strong> : None | bool, defaults to None</p>
<blockquote>
<div><p>If transform_into == ‘average_power’ and log is None or True, then
applies a log transform to standardize the features, else the features
are z-scored. If transform_into == ‘csp_space’, then log must be None.</p>
</div></blockquote>
<p><strong>cov_est</strong> : ‘concat’ | ‘epoch’, defaults to ‘concat’</p>
<blockquote>
<div><p>If ‘concat’, covariance matrices are estimated on concatenated epochs
for each class.
If ‘epoch’, covariance matrices are estimated on each epoch separately
and then averaged over each class.</p>
</div></blockquote>
<p><strong>transform_into</strong> : {‘average_power’, ‘csp_space’}</p>
<blockquote>
<div><p>If ‘average_power’ then self.transform will return the average power of
each spatial filter. If ‘csp_space’ self.transform will return the data
in CSP space. Defaults to ‘average_power’.</p>
</div></blockquote>
<p><strong>norm_trace</strong> : bool</p>
<blockquote class="last">
<div><p>Normalize class covariance by its trace. Defaults to True. Trace
normalization is a step of the original CSP algorithm <a class="reference internal" href="#r110112" id="id1">[R110112]</a> to eliminate
magnitude variations in the EEG between individuals. It is not applied
in more recent work <a class="reference internal" href="#r111112" id="id2">[R111112]</a>, <a class="reference internal" href="#r112112" id="id3">[R112112]</a> and can have a negative impact on
patterns ordering.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.preprocessing.Xdawn.html#mne.preprocessing.Xdawn" title="mne.preprocessing.Xdawn"><code class="xref py py-obj docutils literal"><span class="pre">mne.preprocessing.Xdawn</span></code></a>, <a class="reference internal" href="mne.decoding.SPoC.html#mne.decoding.SPoC" title="mne.decoding.SPoC"><code class="xref py py-obj docutils literal"><span class="pre">SPoC</span></code></a></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r110112" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R110112]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Zoltan J. Koles, Michael S. Lazar, Steven Z. Zhou. Spatial Patterns
Underlying Population Differences in the Background EEG. Brain
Topography 2(4), 275-284, 1990.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r111112" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R111112]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id5">2</a>)</em> Benjamin Blankertz, Ryota Tomioka, Steven Lemm, Motoaki Kawanabe,
Klaus-Robert Müller. Optimizing Spatial Filters for Robust EEG
Single-Trial Analysis. IEEE Signal Processing Magazine 25(1), 41-56,
2008.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r112112" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R112112]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> Grosse-Wentrup, Moritz, and Martin Buss. Multiclass common spatial
patterns and information theoretic feature extraction. IEEE
Transactions on Biomedical Engineering, Vol 55, no. 8, 2008.</td></tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>``filters_``</strong></td>
<td>(ndarray, shape (n_components, n_channels)) If fit, the CSP components used to decompose the data, else None.</td>
</tr>
<tr class="row-even"><td><strong>``patterns_``</strong></td>
<td>(ndarray, shape (n_components, n_channels)) If fit, the CSP patterns used to restore M/EEG signals, else None.</td>
</tr>
<tr class="row-odd"><td><strong>``mean_``</strong></td>
<td>(ndarray, shape (n_components,)) If fit, the mean squared power for each component.</td>
</tr>
<tr class="row-even"><td><strong>``std_``</strong></td>
<td>(ndarray, shape (n_components,)) If fit, the std squared power for each component.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.CSP.__hash__" title="mne.decoding.CSP.__hash__"><code class="xref py py-obj docutils literal"><span class="pre">__hash__</span></code></a>()&nbsp;&lt;==&gt;&nbsp;hash(x)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.CSP.fit" title="mne.decoding.CSP.fit"><code class="xref py py-obj docutils literal"><span class="pre">fit</span></code></a>(X,&nbsp;y)</td>
<td>Estimate the CSP decomposition on epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.CSP.fit_transform" title="mne.decoding.CSP.fit_transform"><code class="xref py py-obj docutils literal"><span class="pre">fit_transform</span></code></a>(X[,&nbsp;y])</td>
<td>Fit to data, then transform it.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.CSP.get_params" title="mne.decoding.CSP.get_params"><code class="xref py py-obj docutils literal"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.CSP.plot_filters" title="mne.decoding.CSP.plot_filters"><code class="xref py py-obj docutils literal"><span class="pre">plot_filters</span></code></a>(info[,&nbsp;components,&nbsp;ch_type,&nbsp;…])</td>
<td>Plot topographic filters of components.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.CSP.plot_patterns" title="mne.decoding.CSP.plot_patterns"><code class="xref py py-obj docutils literal"><span class="pre">plot_patterns</span></code></a>(info[,&nbsp;components,&nbsp;ch_type,&nbsp;…])</td>
<td>Plot topographic patterns of components.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.CSP.set_params" title="mne.decoding.CSP.set_params"><code class="xref py py-obj docutils literal"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.CSP.transform" title="mne.decoding.CSP.transform"><code class="xref py py-obj docutils literal"><span class="pre">transform</span></code></a>(X)</td>
<td>Estimate epochs sources given the CSP filters.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="mne.decoding.CSP.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><em>) &lt;==&gt; hash(x</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.decoding.CSP.__hash__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.decoding.CSP.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/decoding/csp.py#L147-L253"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the CSP decomposition on epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : ndarray, shape (n_epochs, n_channels, n_times)</p>
<blockquote>
<div><p>The data on which to estimate the CSP.</p>
</div></blockquote>
<p><strong>y</strong> : array, shape (n_epochs,)</p>
<blockquote>
<div><p>The class for each epoch.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of CSP</p>
<blockquote class="last">
<div><p>Returns the modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.CSP.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y=None</em>, <em>**fit_params</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/decoding/mixin.py#L7-L33"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit to data, then transform it.</p>
<p>Fits transformer to X and y with optional parameters fit_params
and returns a transformed version of X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : numpy array of shape [n_samples, n_features]</p>
<blockquote>
<div><p>Training set.</p>
</div></blockquote>
<p><strong>y</strong> : numpy array of shape [n_samples]</p>
<blockquote>
<div><p>Target values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X_new</strong> : numpy array of shape [n_samples, n_features_new]</p>
<blockquote class="last">
<div><p>Transformed array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.CSP.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/fixes.py#L1140-L1175"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>deep</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>params</strong> : mapping of string to any</p>
<blockquote class="last">
<div><p>Parameter names mapped to their values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.CSP.plot_filters">
<code class="descname">plot_filters</code><span class="sig-paren">(</span><em>info</em>, <em>components=None</em>, <em>ch_type=None</em>, <em>layout=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap='RdBu_r'</em>, <em>sensors=True</em>, <em>colorbar=True</em>, <em>scalings=None</em>, <em>units='a.u.'</em>, <em>res=64</em>, <em>size=1</em>, <em>cbar_fmt='%3.1f'</em>, <em>name_format='CSP%01d'</em>, <em>show=True</em>, <em>show_names=False</em>, <em>title=None</em>, <em>mask=None</em>, <em>mask_params=None</em>, <em>outlines='head'</em>, <em>contours=6</em>, <em>image_interp='bilinear'</em>, <em>average=None</em>, <em>head_pos=None</em>, <em>scale=None</em>, <em>unit=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/decoding/csp.py#L441-L588"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP.plot_filters" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topographic filters of components.</p>
<p>The filters are used to extract discriminant neural sources from
the measured data (a.k.a. the backward model).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : instance of Info</p>
<blockquote>
<div><p>Info dictionary of the epochs used for fitting.
If not possible, consider using <code class="docutils literal"><span class="pre">create_info</span></code>.</p>
</div></blockquote>
<p><strong>components</strong> : float | array of floats | None.</p>
<blockquote>
<div><p>The patterns to plot. If None, n_components will be shown.</p>
</div></blockquote>
<p><strong>ch_type</strong> : ‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None</p>
<blockquote>
<div><p>The channel type to plot. For ‘grad’, the gradiometers are
collected in pairs and the RMS for each pair is plotted.
If None, then first available channel type from order given
above is used. Defaults to None.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to be
specified for Neuromag data). If possible, the correct layout file
is inferred from the data; if no appropriate layout file was found
the layout is automatically generated from the sensor locations.</p>
</div></blockquote>
<p><strong>vmin</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data).</p>
</div></blockquote>
<p><strong>vmax</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the upper bound of the color range.
If None, the maximum absolute value is used. If vmin is None,
but vmax is not, defaults to np.min(data).
If callable, the output equals vmax(data).</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap | (colormap, bool) | ‘interactive’ | None</p>
<blockquote>
<div><p>Colormap to use. If tuple, the first value indicates the colormap
to use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging
the colorbar with left and right mouse button. Left mouse button
moves the scale up and down and right mouse button adjusts the
range. Hitting space bar resets the range. Up and down arrows can
be used to change the colormap. If None, ‘Reds’ is used for all
positive data, otherwise defaults to ‘RdBu_r’. If ‘interactive’,
translates to (None, True). Defaults to ‘RdBu_r’.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Interactive mode works smoothly only for a small
amount of topomaps.</p>
</div>
</div></blockquote>
<p><strong>sensors</strong> : bool | str</p>
<blockquote>
<div><p>Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., ‘r+’ for red plusses). If True,
a circle will be used (via .add_artist). Defaults to True.</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Plot a colorbar.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | float | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting.
If None, defaults to <code class="docutils literal"><span class="pre">dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15)</span></code>.</p>
</div></blockquote>
<p><strong>units</strong> : dict | str | None</p>
<blockquote>
<div><p>The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</div></blockquote>
<p><strong>res</strong> : int</p>
<blockquote>
<div><p>The resolution of the topomap image (n pixels along each side).</p>
</div></blockquote>
<p><strong>size</strong> : float</p>
<blockquote>
<div><p>Side length per topomap in inches.</p>
</div></blockquote>
<p><strong>cbar_fmt</strong> : str</p>
<blockquote>
<div><p>String format for colorbar values.</p>
</div></blockquote>
<p><strong>name_format</strong> : str</p>
<blockquote>
<div><p>String format for topomap values. Defaults to “CSP%01d”</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool | callable</p>
<blockquote>
<div><p>If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g.,
to delete the prefix ‘MEG ‘ from all channel names, pass the
function lambda x: x.replace(‘MEG ‘, ‘’). If <cite>mask</cite> is not None,
only significant sensors will be shown.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title. If None (default), no title is displayed.</p>
</div></blockquote>
<p><strong>mask</strong> : ndarray of bool, shape (n_channels, n_times) | None</p>
<blockquote>
<div><p>The channels to be marked as significant at a given time point.
Indices set to <cite>True</cite> will be considered. Defaults to None.</p>
</div></blockquote>
<p><strong>mask_params</strong> : dict | None</p>
<blockquote>
<div><p>Additional plotting parameters for plotting significant sensors.
Default (None) equals:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>outlines</strong> : ‘head’ | ‘skirt’ | dict | None</p>
<blockquote>
<div><p>The outlines to be drawn. If ‘head’, the default head scheme will
be drawn. If ‘skirt’ the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in ‘mask_pos’
will serve as image mask, and the ‘autoshrink’ (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to ‘head’.</p>
</div></blockquote>
<p><strong>contours</strong> : int | array of float</p>
<blockquote>
<div><p>The number of contour lines to draw. If 0, no contours will be
drawn. When an integer, matplotlib ticker locator is used to find
suitable values for the contour thresholds (may sometimes be
inaccurate, use array for accuracy). If an array, the values
represent the levels for the contours. Defaults to 6.</p>
</div></blockquote>
<p><strong>image_interp</strong> : str</p>
<blockquote>
<div><p>The image interpolation to be used.
All matplotlib options are accepted.</p>
</div></blockquote>
<p><strong>average</strong> : float | None</p>
<blockquote>
<div><p>The time window around a given time to be used for averaging
(seconds). For example, 0.01 would translate into window that
starts 5 ms before and ends 5 ms after a given time point.
Defaults to None, which means no averaging.</p>
</div></blockquote>
<p><strong>head_pos</strong> : dict | None</p>
<blockquote>
<div><p>If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries ‘center’ (tuple) and
‘scale’ (tuple) for what the center and scale of the head
should be relative to the electrode locations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.CSP.plot_patterns">
<code class="descname">plot_patterns</code><span class="sig-paren">(</span><em>info</em>, <em>components=None</em>, <em>ch_type=None</em>, <em>layout=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap='RdBu_r'</em>, <em>sensors=True</em>, <em>colorbar=True</em>, <em>scalings=None</em>, <em>units='a.u.'</em>, <em>res=64</em>, <em>size=1</em>, <em>cbar_fmt='%3.1f'</em>, <em>name_format='CSP%01d'</em>, <em>show=True</em>, <em>show_names=False</em>, <em>title=None</em>, <em>mask=None</em>, <em>mask_params=None</em>, <em>outlines='head'</em>, <em>contours=6</em>, <em>image_interp='bilinear'</em>, <em>average=None</em>, <em>head_pos=None</em>, <em>scale=None</em>, <em>unit=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/decoding/csp.py#L291-L439"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP.plot_patterns" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topographic patterns of components.</p>
<p>The patterns explain how the measured data was generated from the
neural sources (a.k.a. the forward model).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : instance of Info</p>
<blockquote>
<div><p>Info dictionary of the epochs used for fitting.
If not possible, consider using <code class="docutils literal"><span class="pre">create_info</span></code>.</p>
</div></blockquote>
<p><strong>components</strong> : float | array of floats | None.</p>
<blockquote>
<div><p>The patterns to plot. If None, n_components will be shown.</p>
</div></blockquote>
<p><strong>ch_type</strong> : ‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None</p>
<blockquote>
<div><p>The channel type to plot. For ‘grad’, the gradiometers are
collected in pairs and the RMS for each pair is plotted.
If None, then first available channel type from order given
above is used. Defaults to None.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to be
specified for Neuromag data). If possible, the correct layout file
is inferred from the data; if no appropriate layout file was found
the layout is automatically generated from the sensor locations.</p>
</div></blockquote>
<p><strong>vmin</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data).</p>
</div></blockquote>
<p><strong>vmax</strong> : float | callable</p>
<blockquote>
<div><p>The value specfying the upper bound of the color range.
If None, the maximum absolute value is used. If vmin is None,
but vmax is not, defaults to np.min(data).
If callable, the output equals vmax(data).</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap | (colormap, bool) | ‘interactive’ | None</p>
<blockquote>
<div><p>Colormap to use. If tuple, the first value indicates the colormap
to use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging
the colorbar with left and right mouse button. Left mouse button
moves the scale up and down and right mouse button adjusts the
range. Hitting space bar resets the range. Up and down arrows can
be used to change the colormap. If None, ‘Reds’ is used for all
positive data, otherwise defaults to ‘RdBu_r’. If ‘interactive’,
translates to (None, True). Defaults to ‘RdBu_r’.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Interactive mode works smoothly only for a small
amount of topomaps.</p>
</div>
</div></blockquote>
<p><strong>sensors</strong> : bool | str</p>
<blockquote>
<div><p>Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., ‘r+’ for red plusses). If True,
a circle will be used (via .add_artist). Defaults to True.</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Plot a colorbar.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | float | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting.
If None, defaults to <code class="docutils literal"><span class="pre">dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15)</span></code>.</p>
</div></blockquote>
<p><strong>units</strong> : dict | str | None</p>
<blockquote>
<div><p>The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</div></blockquote>
<p><strong>res</strong> : int</p>
<blockquote>
<div><p>The resolution of the topomap image (n pixels along each side).</p>
</div></blockquote>
<p><strong>size</strong> : float</p>
<blockquote>
<div><p>Side length per topomap in inches.</p>
</div></blockquote>
<p><strong>cbar_fmt</strong> : str</p>
<blockquote>
<div><p>String format for colorbar values.</p>
</div></blockquote>
<p><strong>name_format</strong> : str</p>
<blockquote>
<div><p>String format for topomap values. Defaults to “CSP%01d”</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool | callable</p>
<blockquote>
<div><p>If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g.,
to delete the prefix ‘MEG ‘ from all channel names, pass the
function lambda x: x.replace(‘MEG ‘, ‘’). If <cite>mask</cite> is not None,
only significant sensors will be shown.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title. If None (default), no title is displayed.</p>
</div></blockquote>
<p><strong>mask</strong> : ndarray of bool, shape (n_channels, n_times) | None</p>
<blockquote>
<div><p>The channels to be marked as significant at a given time point.
Indices set to <cite>True</cite> will be considered. Defaults to None.</p>
</div></blockquote>
<p><strong>mask_params</strong> : dict | None</p>
<blockquote>
<div><p>Additional plotting parameters for plotting significant sensors.
Default (None) equals:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>outlines</strong> : ‘head’ | ‘skirt’ | dict | None</p>
<blockquote>
<div><p>The outlines to be drawn. If ‘head’, the default head scheme will
be drawn. If ‘skirt’ the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in ‘mask_pos’
will serve as image mask, and the ‘autoshrink’ (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to ‘head’.</p>
</div></blockquote>
<p><strong>contours</strong> : int | array of float</p>
<blockquote>
<div><p>The number of contour lines to draw. If 0, no contours will be
drawn. When an integer, matplotlib ticker locator is used to find
suitable values for the contour thresholds (may sometimes be
inaccurate, use array for accuracy). If an array, the values
represent the levels for the contours. Defaults to 6.</p>
</div></blockquote>
<p><strong>image_interp</strong> : str</p>
<blockquote>
<div><p>The image interpolation to be used.
All matplotlib options are accepted.</p>
</div></blockquote>
<p><strong>average</strong> : float | None</p>
<blockquote>
<div><p>The time window around a given time to be used for averaging
(seconds). For example, 0.01 would translate into window that
starts 5 ms before and ends 5 ms after a given time point.
Defaults to None, which means no averaging.</p>
</div></blockquote>
<p><strong>head_pos</strong> : dict | None</p>
<blockquote>
<div><p>If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries ‘center’ (tuple) and
‘scale’ (tuple) for what the center and scale of the head
should be relative to the electrode locations.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.CSP.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/fixes.py#L1177-L1211"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.
The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.
Returns
——-
self</p>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.CSP.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.15/mne/decoding/csp.py#L255-L289"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.CSP.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate epochs sources given the CSP filters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, shape (n_epochs, n_channels, n_times)</p>
<blockquote>
<div><p>The data.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>X</strong> : ndarray</p>
<blockquote class="last">
<div><p>If self.transform_into == ‘average_power’ then returns the power of
CSP features averaged over time and shape (n_epochs, n_sources)
If self.transform_into == ‘csp_space’ then returns the data in CSP
space and shape is (n_epochs, n_sources, n_times)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><img src="../_static/institutions.png" alt="Institutions"></div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2017, MNE Developers. Last updated on 2017-10-31.</p>
  </div>
</footer>
<script src="https://mne.tools/versionwarning.js"></script>
  </body>
</html>