<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>mne.time_frequency.AverageTFR &#8212; MNE 0.17.1 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/reset-syntax.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <script type="text/javascript" src="../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flag-icon.css" type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  <link rel="canonical" href="https://mne.tools/stable/index.html" />
</head><body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.17.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Install</a></li>
                <li><a href="../documentation.html">Documentation</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../glossary.html">Glossary</a></li>
                <li><a href="../auto_examples/index.html">Examples</a></li>
                <li><a href="../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-primary navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.17.1
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
    <li><a href="https://mne-tools.github.io/stable/index.html">v0.17 (stable)</a></li>
    <li><a href="https://mne-tools.github.io/0.16/index.html">v0.16</a></li>
    <li><a href="https://mne-tools.github.io/0.15/index.html">v0.15</a></li>
    <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
    <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
    <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
    <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.time_frequency.AverageTFR</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="mne-time-frequency-averagetfr">
<h1>mne.time_frequency.AverageTFR<a class="headerlink" href="#mne-time-frequency-averagetfr" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.time_frequency.AverageTFR">
<em class="property">class </em><code class="descclassname">mne.time_frequency.</code><code class="descname">AverageTFR</code><span class="sig-paren">(</span><em>info</em>, <em>data</em>, <em>times</em>, <em>freqs</em>, <em>nave</em>, <em>comment=None</em>, <em>method=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L958-L1939"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for Time-Frequency data.</p>
<p>Can for example store induced power at sensor level or inter-trial
coherence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Info</span></dt>
<dd><p class="first last">The measurement info.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_channels, n_freqs, n_times)</span></dt>
<dd><p class="first last">The data.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_times,)</span></dt>
<dd><p class="first last">The time values in seconds.</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_freqs,)</span></dt>
<dd><p class="first last">The frequencies in Hz.</p>
</dd>
<dt><strong>nave</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of averaged TFRs.</p>
</dd>
<dt><strong>comment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None, defaults to None</span></dt>
<dd><p class="first last">Comment on the data, e.g., the experimental condition.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None, defaults to None</span></dt>
<dd><p class="first last">Comment on the method used to compute the data, e.g., morlet wavelet.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Info</span></dt>
<dd><p class="first last">Measurement info.</p>
</dd>
<dt><a class="reference internal" href="#mne.time_frequency.AverageTFR.ch_names" title="mne.time_frequency.AverageTFR.ch_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ch_names</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Channel names.</p>
</dd>
<dt><strong>nave</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of averaged epochs.</p>
</dd>
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_channels, n_freqs, n_times)</span></dt>
<dd><p class="first last">The data array.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_times,)</span></dt>
<dd><p class="first last">The time values in seconds.</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, shape (n_freqs,)</span></dt>
<dd><p class="first last">The frequencies in Hz.</p>
</dd>
<dt><strong>comment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Comment on dataset. Can be the condition.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None, defaults to None</span></dt>
<dd><p class="first last">Comment on the method used to compute the data, e.g., morlet wavelet.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.__add__" title="mne.time_frequency.AverageTFR.__add__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__add__</span></code></a>(tfr)</td>
<td>Add instances.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.__contains__" title="mne.time_frequency.AverageTFR.__contains__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__contains__</span></code></a>(ch_type)</td>
<td>Check channel type membership.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.__hash__" title="mne.time_frequency.AverageTFR.__hash__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__hash__</span></code></a>()</td>
<td>Hash the object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.__sub__" title="mne.time_frequency.AverageTFR.__sub__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__sub__</span></code></a>(tfr)</td>
<td>Subtract instances.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.add_channels" title="mne.time_frequency.AverageTFR.add_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_channels</span></code></a>(add_list[,&nbsp;force_update_info])</td>
<td>Append new channels to the instance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.apply_baseline" title="mne.time_frequency.AverageTFR.apply_baseline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_baseline</span></code></a>(baseline[,&nbsp;mode,&nbsp;verbose])</td>
<td>Baseline correct the data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.copy" title="mne.time_frequency.AverageTFR.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Return a copy of the instance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.crop" title="mne.time_frequency.AverageTFR.crop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code></a>([tmin,&nbsp;tmax])</td>
<td>Crop data to a given time interval in place.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.drop_channels" title="mne.time_frequency.AverageTFR.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>(ch_names)</td>
<td>Drop some channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_channels" title="mne.time_frequency.AverageTFR.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a>(ch_names)</td>
<td>Pick some channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_types" title="mne.time_frequency.AverageTFR.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;…])</td>
<td>Pick some channels by type and names.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.plot" title="mne.time_frequency.AverageTFR.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>([picks,&nbsp;baseline,&nbsp;mode,&nbsp;tmin,&nbsp;tmax,&nbsp;…])</td>
<td>Plot TFRs as a two-dimensional image(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.plot_joint" title="mne.time_frequency.AverageTFR.plot_joint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_joint</span></code></a>([timefreqs,&nbsp;picks,&nbsp;baseline,&nbsp;…])</td>
<td>Plot TFRs as a two-dimensional image with topomaps.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.plot_topo" title="mne.time_frequency.AverageTFR.plot_topo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_topo</span></code></a>([picks,&nbsp;baseline,&nbsp;mode,&nbsp;tmin,&nbsp;…])</td>
<td>Plot TFRs in a topography with images.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.plot_topomap" title="mne.time_frequency.AverageTFR.plot_topomap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_topomap</span></code></a>([tmin,&nbsp;tmax,&nbsp;fmin,&nbsp;fmax,&nbsp;…])</td>
<td>Plot topographic maps of time-frequency intervals of TFR data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.reorder_channels" title="mne.time_frequency.AverageTFR.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a>(ch_names)</td>
<td>Reorder channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.time_frequency.AverageTFR.save" title="mne.time_frequency.AverageTFR.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(fname[,&nbsp;overwrite])</td>
<td>Save TFR object to hdf5 file.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.time_frequency.AverageTFR.__add__">
<code class="descname">__add__</code><span class="sig-paren">(</span><em>tfr</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L1909-L1914"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Add instances.</p>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>ch_type</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L163-L191"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check channel type membership.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Channel type to check for. Can be e.g. ‘meg’, ‘eeg’, ‘stim’, etc.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether or not the instance contains the given channel type.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Channel type membership can be tested as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;meg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;seeg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/utils.py#L2348-L2365"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hash</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The hash</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.__sub__">
<code class="descname">__sub__</code><span class="sig-paren">(</span><em>tfr</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L1921-L1926"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract instances.</p>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.add_channels">
<code class="descname">add_channels</code><span class="sig-paren">(</span><em>add_list</em>, <em>force_update_info=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L822-L910"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>add_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of objects to append to self. Must contain all the same
type as the current object</p>
</dd>
<dt><strong>force_update_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If True, force the info for objects to be appended to match the
values in <cite>self</cite>. This should generally only be used when adding
stim channels for which important metadata won’t be overwritten.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.time_frequency.AverageTFR.drop_channels" title="mne.time_frequency.AverageTFR.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a Raw instance that has been preloaded into a
<a class="reference external" href="https://www.numpy.org/devdocs/reference/generated/numpy.memmap.html#numpy.memmap" title="(in NumPy v1.17.dev0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.memmap</span></code></a> instance, the memmap will be resized.</p>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.apply_baseline">
<code class="descname">apply_baseline</code><span class="sig-paren">(</span><em>baseline</em>, <em>mode='mean'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L904-L943"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.apply_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseline correct the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple or list of length 2</span></dt>
<dd><p class="first last">The time interval to apply rescaling / baseline correction.
If None do not apply it. If baseline is (a, b)
the interval is between “a (s)” and “b (s)”.
If a is None the beginning of the data is used
and if b is None then b is set to the end of the interval.
If baseline is equal to (None, None) all the time
interval is used.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mean’ | ‘ratio’ | ‘logratio’ | ‘percent’ | ‘zscore’ | ‘zlogratio’</span></dt>
<dd><p class="first">Perform baseline correction by</p>
<ul class="last simple">
<li>subtracting the mean of baseline values (‘mean’)</li>
<li>dividing by the mean of baseline values (‘ratio’)</li>
<li>dividing by the mean of baseline values and taking the log
(‘logratio’)</li>
<li>subtracting the mean of baseline values followed by dividing by
the mean of baseline values (‘percent’)</li>
<li>subtracting the mean of baseline values and dividing by the
standard deviation of baseline values (‘zscore’)</li>
<li>dividing by the mean of baseline values, taking the log, and
dividing by the standard deviation of log baseline values
(‘zlogratio’)</li>
</ul>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of AverageTFR</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.time_frequency.AverageTFR.ch_names">
<code class="descname">ch_names</code><a class="headerlink" href="#mne.time_frequency.AverageTFR.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.time_frequency.AverageTFR.compensation_grade">
<code class="descname">compensation_grade</code><a class="headerlink" href="#mne.time_frequency.AverageTFR.compensation_grade" title="Permalink to this definition">¶</a></dt>
<dd><p>The current gradient compensation grade.</p>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L900-L902"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the instance.</p>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>tmin=None</em>, <em>tmax=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L880-L898"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop data to a given time interval in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Start time of selection in seconds.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">End time of selection in seconds.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of AverageTFR</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.drop_channels">
<code class="descname">drop_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L757-L798"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of the names of the channels to remove.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.time_frequency.AverageTFR.reorder_channels" title="mne.time_frequency.AverageTFR.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a>, <a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_channels" title="mne.time_frequency.AverageTFR.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a>, <a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_types" title="mne.time_frequency.AverageTFR.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.pick_channels">
<code class="descname">pick_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L692-L720"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The list of channels to select.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.time_frequency.AverageTFR.drop_channels" title="mne.time_frequency.AverageTFR.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>, <a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_types" title="mne.time_frequency.AverageTFR.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>, <a class="reference internal" href="#mne.time_frequency.AverageTFR.reorder_channels" title="mne.time_frequency.AverageTFR.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The channel names given are assumed to be a set, i.e. the order
does not matter. The original order of the channels is preserved.
You can use <code class="docutils literal notranslate"><span class="pre">reorder_channels</span></code> to set channel order if necessary.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.pick_types">
<code class="descname">pick_types</code><span class="sig-paren">(</span><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>dipole=False</em>, <em>gof=False</em>, <em>bio=False</em>, <em>ecog=False</em>, <em>fnirs=False</em>, <em>include=()</em>, <em>exclude='bads'</em>, <em>selection=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L601-L690"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>meg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">If True include all MEG channels. If False include None
If string it can be ‘mag’, ‘grad’, ‘planar1’ or ‘planar2’ to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</dd>
<dt><strong>eeg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EEG channels.</p>
</dd>
<dt><strong>stim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include stimulus channels.</p>
</dd>
<dt><strong>eog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EOG channels.</p>
</dd>
<dt><strong>ecg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include ECG channels.</p>
</dd>
<dt><strong>emg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EMG channels.</p>
</dd>
<dt><strong>ref_meg: bool | str</strong></dt>
<dd><p class="first last">If True include CTF / 4D reference channels. If ‘auto’, the
reference channels are only included if compensations are present.</p>
</dd>
<dt><strong>misc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include miscellaneous analog channels.</p>
</dd>
<dt><strong>resp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</dd>
<dt><strong>chpi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include continuous HPI coil channels.</p>
</dd>
<dt><strong>exci</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Flux excitation channel used to be a stimulus channel.</p>
</dd>
<dt><strong>ias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Internal Active Shielding data (maybe on Triux only).</p>
</dd>
<dt><strong>syst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">System status channel information (on Triux systems only).</p>
</dd>
<dt><strong>seeg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Stereotactic EEG channels.</p>
</dd>
<dt><strong>dipole</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Dipole time course channels.</p>
</dd>
<dt><strong>gof</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Dipole goodness of fit channels.</p>
</dd>
<dt><strong>bio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Bio channels.</p>
</dd>
<dt><strong>ecog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Electrocorticography channels.</p>
</dd>
<dt><strong>fnirs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Functional near-infrared spectroscopy channels. If True include all
fNIRS channels. If False (default) include none. If string it can
be ‘hbo’ (to include channels measuring oxyhemoglobin) or ‘hbr’ (to
include channels measuring deoxyhemoglobin).</p>
</dd>
<dt><strong>include</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">List of additional channels to include. If empty do not include
any.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string | str</span></dt>
<dd><p class="first last">List of channels to exclude. If ‘bads’ (default), exclude channels
in <code class="docutils literal notranslate"><span class="pre">info['bads']</span></code>.</p>
</dd>
<dt><strong>selection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_channels" title="mne.time_frequency.AverageTFR.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>picks=None</em>, <em>baseline=None</em>, <em>mode='mean'</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>fmin=None</em>, <em>fmax=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap='RdBu_r'</em>, <em>dB=False</em>, <em>colorbar=True</em>, <em>show=True</em>, <em>title=None</em>, <em>axes=None</em>, <em>layout=None</em>, <em>yscale='auto'</em>, <em>mask=None</em>, <em>mask_style=None</em>, <em>mask_cmap='Greys'</em>, <em>mask_alpha=0.1</em>, <em>combine=None</em>, <em>exclude=[]</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L1036-L1181"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot TFRs as a two-dimensional image(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | array-like of int</span></dt>
<dd><p class="first last">The indices of the channels to plot, one figure per channel. If
None, plot the across-channel average.</p>
</dd>
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None (default) or tuple of length 2</span></dt>
<dd><p class="first last">The time interval to apply baseline correction.
If None do not apply it. If baseline is (a, b)
the interval is between “a (s)” and “b (s)”.
If a is None the beginning of the data is used
and if b is None then b is set to the end of the interval.
If baseline is equal to (None, None) all the time
interval is used.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mean’ | ‘ratio’ | ‘logratio’ | ‘percent’ | ‘zscore’ | ‘zlogratio’</span></dt>
<dd><p class="first">Perform baseline correction by</p>
<ul class="last simple">
<li>subtracting the mean of baseline values (‘mean’)</li>
<li>dividing by the mean of baseline values (‘ratio’)</li>
<li>dividing by the mean of baseline values and taking the log
(‘logratio’)</li>
<li>subtracting the mean of baseline values followed by dividing by
the mean of baseline values (‘percent’)</li>
<li>subtracting the mean of baseline values and dividing by the
standard deviation of baseline values (‘zscore’)</li>
<li>dividing by the mean of baseline values, taking the log, and
dividing by the standard deviation of log baseline values
(‘zlogratio’)</li>
</ul>
</dd>
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first time instant to display. If None the first time point
available is used.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last time instant to display. If None the last time point
available is used.</p>
</dd>
<dt><strong>fmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first frequency to display. If None the first frequency
available is used.</p>
</dd>
<dt><strong>fmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last frequency to display. If None the last frequency
available is used.</p>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The minimum value an the color scale. If vmin is None, the data
minimum value is used.</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The maximum value an the color scale. If vmax is None, the data
maximum value is used.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | ‘interactive’ | (colormap, bool)</span></dt>
<dd><p class="first">The colormap to use. If tuple, the first value indicates the
colormap to use and the second value is a boolean defining
interactivity. In interactive mode the colors are adjustable by
clicking and dragging the colorbar with left and right mouse
button. Left mouse button moves the scale up and down and right
mouse button adjusts the range. Hitting space bar resets the range.
Up and down arrows can be used to change the colormap. If
‘interactive’, translates to (‘RdBu_r’, True). Defaults to
‘RdBu_r’.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Interactive mode works smoothly only for a small
amount of images.</p>
</div>
</dd>
<dt><strong>dB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, 10*log10 is applied to the data to get dB.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, colorbar will be added to the plot. For user defined axes,
the colorbar cannot be drawn. Defaults to True.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Call pyplot.show() at the end.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | ‘auto’ | None</span></dt>
<dd><p class="first last">String for title. Defaults to None (blank/no title). If ‘auto’,
automatically create a title that lists up to 6 of the channels
used in the figure.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axes | list | None</span></dt>
<dd><p class="first last">The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of channels. If instance of Axes,
there must be only one channel plotted.</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Layout | None</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions. Used for interactive
plotting of topographies on rectangle selection. If possible, the
correct layout is inferred from the data.</p>
</dd>
<dt><strong>yscale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘auto’ (default) | ‘linear’ | ‘log’</span></dt>
<dd><p class="first">The scale of y (frequency) axis. ‘linear’ gives linear y axis,
‘log’ leads to log-spaced y axis and ‘auto’ detects if frequencies
are log-spaced and only then sets the y axis to ‘log’.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.14.0.</span></p>
</div>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray | None</span></dt>
<dd><p class="first">An array of booleans of the same shape as the data. Entries of the
data that correspond to False in the mask are plotted
transparently. Useful for, e.g., masking for statistical
significance.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd>
<dt><strong>mask_style: None | ‘both’ | ‘contour’ | ‘mask’</strong></dt>
<dd><p class="first">If <cite>mask</cite> is not None: if ‘contour’, a contour line is drawn around
the masked areas (<code class="docutils literal notranslate"><span class="pre">True</span></code> in <cite>mask</cite>). If ‘mask’, entries not
<code class="docutils literal notranslate"><span class="pre">True</span></code> in <cite>mask</cite> are shown transparently. If ‘both’, both a contour
and transparency are used.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to ‘both’ if <cite>mask</cite> is not None, and is ignored
otherwise.</p>
<blockquote class="last">
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.17.</span></p>
</div>
</div></blockquote>
</dd>
<dt><strong>mask_cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’</span></dt>
<dd><p class="first">The colormap chosen for masked parts of the image (see below), if
<cite>mask</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>. If None, <cite>cmap</cite> is reused. Defaults to
<code class="docutils literal notranslate"><span class="pre">Greys</span></code>. Not interactive. Otherwise, as <cite>cmap</cite>.</p>
<blockquote class="last">
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.17.</span></p>
</div>
</div></blockquote>
</dd>
<dt><strong>mask_alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first">A float between 0 and 1. If <code class="docutils literal notranslate"><span class="pre">mask</span></code> is not None, this sets the
alpha level (degree of transparency) for the masked-out segments.
I.e., if 0, masked-out segments are not visible at all.
Defaults to 0.1.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd>
<dt><strong>combine</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mean’ | ‘rms’ | None</span></dt>
<dd><p class="first last">Type of aggregation to perform across selected channels. If
None, plot one figure per selected channel.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str | ‘bads’</span></dt>
<dd><p class="first last">Channels names to exclude from being shown. If ‘bads’, the
bad channels are excluded. Defaults to an empty list.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure containing the topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.plot_joint">
<code class="descname">plot_joint</code><span class="sig-paren">(</span><em>timefreqs=None</em>, <em>picks=None</em>, <em>baseline=None</em>, <em>mode='mean'</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>fmin=None</em>, <em>fmax=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap='RdBu_r'</em>, <em>dB=False</em>, <em>colorbar=True</em>, <em>show=True</em>, <em>title=None</em>, <em>layout=None</em>, <em>yscale='auto'</em>, <em>combine='mean'</em>, <em>exclude=[]</em>, <em>topomap_args=None</em>, <em>image_args=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L1260-L1577"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.plot_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot TFRs as a two-dimensional image with topomaps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>timefreqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of tuples | dict of tuples</span></dt>
<dd><p class="first last">The time-frequency point(s) for which topomaps will be plotted.
See Notes.</p>
</dd>
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | array-like of int</span></dt>
<dd><p class="first last">The indices of the channels to plot, one figure per channel. If
None, plot the across-channel aggregation (defaults to “mean”).</p>
</dd>
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None (default) or tuple of length 2</span></dt>
<dd><p class="first last">The time interval to apply baseline correction.
If None do not apply it. If baseline is (a, b)
the interval is between “a (s)” and “b (s)”.
If a is None, the beginning of the data is used.
If b is None, then b is set to the end of the interval.
If baseline is equal to (None, None), the  entire time
interval is used.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str</span></dt>
<dd><p class="first last">If str, must be one of ‘ratio’, ‘zscore’, ‘mean’, ‘percent’,
‘logratio’ and ‘zlogratio’.
Do baseline correction with ratio (power is divided by mean
power during baseline) or zscore (power is divided by standard
deviation of power during baseline after subtracting the mean,
power = [power - mean(power_baseline)] / std(power_baseline)),
mean simply subtracts the mean power, percent is the same as
applying ratio then mean, logratio is the same as mean but then
rendered in log-scale, zlogratio is the same as zscore but data
is rendered in log-scale first.
If None no baseline correction is applied.</p>
</dd>
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first time instant to display. If None the first time point
available is used.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last time instant to display. If None the last time point
available is used.</p>
</dd>
<dt><strong>fmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first frequency to display. If None the first frequency
available is used.</p>
</dd>
<dt><strong>fmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last frequency to display. If None the last frequency
available is used.</p>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The minimum value of the color scale for the image (for
topomaps, see <cite>topomap_args</cite>). If vmin is None, the data
absolute minimum value is used.</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The maximum value of the color scale for the image (for
topomaps, see <cite>topomap_args</cite>). If vmax is None, the data
absolute maximum value is used.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap</span></dt>
<dd><p class="first last">The colormap to use.</p>
</dd>
<dt><strong>dB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, 10*log10 is applied to the data to get dB.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, colorbar will be added to the plot (relating to the
topomaps). For user defined axes, the colorbar cannot be drawn.
Defaults to True.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Call pyplot.show() at the end.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">String for title. Defaults to None (blank/no title).</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Layout | None</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions. Used for interactive
plotting of topographies on rectangle selection. If possible, the
correct layout is inferred from the data.</p>
</dd>
<dt><strong>yscale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘auto’ (default) | ‘linear’ | ‘log’</span></dt>
<dd><p class="first last">The scale of y (frequency) axis. ‘linear’ gives linear y axis,
‘log’ leads to log-spaced y axis and ‘auto’ detects if frequencies
are log-spaced and only then sets the y axis to ‘log’.</p>
</dd>
<dt><strong>combine</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mean’ | ‘rms’</span></dt>
<dd><p class="first last">Type of aggregation to perform across selected channels.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str | ‘bads’</span></dt>
<dd><p class="first last">Channels names to exclude from being shown. If ‘bads’, the
bad channels are excluded. Defaults to an empty list, i.e., <cite>[]</cite>.</p>
</dd>
<dt><strong>topomap_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | dict</span></dt>
<dd><p class="first last">A dict of <cite>kwargs</cite> that are forwarded to
<a class="reference internal" href="mne.viz.plot_topomap.html#mne.viz.plot_topomap" title="mne.viz.plot_topomap"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_topomap()</span></code></a> to style the topomaps. <cite>axes</cite> and
<cite>show</cite> are ignored. If <cite>times</cite> is not in this dict, automatic
peak detection is used. Beyond that, if <code class="docutils literal notranslate"><span class="pre">None</span></code>, no customizable
arguments will be passed.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>image_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | dict</span></dt>
<dd><p class="first last">A dict of <cite>kwargs</cite> that are forwarded to <a class="reference internal" href="#mne.time_frequency.AverageTFR.plot" title="mne.time_frequency.AverageTFR.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">AverageTFR.plot()</span></code></a>
to style the image. <cite>axes</cite> and <cite>show</cite> are ignored. Beyond that,
if <code class="docutils literal notranslate"><span class="pre">None</span></code>, no customizable arguments will be passed.
Defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure containing the topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p><cite>timefreqs</cite> has three different modes: tuples, dicts, and auto.
For (list of) tuple(s) mode, each tuple defines a pair
(time, frequency) in s and Hz on the TFR plot. For example, to
look at 10 Hz activity 1 second into the epoch and 3 Hz activity
300 msec into the epoch,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">timefreqs</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>If provided as a dictionary, (time, frequency) tuples are keys and
(time_window, frequency_window) tuples are the values - indicating the
width of the windows (centered on the time and frequency indicated by
the key) to be averaged over. For example,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">timefreqs</span><span class="o">=</span><span class="p">{(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)}</span>
</pre></div>
</div>
<p>would translate into a window that spans 0.95 to 1.05 seconds, as
well as 9 to 11 Hz. If None, a single topomap will be plotted at the
absolute peak across the time-frequency representation.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.plot_topo">
<code class="descname">plot_topo</code><span class="sig-paren">(</span><em>picks=None</em>, <em>baseline=None</em>, <em>mode='mean'</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>fmin=None</em>, <em>fmax=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>layout=None</em>, <em>cmap='RdBu_r'</em>, <em>title=None</em>, <em>dB=False</em>, <em>colorbar=True</em>, <em>layout_scale=0.945</em>, <em>show=True</em>, <em>border='none'</em>, <em>fig_facecolor='k'</em>, <em>fig_background=None</em>, <em>font_color='w'</em>, <em>yscale='auto'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L1635-L1759"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.plot_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot TFRs in a topography with images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">The indices of the channels to plot. If None, all available
channels are displayed.</p>
</dd>
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None (default) or tuple of length 2</span></dt>
<dd><p class="first last">The time interval to apply baseline correction.
If None do not apply it. If baseline is (a, b)
the interval is between “a (s)” and “b (s)”.
If a is None the beginning of the data is used
and if b is None then b is set to the end of the interval.
If baseline is equal to (None, None) all the time
interval is used.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mean’ | ‘ratio’ | ‘logratio’ | ‘percent’ | ‘zscore’ | ‘zlogratio’</span></dt>
<dd><p class="first">Perform baseline correction by</p>
<ul class="last simple">
<li>subtracting the mean of baseline values (‘mean’)</li>
<li>dividing by the mean of baseline values (‘ratio’)</li>
<li>dividing by the mean of baseline values and taking the log
(‘logratio’)</li>
<li>subtracting the mean of baseline values followed by dividing by
the mean of baseline values (‘percent’)</li>
<li>subtracting the mean of baseline values and dividing by the
standard deviation of baseline values (‘zscore’)</li>
<li>dividing by the mean of baseline values, taking the log, and
dividing by the standard deviation of log baseline values
(‘zlogratio’)</li>
</ul>
</dd>
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first time instant to display. If None the first time point
available is used.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last time instant to display. If None the last time point
available is used.</p>
</dd>
<dt><strong>fmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first frequency to display. If None the first frequency
available is used.</p>
</dd>
<dt><strong>fmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last frequency to display. If None the last frequency
available is used.</p>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The minimum value of the color scale. If vmin is None, the data
minimum value is used.</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The maximum value of the color scale. If vmax is None, the data
maximum value is used.</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Layout | None</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions. If possible, the
correct layout is inferred from the data.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | str</span></dt>
<dd><p class="first last">The colormap to use. Defaults to ‘RdBu_r’.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Title of the figure.</p>
</dd>
<dt><strong>dB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, 10*log10 is applied to the data to get dB.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, colorbar will be added to the plot</p>
</dd>
<dt><strong>layout_scale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling factor for adjusting the relative size of the layout
on the canvas.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Call pyplot.show() at the end.</p>
</dd>
<dt><strong>border</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">matplotlib borders style to be used for each sensor plot.</p>
</dd>
<dt><strong>fig_facecolor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | obj</span></dt>
<dd><p class="first last">The figure face color. Defaults to black.</p>
</dd>
<dt><strong>fig_background</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | array</span></dt>
<dd><p class="first last">A background image for the figure. This must be a valid input to
<cite>matplotlib.pyplot.imshow</cite>. Defaults to None.</p>
</dd>
<dt><strong>font_color: str | obj</strong></dt>
<dd><p class="first last">The color of tick labels in the colorbar. Defaults to white.</p>
</dd>
<dt><strong>yscale</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘auto’ (default) | ‘linear’ | ‘log’</span></dt>
<dd><p class="first last">The scale of y (frequency) axis. ‘linear’ gives linear y axis,
‘log’ leads to log-spaced y axis and ‘auto’ detects if frequencies
are log-spaced and only then sets the y axis to ‘log’.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure containing the topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.plot_topomap">
<code class="descname">plot_topomap</code><span class="sig-paren">(</span><em>tmin=None</em>, <em>tmax=None</em>, <em>fmin=None</em>, <em>fmax=None</em>, <em>ch_type=None</em>, <em>baseline=None</em>, <em>mode='mean'</em>, <em>layout=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap=None</em>, <em>sensors=True</em>, <em>colorbar=True</em>, <em>unit=None</em>, <em>res=64</em>, <em>size=2</em>, <em>cbar_fmt='%1.1e'</em>, <em>show_names=False</em>, <em>title=None</em>, <em>axes=None</em>, <em>show=True</em>, <em>outlines='head'</em>, <em>head_pos=None</em>, <em>contours=6</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L1761-L1902"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.plot_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topographic maps of time-frequency intervals of TFR data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first time instant to display. If None the first time point
available is used.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last time instant to display. If None the last time point
available is used.</p>
</dd>
<dt><strong>fmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The first frequency to display. If None the first frequency
available is used.</p>
</dd>
<dt><strong>fmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float</span></dt>
<dd><p class="first last">The last frequency to display. If None the last frequency
available is used.</p>
</dd>
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None</span></dt>
<dd><p class="first last">The channel type to plot. For ‘grad’, the gradiometers are
collected in pairs and the RMS for each pair is plotted.
If None, then first available channel type from order given
above is used. Defaults to None.</p>
</dd>
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple or list of length 2</span></dt>
<dd><p class="first last">The time interval to apply rescaling / baseline correction.
If None do not apply it. If baseline is (a, b)
the interval is between “a (s)” and “b (s)”.
If a is None the beginning of the data is used
and if b is None then b is set to the end of the interval.
If baseline is equal to (None, None) all the time
interval is used.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mean’ | ‘ratio’ | ‘logratio’ | ‘percent’ | ‘zscore’ | ‘zlogratio’</span></dt>
<dd><p class="first">Perform baseline correction by</p>
<ul class="last simple">
<li>subtracting the mean of baseline values (‘mean’)</li>
<li>dividing by the mean of baseline values (‘ratio’)</li>
<li>dividing by the mean of baseline values and taking the log
(‘logratio’)</li>
<li>subtracting the mean of baseline values followed by dividing by
the mean of baseline values (‘percent’)</li>
<li>subtracting the mean of baseline values and dividing by the
standard deviation of baseline values (‘zscore’)</li>
<li>dividing by the mean of baseline values, taking the log, and
dividing by the standard deviation of log baseline values
(‘zlogratio’)</li>
</ul>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | Layout</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout
file is inferred from the data; if no appropriate layout file was
found, the layout is automatically generated from the sensor
locations.</p>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | callable | None</span></dt>
<dd><p class="first last">The value specifying the lower bound of the color range. If None,
and vmax is None, -vmax is used. Else np.min(data) or in case
data contains only positive values 0. If callable, the output
equals vmin(data). Defaults to None.</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | callable | None</span></dt>
<dd><p class="first last">The value specifying the upper bound of the color range. If None,
the maximum value is used. If callable, the output equals
vmax(data). Defaults to None.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’ | None</span></dt>
<dd><p class="first last">Colormap to use. If tuple, the first value indicates the colormap
to use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging
the colorbar with left and right mouse button. Left mouse button
moves the scale up and down and right mouse button adjusts the
range. Hitting space bar resets the range. Up and down arrows can
be used to change the colormap. If None (default), ‘Reds’ is used
for all positive data, otherwise defaults to ‘RdBu_r’. If
‘interactive’, translates to (None, True).</p>
</dd>
<dt><strong>sensors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., ‘r+’ for red plusses). If True, a circle
will be used (via .add_artist). Defaults to True.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Plot a colorbar.</p>
</dd>
<dt><strong>unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | str | None</span></dt>
<dd><p class="first last">The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</dd>
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The resolution of the topomap image (n pixels along each side).</p>
</dd>
<dt><strong>size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Side length per topomap in inches.</p>
</dd>
<dt><strong>cbar_fmt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">String format for colorbar values.</p>
</dd>
<dt><strong>show_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | callable</span></dt>
<dd><p class="first last">If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g.,
to delete the prefix ‘MEG ‘ from all channel names, pass the
function lambda x: x.replace(‘MEG ‘, ‘’). If <cite>mask</cite> is not None,
only significant sensors will be shown.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Title. If None (default), no title is displayed.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axes | None</span></dt>
<dd><p class="first last">The axes to plot to. If None the axes is defined automatically.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Call pyplot.show() at the end.</p>
</dd>
<dt><strong>outlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘head’ | ‘skirt’ | dict | None</span></dt>
<dd><p class="first last">The outlines to be drawn. If ‘head’, the default head scheme will
be drawn. If ‘skirt’ the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in ‘mask_pos’
will serve as image mask, and the ‘autoshrink’ (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to ‘head’.</p>
</dd>
<dt><strong>head_pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries ‘center’ (tuple) and
‘scale’ (tuple) for what the center and scale of the head should be
relative to the electrode locations.</p>
</dd>
<dt><strong>contours</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | array of float</span></dt>
<dd><p class="first last">The number of contour lines to draw. If 0, no contours will be
drawn. When an integer, matplotlib ticker locator is used to find
suitable values for the contour thresholds (may sometimes be
inaccurate, use array for accuracy). If an array, the values
represent the levels for the contours. If colorbar=True, the ticks
in colorbar correspond to the contour levels. Defaults to 6.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure containing the topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.reorder_channels">
<code class="descname">reorder_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L722-L755"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.reorder_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The desired channel order.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.time_frequency.AverageTFR.drop_channels" title="mne.time_frequency.AverageTFR.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>, <a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_types" title="mne.time_frequency.AverageTFR.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>, <a class="reference internal" href="#mne.time_frequency.AverageTFR.pick_channels" title="mne.time_frequency.AverageTFR.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Channel names must be unique. Channels that are not in <code class="docutils literal notranslate"><span class="pre">ch_names</span></code>
are dropped.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.time_frequency.AverageTFR.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em>, <em>overwrite=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/time_frequency/tfr.py#L945-L955"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.time_frequency.AverageTFR.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save TFR object to hdf5 file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The file name, which should end with -tfr.h5 .</p>
</dd>
<dt><strong>overwrite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, overwrite file (if it exists). Defaults to false</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><img src="../_static/institutions.png" alt="Institutions"></div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-02-22.</p>
  </div>
</footer>
<script src="https://mne.tools/versionwarning.js"></script>
  </body>
</html>