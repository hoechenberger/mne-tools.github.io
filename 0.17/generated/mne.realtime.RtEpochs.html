<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>mne.realtime.RtEpochs &#8212; MNE 0.17.1 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/reset-syntax.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <script type="text/javascript" src="../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flag-icon.css" type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  <link rel="canonical" href="https://mne.tools/stable/index.html" />
</head><body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.17.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Install</a></li>
                <li><a href="../documentation.html">Documentation</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../glossary.html">Glossary</a></li>
                <li><a href="../auto_examples/index.html">Examples</a></li>
                <li><a href="../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-primary navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.17.1
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
    <li><a href="https://mne-tools.github.io/stable/index.html">v0.17 (stable)</a></li>
    <li><a href="https://mne-tools.github.io/0.16/index.html">v0.16</a></li>
    <li><a href="https://mne-tools.github.io/0.15/index.html">v0.15</a></li>
    <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
    <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
    <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
    <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.realtime.RtEpochs</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="mne-realtime-rtepochs">
<h1>mne.realtime.RtEpochs<a class="headerlink" href="#mne-realtime-rtepochs" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.realtime.RtEpochs">
<em class="property">class </em><code class="descclassname">mne.realtime.</code><code class="descname">RtEpochs</code><span class="sig-paren">(</span><em>client</em>, <em>event_id</em>, <em>tmin</em>, <em>tmax</em>, <em>stim_channel='STI 014'</em>, <em>sleep_time=0.1</em>, <em>baseline=(None</em>, <em>0)</em>, <em>picks=None</em>, <em>reject=None</em>, <em>flat=None</em>, <em>proj=True</em>, <em>decim=1</em>, <em>reject_tmin=None</em>, <em>reject_tmax=None</em>, <em>detrend=None</em>, <em>isi_max=2.0</em>, <em>find_events=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/realtime/epochs.py#L19-L583"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs" title="Permalink to this definition">¶</a></dt>
<dd><p>Realtime Epochs.</p>
<p>Can receive epochs in real time from an RtClient.</p>
<p>For example, to get some epochs from a running mne_rt_server on
‘localhost’, you could use:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">client</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">realtime</span><span class="o">.</span><span class="n">RtClient</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">)</span>
<span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span>

<span class="n">epochs</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">realtime</span><span class="o">.</span><span class="n">RtEpochs</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">)</span>
<span class="n">epochs</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>  <span class="c1"># start the measurement and start receiving epochs</span>

<span class="n">evoked_1</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">average</span><span class="p">()</span>  <span class="c1"># computed over all epochs</span>
<span class="n">evoked_2</span> <span class="o">=</span> <span class="n">epochs</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="o">.</span><span class="n">average</span><span class="p">()</span>  <span class="c1"># computed over the last 5 epochs</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>client</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of mne.realtime.RtClient</span></dt>
<dd><p class="first last">The realtime client.</p>
</dd>
<dt><strong>event_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | list of int</span></dt>
<dd><p class="first last">The id of the event to consider. If int, only events with the
ID specified by event_id are considered. Multiple event ID’s
can be specified using a list.</p>
</dd>
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Start time before event.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">End time after event.</p>
</dd>
<dt><strong>stim_channel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or list of string</span></dt>
<dd><p class="first last">Name of the stim channel or all the stim channels affected by
the trigger.</p>
</dd>
<dt><strong>sleep_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Time in seconds to wait between checking for new epochs when epochs
are requested and the receive queue is empty.</p>
</dd>
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None (default) or tuple of length 2</span></dt>
<dd><p class="first last">The time interval to apply baseline correction.
If None do not apply it. If baseline is (a, b)
the interval is between “a (s)” and “b (s)”.
If a is None the beginning of the data is used
and if b is None then b is set to the end of the interval.
If baseline is equal to (None, None) all the time
interval is used.</p>
</dd>
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None (default)</span></dt>
<dd><p class="first last">Indices of channels to include (if None, all channels are used).</p>
</dd>
<dt><strong>reject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first">Rejection parameters based on peak-to-peak amplitude.
Valid keys are ‘grad’ | ‘mag’ | ‘eeg’ | ‘eog’ | ‘ecg’.
If reject is None then no rejection is done. Example:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reject</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">grad</span><span class="o">=</span><span class="mf">4000e-13</span><span class="p">,</span> <span class="c1"># T / m (gradiometers)</span>
              <span class="n">mag</span><span class="o">=</span><span class="mf">4e-12</span><span class="p">,</span> <span class="c1"># T (magnetometers)</span>
              <span class="n">eeg</span><span class="o">=</span><span class="mf">40e-6</span><span class="p">,</span> <span class="c1"># V (EEG channels)</span>
              <span class="n">eog</span><span class="o">=</span><span class="mf">250e-6</span> <span class="c1"># V (EOG channels))</span>
</pre></div>
</div>
</dd>
<dt><strong>flat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">Rejection parameters based on flatness of signal.
Valid keys are ‘grad’ | ‘mag’ | ‘eeg’ | ‘eog’ | ‘ecg’, and values
are floats that set the minimum acceptable peak-to-peak amplitude.
If flat is None then no rejection is done.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Apply SSP projection vectors</p>
</dd>
<dt><strong>decim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Factor by which to downsample the data from the raw file upon import.
Warning: This simply selects every nth sample, data is not filtered
here. If data is not properly filtered, aliasing artifacts may occur.</p>
</dd>
<dt><strong>reject_tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | None</span></dt>
<dd><p class="first last">Start of the time window used to reject epochs (with the default None,
the window will start with tmin).</p>
</dd>
<dt><strong>reject_tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar | None</span></dt>
<dd><p class="first last">End of the time window used to reject epochs (with the default None,
the window will end with tmax).</p>
</dd>
<dt><strong>detrend</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">If 0 or 1, the data channels (MEG and EEG) will be detrended when
loaded. 0 is a constant (DC) detrend, 1 is a linear detrend. None
is no detrending. Note that detrending is performed before baseline
correction. If no DC offset is preferred (zeroth order detrending),
either turn off baseline correction, as this may introduce a DC
shift, or set baseline correction to use the entire time interval
(will yield equivalent results but be slower).</p>
</dd>
<dt><strong>isi_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The maximum time in seconds between epochs. If no epoch
arrives in the next isi_max seconds the RtEpochs stops.</p>
</dd>
<dt><strong>find_events</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">The arguments to the real-time <cite>find_events</cite> method as a dictionary.
If <cite>find_events</cite> is None, then default values are used.
Example (also default values):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">find_events</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;onset&#39;</span><span class="p">,</span> <span class="n">consecutive</span><span class="o">=</span><span class="s1">&#39;increasing&#39;</span><span class="p">,</span>
                   <span class="n">min_duration</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask_type</span><span class="o">=</span><span class="s1">&#39;not_and&#39;</span><span class="p">,</span>
                   <span class="n">verbose</span><span class="o">=</span><span class="s1">&#39;ERROR&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">See <a class="reference internal" href="mne.find_events.html#mne.find_events" title="mne.find_events"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.find_events()</span></code></a> for detailed explanation of these options.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more). Defaults to
client.verbose.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<ul class="simple">
<li>Calling <cite>next()</cite> on an <cite>RtEpochs</cite> object (as internally done when
iterating over the object) is blocking, i.e., waits for at most <cite>isi_max</cite>
seconds for a new epoch to be received.</li>
<li>Calling <cite>get_data()</cite> on an <cite>RtEpochs</cite> object immediately returns the
epochs received so far (without waiting for new epochs).</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Measurement info.</p>
</dd>
<dt><strong>event_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Names of  of conditions corresponding to event_ids.</p>
</dd>
<dt><a class="reference internal" href="#mne.realtime.RtEpochs.ch_names" title="mne.realtime.RtEpochs.ch_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ch_names</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">Channel names.</p>
</dd>
<dt><a class="reference internal" href="#mne.realtime.RtEpochs.events" title="mne.realtime.RtEpochs.events"><code class="xref py py-obj docutils literal notranslate"><span class="pre">events</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (n_events, 3)</span></dt>
<dd><p class="first last">The events associated with the epochs currently in the queue.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">See above.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.__contains__" title="mne.realtime.RtEpochs.__contains__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__contains__</span></code></a>(ch_type)</td>
<td>Check channel type membership.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.__getitem__" title="mne.realtime.RtEpochs.__getitem__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__getitem__</span></code></a>(item)</td>
<td>Return an Epochs object with a copied subset of epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.__hash__" title="mne.realtime.RtEpochs.__hash__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__hash__</span></code></a>()</td>
<td>Hash the object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.__iter__" title="mne.realtime.RtEpochs.__iter__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__iter__</span></code></a>()</td>
<td>Facilitate iteration over epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.__len__" title="mne.realtime.RtEpochs.__len__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__len__</span></code></a>()</td>
<td>Return the number of epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.add_channels" title="mne.realtime.RtEpochs.add_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_channels</span></code></a>(add_list[,&nbsp;force_update_info])</td>
<td>Append new channels to the instance.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.add_proj" title="mne.realtime.RtEpochs.add_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_proj</span></code></a>(projs[,&nbsp;remove_existing,&nbsp;verbose])</td>
<td>Add SSP projection vectors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.anonymize" title="mne.realtime.RtEpochs.anonymize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">anonymize</span></code></a>()</td>
<td>Anonymize measurement information in place.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.apply_baseline" title="mne.realtime.RtEpochs.apply_baseline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_baseline</span></code></a>([baseline,&nbsp;verbose])</td>
<td>Baseline correct epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.apply_proj" title="mne.realtime.RtEpochs.apply_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_proj</span></code></a>()</td>
<td>Apply the signal space projection (SSP) operators to the data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.average" title="mne.realtime.RtEpochs.average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">average</span></code></a>([picks,&nbsp;method])</td>
<td>Compute an average over epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.copy" title="mne.realtime.RtEpochs.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Return copy of Epochs instance.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.crop" title="mne.realtime.RtEpochs.crop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code></a>([tmin,&nbsp;tmax])</td>
<td>Crop a time interval from the epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.decimate" title="mne.realtime.RtEpochs.decimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code></a>(decim[,&nbsp;offset,&nbsp;verbose])</td>
<td>Decimate the epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.del_proj" title="mne.realtime.RtEpochs.del_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">del_proj</span></code></a>([idx])</td>
<td>Remove SSP projection vector.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.drop" title="mne.realtime.RtEpochs.drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop</span></code></a>(indices[,&nbsp;reason,&nbsp;verbose])</td>
<td>Drop epochs based on indices or boolean mask.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.drop_bad" title="mne.realtime.RtEpochs.drop_bad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_bad</span></code></a>([reject,&nbsp;flat,&nbsp;verbose])</td>
<td>Drop bad epochs without retaining the epochs data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.drop_channels" title="mne.realtime.RtEpochs.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>(ch_names)</td>
<td>Drop some channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.drop_log_stats" title="mne.realtime.RtEpochs.drop_log_stats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_log_stats</span></code></a>([ignore])</td>
<td>Compute the channel stats based on a drop_log from Epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.equalize_event_counts" title="mne.realtime.RtEpochs.equalize_event_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equalize_event_counts</span></code></a>(event_ids[,&nbsp;method])</td>
<td>Equalize the number of trials in each condition.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.filter" title="mne.realtime.RtEpochs.filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter</span></code></a>(l_freq,&nbsp;h_freq[,&nbsp;picks,&nbsp;…])</td>
<td>Filter a subset of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.get_data" title="mne.realtime.RtEpochs.get_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_data</span></code></a>()</td>
<td>Get all epochs as a 3D array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.interpolate_bads" title="mne.realtime.RtEpochs.interpolate_bads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_bads</span></code></a>([reset_bads,&nbsp;mode,&nbsp;origin,&nbsp;…])</td>
<td>Interpolate bad MEG and EEG channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.iter_evoked" title="mne.realtime.RtEpochs.iter_evoked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_evoked</span></code></a>()</td>
<td>Iterate over epochs as a sequence of Evoked objects.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.load_data" title="mne.realtime.RtEpochs.load_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_data</span></code></a>()</td>
<td>Load the data if not already preloaded.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.next" title="mne.realtime.RtEpochs.next"><code class="xref py py-obj docutils literal notranslate"><span class="pre">next</span></code></a>([return_event_id,&nbsp;verbose])</td>
<td>Make iteration over epochs easy.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.pick_channels" title="mne.realtime.RtEpochs.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a>(ch_names)</td>
<td>Pick some channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.pick_types" title="mne.realtime.RtEpochs.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;…])</td>
<td>Pick some channels by type and names.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot" title="mne.realtime.RtEpochs.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>([picks,&nbsp;scalings,&nbsp;n_epochs,&nbsp;…])</td>
<td>Visualize epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot_drop_log" title="mne.realtime.RtEpochs.plot_drop_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_drop_log</span></code></a>([threshold,&nbsp;n_max_plot,&nbsp;…])</td>
<td>Show the channel stats based on a drop_log from Epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot_image" title="mne.realtime.RtEpochs.plot_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_image</span></code></a>([picks,&nbsp;sigma,&nbsp;vmin,&nbsp;vmax,&nbsp;…])</td>
<td>Plot Event Related Potential / Fields image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot_projs_topomap" title="mne.realtime.RtEpochs.plot_projs_topomap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_projs_topomap</span></code></a>([ch_type,&nbsp;layout,&nbsp;axes])</td>
<td>Plot SSP vector.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot_psd" title="mne.realtime.RtEpochs.plot_psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_psd</span></code></a>([fmin,&nbsp;fmax,&nbsp;tmin,&nbsp;tmax,&nbsp;proj,&nbsp;…])</td>
<td>Plot the power spectral density across epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot_psd_topomap" title="mne.realtime.RtEpochs.plot_psd_topomap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_psd_topomap</span></code></a>([bands,&nbsp;vmin,&nbsp;vmax,&nbsp;tmin,&nbsp;…])</td>
<td>Plot the topomap of the power spectral density across epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot_sensors" title="mne.realtime.RtEpochs.plot_sensors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_sensors</span></code></a>([kind,&nbsp;ch_type,&nbsp;title,&nbsp;…])</td>
<td>Plot sensor positions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.plot_topo_image" title="mne.realtime.RtEpochs.plot_topo_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_topo_image</span></code></a>([layout,&nbsp;sigma,&nbsp;vmin,&nbsp;vmax,&nbsp;…])</td>
<td>Plot Event Related Potential / Fields image on topographies.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.rename_channels" title="mne.realtime.RtEpochs.rename_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename_channels</span></code></a>(mapping)</td>
<td>Rename channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.reorder_channels" title="mne.realtime.RtEpochs.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a>(ch_names)</td>
<td>Reorder channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.resample" title="mne.realtime.RtEpochs.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sfreq[,&nbsp;npad,&nbsp;window,&nbsp;n_jobs,&nbsp;pad,&nbsp;…])</td>
<td>Resample data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.save" title="mne.realtime.RtEpochs.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(fname[,&nbsp;split_size,&nbsp;fmt,&nbsp;verbose])</td>
<td>Save epochs in a fif file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.savgol_filter" title="mne.realtime.RtEpochs.savgol_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">savgol_filter</span></code></a>(h_freq[,&nbsp;verbose])</td>
<td>Filter the data using Savitzky-Golay polynomial method.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.set_channel_types" title="mne.realtime.RtEpochs.set_channel_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_channel_types</span></code></a>(mapping)</td>
<td>Define the sensor type of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.set_eeg_reference" title="mne.realtime.RtEpochs.set_eeg_reference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_eeg_reference</span></code></a>([ref_channels,&nbsp;…])</td>
<td>Specify which reference to use for EEG data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.set_montage" title="mne.realtime.RtEpochs.set_montage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_montage</span></code></a>(montage[,&nbsp;set_dig,&nbsp;verbose])</td>
<td>Set EEG sensor configuration and head digitization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.shift_time" title="mne.realtime.RtEpochs.shift_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shift_time</span></code></a>(tshift[,&nbsp;relative])</td>
<td>Shift time scale in epoched data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.standard_error" title="mne.realtime.RtEpochs.standard_error"><code class="xref py py-obj docutils literal notranslate"><span class="pre">standard_error</span></code></a>([picks])</td>
<td>Compute standard error over epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.start" title="mne.realtime.RtEpochs.start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start</span></code></a>()</td>
<td>Start receiving epochs.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.stop" title="mne.realtime.RtEpochs.stop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stop</span></code></a>([stop_receive_thread,&nbsp;stop_measurement])</td>
<td>Stop receiving epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.subtract_evoked" title="mne.realtime.RtEpochs.subtract_evoked"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subtract_evoked</span></code></a>([evoked])</td>
<td>Subtract an evoked response from each epoch.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.realtime.RtEpochs.time_as_index" title="mne.realtime.RtEpochs.time_as_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time_as_index</span></code></a>(times[,&nbsp;use_rounding])</td>
<td>Convert time to indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.realtime.RtEpochs.to_data_frame" title="mne.realtime.RtEpochs.to_data_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_data_frame</span></code></a>([picks,&nbsp;index,&nbsp;scaling_time,&nbsp;…])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.realtime.RtEpochs.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>ch_type</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L163-L191"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check channel type membership.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Channel type to check for. Can be e.g. ‘meg’, ‘eeg’, ‘stim’, etc.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether or not the instance contains the given channel type.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Channel type membership can be tested as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;meg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;seeg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1508-L1560"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an Epochs object with a copied subset of epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>item</strong> <span class="classifier-delimiter">:</span> <span class="classifier">slice, array-like, str, or list</span></dt>
<dd><p class="first last">See below for use cases.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">See below for use cases.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Epochs can be accessed as <code class="docutils literal notranslate"><span class="pre">epochs[...]</span></code> in several ways:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">epochs[idx]</span></code>: Return <code class="docutils literal notranslate"><span class="pre">Epochs</span></code> object with a subset of
epochs (supports single index and python-style slicing).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">epochs['name']</span></code>: Return <code class="docutils literal notranslate"><span class="pre">Epochs</span></code> object with a copy of the
subset of epochs corresponding to an experimental condition as
specified by ‘name’.</p>
<p>If conditions are tagged by names separated by ‘/’ (e.g.
‘audio/left’, ‘audio/right’), and ‘name’ is not in itself an
event key, this selects every event whose condition contains
the ‘name’ tag (e.g., ‘left’ matches ‘audio/left’ and
‘visual/left’; but not ‘audio_left’). Note that tags selection
is insensitive to order: tags like ‘auditory/left’ and
‘left/auditory’ will be treated the same way when accessed.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">epochs[['name_1',</span> <span class="pre">'name_2',</span> <span class="pre">...</span> <span class="pre">]]</span></code>: Return <code class="docutils literal notranslate"><span class="pre">Epochs</span></code> object
with a copy of the subset of epochs corresponding to multiple
experimental conditions as specified by
<code class="docutils literal notranslate"><span class="pre">'name_1',</span> <span class="pre">'name_2',</span> <span class="pre">...</span></code> .</p>
<p>If conditions are separated by ‘/’, selects every item
containing every list tag (e.g. [‘audio’, ‘left’] selects
‘audio/left’ and ‘audio/center/left’, but not ‘audio/right’).</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">epochs['pandas</span> <span class="pre">query']</span></code>: Return <code class="docutils literal notranslate"><span class="pre">Epochs</span></code> object with a
copy of the subset of epochs (and matching metadata) that match
<code class="docutils literal notranslate"><span class="pre">pandas</span> <span class="pre">query</span></code> called with <code class="docutils literal notranslate"><span class="pre">self.metadata.eval</span></code>, e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">epochs</span><span class="p">[</span><span class="s2">&quot;col_a &gt; 2 and col_b == &#39;foo&#39;&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>This is only called if Pandas is installed and <code class="docutils literal notranslate"><span class="pre">self.metadata</span></code>
is a <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame" title="(in pandas v0.24.1)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/utils.py#L2348-L2365"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hash</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The hash</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1363-L1383"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Facilitate iteration over epochs.</p>
<p>This method resets the object iteration state to the first epoch.</p>
<p class="rubric">Notes</p>
<p>This enables the use of this Python pattern:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">:</span>  
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>  
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">epoch</span></code> is given by successive outputs of
<a class="reference internal" href="mne.Epochs.html#mne.Epochs.next" title="mne.Epochs.next"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.next()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1331-L1361"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n_epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of remaining epochs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function only works if bad epochs have been dropped.</p>
<p class="rubric">Examples</p>
<p>This can be used as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">epochs</span><span class="o">.</span><span class="n">drop_bad</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>  
<span class="go">43</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>  
<span class="go">43</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.add_channels">
<code class="descname">add_channels</code><span class="sig-paren">(</span><em>add_list</em>, <em>force_update_info=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L822-L910"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>add_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of objects to append to self. Must contain all the same
type as the current object</p>
</dd>
<dt><strong>force_update_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If True, force the info for objects to be appended to match the
values in <cite>self</cite>. This should generally only be used when adding
stim channels for which important metadata won’t be overwritten.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.realtime.RtEpochs.drop_channels" title="mne.realtime.RtEpochs.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a Raw instance that has been preloaded into a
<a class="reference external" href="https://www.numpy.org/devdocs/reference/generated/numpy.memmap.html#numpy.memmap" title="(in NumPy v1.17.dev0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.memmap</span></code></a> instance, the memmap will be resized.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.add_proj">
<code class="descname">add_proj</code><span class="sig-paren">(</span><em>projs</em>, <em>remove_existing=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L150-L191"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>projs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List with projection vectors.</p>
</dd>
<dt><strong>remove_existing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Remove the projection vectors currently in the file.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd><p class="first last">The data container.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.anonymize">
<code class="descname">anonymize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L583-L595"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.anonymize" title="Permalink to this definition">¶</a></dt>
<dd><p>Anonymize measurement information in place.</p>
<p>Reset ‘subject_info’, ‘meas_date’, ‘file_id’, and ‘meas_id’ keys if they
exist in <code class="docutils literal notranslate"><span class="pre">info</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Info</span></dt>
<dd><p class="first last">Measurement information for the dataset.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.apply_baseline">
<code class="descname">apply_baseline</code><span class="sig-paren">(</span><em>baseline=(None</em>, <em>0)</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L572-L613"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.apply_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseline correct epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of length 2</span></dt>
<dd><p class="first last">The time interval to apply baseline correction. If None do not
apply it. If baseline is (a, b) the interval is between “a (s)” and
“b (s)”. If a is None the beginning of the data is used and if b is
None then b is set to the end of the interval. If baseline is equal
to (None, None) all the time interval is used. Correction is
applied by computing mean of the baseline period and subtracting it
from the data. The baseline (a, b) includes both endpoints, i.e.
all timepoints t such that a &lt;= t &lt;= b.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The baseline-corrected Epochs object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Baseline correction can be done multiple times.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.apply_proj">
<code class="descname">apply_proj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L193-L257"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd><p class="first last">The instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c1"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c1"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.average">
<code class="descname">average</code><span class="sig-paren">(</span><em>picks=None</em>, <em>method='mean'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L834-L877"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute an average over epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">If None only MEG, EEG, SEEG, ECoG, and fNIRS channels are kept
otherwise the channels indices in picks are kept.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | callable</span></dt>
<dd><p class="first last">How to combine the data. If “mean”/”median”, the mean/median
are returned.
Otherwise, must be a callable which, when passed an array of shape
(n_epochs, n_channels, n_time) returns an array of shape
(n_channels, n_time).
Note that due to file type limitations, the kind for all
these will be “average”.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked | dict of Evoked</span></dt>
<dd><p class="first last">The averaged epochs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Computes an average of all epochs in the instance, even if
they correspond to different conditions. To average by condition,
do <code class="docutils literal notranslate"><span class="pre">epochs[condition].average()</span></code> for each condition separately.</p>
<p>When picks is None and epochs contain only ICA channels, no channels
are selected, resulting in an error. This is because ICA channels
are not considered data channels (they are of misc type) and only data
channels are selected when picks is None.</p>
<p>The <cite>method</cite> parameter allows e.g. robust averaging.
For example, one could do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">trim_mean</span>  <span class="c1"># doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trim</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">trim_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epochs</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">trim</span><span class="p">)</span>  <span class="c1"># doctest:+SKIP</span>
</pre></div>
</div>
<p>This would compute the trimmed mean.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.ch_names">
<code class="descname">ch_names</code><a class="headerlink" href="#mne.realtime.RtEpochs.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.compensation_grade">
<code class="descname">compensation_grade</code><a class="headerlink" href="#mne.realtime.RtEpochs.compensation_grade" title="Permalink to this definition">¶</a></dt>
<dd><p>The current gradient compensation grade.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/realtime/epochs.py#L252-L259"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of Epochs instance.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>tmin=None</em>, <em>tmax=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1640-L1683"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop a time interval from the epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Start time of selection in seconds.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">End time of selection in seconds.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The cropped epochs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Unlike Python slices, MNE time intervals include both their end points;
crop(tmin, tmax) returns the interval tmin &lt;= t &lt;= tmax.</p>
<p>Note that the object is modified in place.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.decimate">
<code class="descname">decimate</code><span class="sig-paren">(</span><em>decim</em>, <em>offset=0</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/realtime/epochs.py#L529-L575"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Decimate the epochs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No filtering is performed. To avoid aliasing, ensure
your data are properly lowpassed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>decim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The amount to decimate data.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first">Apply an offset to where the decimation starts relative to the
sample corresponding to t=0. The offset is in samples at the
current sampling rate.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The decimated Epochs object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.Evoked.html#mne.Evoked.decimate" title="mne.Evoked.decimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.Evoked.decimate</span></code></a>, <a class="reference internal" href="mne.Epochs.html#mne.Epochs.resample" title="mne.Epochs.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.Epochs.resample</span></code></a>, <a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.resample" title="mne.io.Raw.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.io.Raw.resample</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Decimation can be done multiple times. For example,
<code class="docutils literal notranslate"><span class="pre">epochs.decimate(2).decimate(2)</span></code> will be the same as
<code class="docutils literal notranslate"><span class="pre">epochs.decimate(4)</span></code>.
If <cite>decim</cite> is 1, this method does not copy the underlying data.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.del_proj">
<code class="descname">del_proj</code><span class="sig-paren">(</span><em>idx='all'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L259-L284"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector.</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | list of int | str</span></dt>
<dd><p class="first last">Index of the projector to remove. Can also be “all” (default)
to remove all projectors.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>indices</em>, <em>reason='USER'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1158-L1207"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop epochs based on indices or boolean mask.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The indices refer to the current set of undropped epochs
rather than the complete set of dropped and undropped epochs.
They are therefore not necessarily consistent with any
external indices (e.g., behavioral logs). To drop epochs
based on external criteria, do not use the <code class="docutils literal notranslate"><span class="pre">preload=True</span></code>
flag when constructing an Epochs object, and call this
method before calling the <a class="reference internal" href="mne.Epochs.html#mne.Epochs.drop_bad" title="mne.Epochs.drop_bad"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.drop_bad()</span></code></a> or
<a class="reference internal" href="mne.Epochs.html#mne.Epochs.load_data" title="mne.Epochs.load_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.load_data()</span></code></a> methods.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of ints or bools</span></dt>
<dd><p class="first last">Set epochs to remove by specifying indices to remove or a boolean
mask to apply (where True values get removed). Events are
correspondingly modified.</p>
</dd>
<dt><strong>reason</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Reason for dropping the epochs (‘ECG’, ‘timeout’, ‘blink’ etc).
Default: ‘USER’.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The epochs with indices dropped. Operates in-place.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.drop_bad">
<code class="descname">drop_bad</code><span class="sig-paren">(</span><em>reject='existing'</em>, <em>flat='existing'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1060-L1111"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.drop_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop bad epochs without retaining the epochs data.</p>
<p>Should be used before slicing operations.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This operation is slow since all epochs have to be read
from disk. To avoid reading epochs from disk multiple
times, use <a class="reference internal" href="mne.Epochs.html#mne.Epochs.load_data" title="mne.Epochs.load_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.Epochs.load_data()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>reject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | str | None</span></dt>
<dd><p class="first last">Rejection parameters based on peak-to-peak amplitude.
Valid keys are ‘grad’ | ‘mag’ | ‘eeg’ | ‘eog’ | ‘ecg’.
If reject is None then no rejection is done. If ‘existing’,
then the rejection parameters set at instantiation are used.</p>
</dd>
<dt><strong>flat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | str | None</span></dt>
<dd><p class="first last">Rejection parameters based on flatness of signal.
Valid keys are ‘grad’ | ‘mag’ | ‘eeg’ | ‘eog’ | ‘ecg’, and values
are floats that set the minimum acceptable peak-to-peak amplitude.
If flat is None then no rejection is done. If ‘existing’,
then the flat parameters set at instantiation are used.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The epochs with bad epochs dropped. Operates in-place.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Dropping bad epochs can be done multiple times with different
<code class="docutils literal notranslate"><span class="pre">reject</span></code> and <code class="docutils literal notranslate"><span class="pre">flat</span></code> parameters. However, once an epoch is
dropped, it is dropped forever, so if more lenient thresholds may
subsequently be applied, <cite>epochs.copy</cite> should be used.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.drop_channels">
<code class="descname">drop_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L757-L798"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of the names of the channels to remove.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.realtime.RtEpochs.reorder_channels" title="mne.realtime.RtEpochs.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a>, <a class="reference internal" href="#mne.realtime.RtEpochs.pick_channels" title="mne.realtime.RtEpochs.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a>, <a class="reference internal" href="#mne.realtime.RtEpochs.pick_types" title="mne.realtime.RtEpochs.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.drop_log_stats">
<code class="descname">drop_log_stats</code><span class="sig-paren">(</span><em>ignore=('IGNORED'</em>, <em>)</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1113-L1130"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.drop_log_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the channel stats based on a drop_log from Epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ignore</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The drop reasons to ignore.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>perc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total percentage of epochs dropped.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.realtime.RtEpochs.plot_drop_log" title="mne.realtime.RtEpochs.plot_drop_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_drop_log</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.equalize_event_counts">
<code class="descname">equalize_event_counts</code><span class="sig-paren">(</span><em>event_ids</em>, <em>method='mintime'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1760-L1867"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.equalize_event_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Equalize the number of trials in each condition.</p>
<p>It tries to make the remaining epochs occurring as close as possible in
time. This method works based on the idea that if there happened to be
some time-varying (like on the scale of minutes) noise characteristics
during a recording, they could be compensated for (to some extent) in
the equalization process. This method thus seeks to reduce any of
those effects by minimizing the differences in the times of the events
in the two sets of epochs. For example, if one had event times
[1, 2, 3, 4, 120, 121] and the other one had [3.5, 4.5, 120.5, 121.5],
it would remove events at times [1, 2] in the first epochs and not
[20, 21].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>event_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The event types to equalize. Each entry in the list can either be
a str (single event) or a list of str. In the case where one of
the entries is a list of str, event_ids in that list will be
grouped together before equalizing trial counts across conditions.
In the case where partial matching is used (using ‘/’ in
<cite>event_ids</cite>), <cite>event_ids</cite> will be matched according to the
provided tags, that is, processing works as if the event_ids
matched by the provided tags had been supplied instead.
The event_ids must identify nonoverlapping subsets of the epochs.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">If ‘truncate’, events will be truncated from the end of each event
list. If ‘mintime’, timing differences between each event list
will be minimized.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The modified Epochs instance.</p>
</dd>
<dt><strong>indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of int</span></dt>
<dd><p class="first last">Indices from the original events list that were dropped.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For example (if epochs.event_id was {‘Left’: 1, ‘Right’: 2,
‘Nonspatial’:3}:</p>
<blockquote>
<div>epochs.equalize_event_counts([[‘Left’, ‘Right’], ‘Nonspatial’])</div></blockquote>
<p>would equalize the number of trials in the ‘Nonspatial’ condition with
the total number of trials in the ‘Left’ and ‘Right’ conditions.</p>
<p>If multiple indices are provided (e.g. ‘Left’ and ‘Right’ in the
example above), it is not guaranteed that after equalization, the
conditions will contribute evenly. E.g., it is possible to end up
with 70 ‘Nonspatial’ trials, 69 ‘Left’ and 1 ‘Right’.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.events">
<code class="descname">events</code><a class="headerlink" href="#mne.realtime.RtEpochs.events" title="Permalink to this definition">¶</a></dt>
<dd><p>The events associated with the epochs currently in the queue.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.filename">
<code class="descname">filename</code><a class="headerlink" href="#mne.realtime.RtEpochs.filename" title="Permalink to this definition">¶</a></dt>
<dd><p>The filename.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>l_freq</em>, <em>h_freq</em>, <em>picks=None</em>, <em>filter_length='auto'</em>, <em>l_trans_bandwidth='auto'</em>, <em>h_trans_bandwidth='auto'</em>, <em>n_jobs=1</em>, <em>method='fir'</em>, <em>iir_params=None</em>, <em>phase='zero'</em>, <em>fir_window='hamming'</em>, <em>fir_design='firwin'</em>, <em>pad='edge'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/filter.py#L1920-L2047"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter a subset of channels.</p>
<p>Applies a zero-phase low-pass, high-pass, band-pass, or band-stop
filter to the channels selected by <code class="docutils literal notranslate"><span class="pre">picks</span></code>.
The data are modified inplace.</p>
<p>The object has to have the data loaded e.g. with <code class="docutils literal notranslate"><span class="pre">preload=True</span></code>
or <code class="docutils literal notranslate"><span class="pre">self.load_data()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">l_freq</span></code> and <code class="docutils literal notranslate"><span class="pre">h_freq</span></code> are the frequencies below which and above
which, respectively, to filter out of the data. Thus the uses are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">&lt;</span> <span class="pre">h_freq</span></code>: band-pass filter</li>
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">&gt;</span> <span class="pre">h_freq</span></code>: band-stop filter</li>
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">None</span></code>: high-pass filter</li>
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>: low-pass filter</li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">self.info['lowpass']</span></code> and <code class="docutils literal notranslate"><span class="pre">self.info['highpass']</span></code> are only
updated with picks=None.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<code class="docutils literal notranslate"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></code> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>l_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Low cut-off frequency in Hz. If None the data are only low-passed.</p>
</dd>
<dt><strong>h_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">High cut-off frequency in Hz. If None the data are only
high-passed.</p>
</dd>
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</dd>
<dt><strong>filter_length</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | int</span></dt>
<dd><p class="first">Length of the FIR filter to use (if applicable):</p>
<ul class="last simple">
<li>‘auto’ (default): the filter length is chosen based
on the size of the transition regions (6.6 times the reciprocal
of the shortest transition band for fir_window=’hamming’
and fir_design=”firwin2”, and half that for “firwin”).</li>
<li>str: a human-readable time in
units of “s” or “ms” (e.g., “10s” or “5500ms”) will be
converted to that number of samples if <code class="docutils literal notranslate"><span class="pre">phase=&quot;zero&quot;</span></code>, or
the shortest power-of-two length at least that duration for
<code class="docutils literal notranslate"><span class="pre">phase=&quot;zero-double&quot;</span></code>.</li>
<li>int: specified length in samples. For fir_design=”firwin”,
this should not be used.</li>
</ul>
</dd>
<dt><strong>l_trans_bandwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | str</span></dt>
<dd><p class="first">Width of the transition band at the low cut-off frequency in Hz
(high pass or cutoff 1 in bandpass). Can be “auto”
(default) to use a multiple of <code class="docutils literal notranslate"><span class="pre">l_freq</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">l_freq</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">l_freq</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Only used for <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.</p>
</dd>
<dt><strong>h_trans_bandwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | str</span></dt>
<dd><p class="first">Width of the transition band at the high cut-off frequency in Hz
(low pass or cutoff 2 in bandpass). Can be “auto”
(default) to use a multiple of <code class="docutils literal notranslate"><span class="pre">h_freq</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">h_freq</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">h_freq</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Only used for <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number of jobs to run in parallel. Can be ‘cuda’ if <code class="docutils literal notranslate"><span class="pre">cupy</span></code>
is installed properly and method=’fir’.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">‘fir’ will use overlap-add FIR filtering, ‘iir’ will use IIR
forward-backward filtering (via filtfilt).</p>
</dd>
<dt><strong>iir_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=”iir”, 4th order Butterworth will be used.</p>
</dd>
<dt><strong>phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Phase of the filter, only used if <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.
By default, a symmetric linear-phase FIR filter is constructed.
If <code class="docutils literal notranslate"><span class="pre">phase='zero'</span></code> (default), the delay of this filter
is compensated for. If <code class="docutils literal notranslate"><span class="pre">phase=='zero-double'</span></code>, then this filter
is applied twice, once forward, and once backward. If ‘minimum’,
then a minimum-phase, causal filter will be used.</p>
</dd>
<dt><strong>fir_window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The window to use in FIR design, can be “hamming” (default),
“hann” (default in 0.13), or “blackman”.</p>
</dd>
<dt><strong>fir_design</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Can be “firwin” (default) to use <a class="reference external" href="https://scipy.github.io/devdocs/generated/scipy.signal.firwin.html#scipy.signal.firwin" title="(in SciPy v1.3.0.dev0+446cf44)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.firwin()</span></code></a>,
or “firwin2” to use <a class="reference external" href="https://scipy.github.io/devdocs/generated/scipy.signal.firwin2.html#scipy.signal.firwin2" title="(in SciPy v1.3.0.dev0+446cf44)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.firwin2()</span></code></a>. “firwin” uses
a time-domain design technique that generally gives improved
attenuation using fewer samples than “firwin2”.</p>
</dd>
<dt><strong>pad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The type of padding to use. Supports all <a class="reference external" href="https://www.numpy.org/devdocs/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.17.dev0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.pad()</span></code></a> <code class="docutils literal notranslate"><span class="pre">mode</span></code>
options. Can also be “reflect_limited”, which pads with a
reflected version of each vector mirrored on the first and last
values of the vector, followed by zeros. The default is “edge”,
which pads with the edge values of each vector.
Only used for <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs or Evoked</span></dt>
<dd><p class="first last">The filtered data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.15.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1321-L1329"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all epochs as a 3D array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape (n_epochs, n_channels, n_times)</span></dt>
<dd><p class="first last">A view on epochs data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.interpolate_bads">
<code class="descname">interpolate_bads</code><span class="sig-paren">(</span><em>reset_bads=True</em>, <em>mode='accurate'</em>, <em>origin=(0.0</em>, <em>0.0</em>, <em>0.04)</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L916-L965"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>reset_bads</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, remove the bads from info.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Either <code class="docutils literal notranslate"><span class="pre">'accurate'</span></code> or <code class="docutils literal notranslate"><span class="pre">'fast'</span></code>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</dd>
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape (3,) | str</span></dt>
<dd><p class="first">Origin of the sphere in the head coordinate frame and in meters.
Can be <code class="docutils literal notranslate"><span class="pre">'auto'</span></code>, which means a head-digitization-based origin
fit. Default is <code class="docutils literal notranslate"><span class="pre">(0.,</span> <span class="pre">0.,</span> <span class="pre">0.04)</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.iter_evoked">
<code class="descname">iter_evoked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L738-L756"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.iter_evoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over epochs as a sequence of Evoked objects.</p>
<p>The Evoked objects yielded will each contain a single epoch (i.e., no
averaging is performed).</p>
<p>This method resets the object iteration state to the first epoch.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.load_data">
<code class="descname">load_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L484-L507"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the data if not already preloaded.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The epochs object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function operates in-place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.metadata">
<code class="descname">metadata</code><a class="headerlink" href="#mne.realtime.RtEpochs.metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the metadata.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.next">
<code class="descname">next</code><span class="sig-paren">(</span><em>return_event_id=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/realtime/epochs.py#L314-L353"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Make iteration over epochs easy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>return_event_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, return both an epoch and and event_id.</p>
</dd>
<dt><strong>verbose: bool, str, int, or None</strong></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epoch</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The epoch.</p>
</dd>
<dt><strong>event_id</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The event id. Only returned if <code class="docutils literal notranslate"><span class="pre">return_event_id</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.pick_channels">
<code class="descname">pick_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L692-L720"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The list of channels to select.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.realtime.RtEpochs.drop_channels" title="mne.realtime.RtEpochs.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>, <a class="reference internal" href="#mne.realtime.RtEpochs.pick_types" title="mne.realtime.RtEpochs.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>, <a class="reference internal" href="#mne.realtime.RtEpochs.reorder_channels" title="mne.realtime.RtEpochs.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The channel names given are assumed to be a set, i.e. the order
does not matter. The original order of the channels is preserved.
You can use <code class="docutils literal notranslate"><span class="pre">reorder_channels</span></code> to set channel order if necessary.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.pick_types">
<code class="descname">pick_types</code><span class="sig-paren">(</span><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>dipole=False</em>, <em>gof=False</em>, <em>bio=False</em>, <em>ecog=False</em>, <em>fnirs=False</em>, <em>include=()</em>, <em>exclude='bads'</em>, <em>selection=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L601-L690"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>meg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">If True include all MEG channels. If False include None
If string it can be ‘mag’, ‘grad’, ‘planar1’ or ‘planar2’ to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</dd>
<dt><strong>eeg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EEG channels.</p>
</dd>
<dt><strong>stim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include stimulus channels.</p>
</dd>
<dt><strong>eog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EOG channels.</p>
</dd>
<dt><strong>ecg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include ECG channels.</p>
</dd>
<dt><strong>emg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EMG channels.</p>
</dd>
<dt><strong>ref_meg: bool | str</strong></dt>
<dd><p class="first last">If True include CTF / 4D reference channels. If ‘auto’, the
reference channels are only included if compensations are present.</p>
</dd>
<dt><strong>misc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include miscellaneous analog channels.</p>
</dd>
<dt><strong>resp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</dd>
<dt><strong>chpi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include continuous HPI coil channels.</p>
</dd>
<dt><strong>exci</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Flux excitation channel used to be a stimulus channel.</p>
</dd>
<dt><strong>ias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Internal Active Shielding data (maybe on Triux only).</p>
</dd>
<dt><strong>syst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">System status channel information (on Triux systems only).</p>
</dd>
<dt><strong>seeg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Stereotactic EEG channels.</p>
</dd>
<dt><strong>dipole</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Dipole time course channels.</p>
</dd>
<dt><strong>gof</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Dipole goodness of fit channels.</p>
</dd>
<dt><strong>bio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Bio channels.</p>
</dd>
<dt><strong>ecog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Electrocorticography channels.</p>
</dd>
<dt><strong>fnirs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Functional near-infrared spectroscopy channels. If True include all
fNIRS channels. If False (default) include none. If string it can
be ‘hbo’ (to include channels measuring oxyhemoglobin) or ‘hbr’ (to
include channels measuring deoxyhemoglobin).</p>
</dd>
<dt><strong>include</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">List of additional channels to include. If empty do not include
any.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string | str</span></dt>
<dd><p class="first last">List of channels to exclude. If ‘bads’ (default), exclude channels
in <code class="docutils literal notranslate"><span class="pre">info['bads']</span></code>.</p>
</dd>
<dt><strong>selection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.realtime.RtEpochs.pick_channels" title="mne.realtime.RtEpochs.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>picks=None</em>, <em>scalings=None</em>, <em>n_epochs=20</em>, <em>n_channels=20</em>, <em>title=None</em>, <em>events=None</em>, <em>event_colors=None</em>, <em>show=True</em>, <em>block=False</em>, <em>decim='auto'</em>, <em>noise_cov=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1008-L1016"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize epochs.</p>
<p>Bad epochs can be marked with a left click on top of the epoch. Bad
channels can be selected by clicking the channel name on the left side of
the main axes. Calling this function drops all the selected bad epochs as
well as bad epochs marked beforehand with rejection parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">Channels to be included. If None only good data channels are used.
Defaults to None</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | ‘auto’ | None</span></dt>
<dd><p class="first">Scaling factors for the traces. If any fields in scalings are ‘auto’,
the scaling factor is set to match the 99.5th percentile of a subset of
the corresponding data. If scalings == ‘auto’, all scalings fields are
set to ‘auto’. If any fields are ‘auto’ and data is not preloaded,
a subset of epochs up to 100mb will be loaded. If None, defaults to:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="mf">4e-11</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="mf">20e-6</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="mf">150e-6</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">resp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
     <span class="n">whitened</span><span class="o">=</span><span class="mf">10.</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt><strong>n_epochs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of epochs per view. Defaults to 20.</p>
</dd>
<dt><strong>n_channels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of channels per view. Defaults to 20.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">The title of the window. If None, epochs name will be displayed.
Defaults to None.</p>
</dd>
<dt><strong>events</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None, array, shape (n_events, 3)</span></dt>
<dd><p class="first">Events to show with vertical bars. If events are provided, the epoch
numbers are not shown to prevent overlap. You can toggle epoch
numbering through options (press ‘o’ key). You can use
<a class="reference internal" href="mne.viz.plot_events.html#mne.viz.plot_events" title="mne.viz.plot_events"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_events()</span></code></a> as a legend for the colors. By default, the
coloring scheme is the same.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the epochs have been resampled, the events no longer
align with the data.</p>
</div>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.14.0.</span></p>
</div>
</dd>
<dt><strong>event_colors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None, dict</span></dt>
<dd><p class="first">Dictionary of event_id value and its associated color. If None,
colors are automatically drawn from a default list (cycled through if
number of events longer than list of default colors). Uses the same
coloring scheme as <a class="reference internal" href="mne.viz.plot_events.html#mne.viz.plot_events" title="mne.viz.plot_events"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_events()</span></code></a>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.14.0.</span></p>
</div>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True. Defaults to True</p>
</dd>
<dt><strong>block</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to halt program execution until the figure is closed.
Useful for rejecting bad trials on the fly by clicking on an epoch.
Defaults to False.</p>
</dd>
<dt><strong>decim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | ‘auto’</span></dt>
<dd><p class="first">Amount to decimate the data during display for speed purposes.
You should only decimate if the data are sufficiently low-passed,
otherwise aliasing can occur. The ‘auto’ mode (default) uses
the decimation that results in a sampling rate at least three times
larger than <code class="docutils literal notranslate"><span class="pre">info['lowpass']</span></code> (e.g., a 40 Hz lowpass will result in
at least a 120 Hz displayed sample rate).</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.15.0.</span></p>
</div>
</dd>
<dt><strong>noise_cov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Covariance | str | None</span></dt>
<dd><p class="first">Noise covariance used to whiten the data while plotting.
Whitened data channels are scaled by <code class="docutils literal notranslate"><span class="pre">scalings['whitened']</span></code>,
and their channel names are shown in italic.
Can be a string to load a covariance from disk.
See also <a class="reference internal" href="mne.Evoked.html#mne.Evoked.plot_white" title="mne.Evoked.plot_white"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Evoked.plot_white()</span></code></a> for additional inspection
of noise covariance properties when whitening evoked data.
For data processed with SSS, the effective dependence between
magnetometers and gradiometers may introduce differences in scaling,
consider using <a class="reference internal" href="mne.Evoked.html#mne.Evoked.plot_white" title="mne.Evoked.plot_white"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Evoked.plot_white()</span></code></a>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Instance of matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The arrow keys (up/down/left/right) can be used to navigate between
channels and epochs and the scaling can be adjusted with - and + (or =)
keys, but this depends on the backend matplotlib is configured to use
(e.g., mpl.use(<code class="docutils literal notranslate"><span class="pre">TkAgg</span></code>) should work). Full screen mode can be toggled
with f11 key. The amount of epochs and channels per view can be adjusted
with home/end and page down/page up keys. These can also be set through
options dialog by pressing <code class="docutils literal notranslate"><span class="pre">o</span></code> key. <code class="docutils literal notranslate"><span class="pre">h</span></code> key plots a histogram of
peak-to-peak values along with the used rejection thresholds. Butterfly
plot can be toggled with <code class="docutils literal notranslate"><span class="pre">b</span></code> key. Right mouse click adds a vertical line
to the plot. Click ‘help’ button at bottom left corner of the plotter to
view all the options.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot_drop_log">
<code class="descname">plot_drop_log</code><span class="sig-paren">(</span><em>threshold=0</em>, <em>n_max_plot=20</em>, <em>subject='Unknown'</em>, <em>color=(0.9</em>, <em>0.9</em>, <em>0.9)</em>, <em>width=0.8</em>, <em>ignore=('IGNORED'</em>, <em>)</em>, <em>show=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1132-L1142"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot_drop_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the channel stats based on a drop_log from Epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>threshold</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The percentage threshold to use to decide whether or not to
plot. Default is zero (always plot).</p>
</dd>
<dt><strong>n_max_plot</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of channels to show stats for.</p>
</dd>
<dt><strong>subject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The subject name to use in the title of the plot.</p>
</dd>
<dt><strong>color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple | str</span></dt>
<dd><p class="first last">Color to use for the bars.</p>
</dd>
<dt><strong>width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Width of the bars.</p>
</dd>
<dt><strong>ignore</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The drop reasons to ignore.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Instance of matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot_image">
<code class="descname">plot_image</code><span class="sig-paren">(</span><em>picks=None</em>, <em>sigma=0.0</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>colorbar=True</em>, <em>order=None</em>, <em>show=True</em>, <em>units=None</em>, <em>scalings=None</em>, <em>cmap=None</em>, <em>fig=None</em>, <em>axes=None</em>, <em>overlay_times=None</em>, <em>combine=None</em>, <em>group_by=None</em>, <em>evoked=True</em>, <em>ts_args={'show_sensors': False}</em>, <em>title=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1144-L1156"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Event Related Potential / Fields image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | array-like of int | None</span></dt>
<dd><p class="first last">The indices of the channels to consider. If None and <code class="docutils literal notranslate"><span class="pre">combine</span></code> is
also None, the first five good channels are plotted.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The standard deviation of the Gaussian smoothing to apply along
the epoch axis to apply in the image. If 0., no smoothing is applied.
Defaults to 0.</p>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float | callable</span></dt>
<dd><p class="first last">The min value in the image (and the ER[P/F]). The unit is uV for
EEG channels, fT for magnetometers and fT/cm for gradiometers.
If vmin is None and multiple plots are returned, the limit is
equalized within channel types.
Hint: to specify the lower limit of the data, use
<code class="docutils literal notranslate"><span class="pre">vmin=lambda</span> <span class="pre">data:</span> <span class="pre">data.min()</span></code>.</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | float | callable</span></dt>
<dd><p class="first last">The max value in the image (and the ER[P/F]). The unit is uV for
EEG channels, fT for magnetometers and fT/cm for gradiometers.
If vmin is None and multiple plots are returned, the limit is
equalized within channel types.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Display or not a colorbar.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | array of int | callable</span></dt>
<dd><p class="first last">If not None, order is used to reorder the epochs on the y-axis
of the image. If it’s an array of int it should be of length
the number of good epochs. If it’s a callable the arguments
passed are the times vector and the data as 2d array
(data.shape[1] == len(times).</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt><strong>units</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The units of the channel types used for axes labels. If None,
defaults to <cite>units=dict(eeg=’uV’, grad=’fT/cm’, mag=’fT’)</cite>.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The scalings of the channel types to be applied for plotting.
If None, defaults to <cite>scalings=dict(eeg=1e6, grad=1e13, mag=1e15,
eog=1e6)</cite>.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | matplotlib colormap | (colormap, bool) | ‘interactive’</span></dt>
<dd><p class="first last">Colormap. If tuple, the first value indicates the colormap to use and
the second value is a boolean defining interactivity. In interactive
mode the colors are adjustable by clicking and dragging the colorbar
with left and right mouse button. Left mouse button moves the scale up
and down and right mouse button adjusts the range. Hitting space bar
resets the scale. Up and down arrows can be used to change the
colormap. If ‘interactive’, translates to (‘RdBu_r’, True).
If None, “RdBu_r” is used, unless the data is all positive, in which
case “Reds” is used.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib figure | None</span></dt>
<dd><p class="first last">Figure instance to draw the image to. Figure must contain two axes for
drawing the single trials and evoked responses. If None a new figure is
created. Defaults to None.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of matplotlib axes | dict of lists of matplotlib Axes | None</span></dt>
<dd><p class="first last">List of axes instances to draw the image, erp and colorbar to.
Must be of length three if colorbar is True (with the last list element
being the colorbar axes) or two if colorbar is False. If both fig and
axes are passed, an error is raised.
If <code class="docutils literal notranslate"><span class="pre">group_by</span></code> is a dict, this cannot be a list, but it can be a dict
of lists of axes, with the keys matching those of <code class="docutils literal notranslate"><span class="pre">group_by</span></code>. In that
case, the provided axes will be used for the corresponding groups.
Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>overlay_times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape (n_epochs,) | None</span></dt>
<dd><p class="first last">If not None the parameter is interpreted as time instants in seconds
and is added to the image. It is typically useful to display reaction
times. Note that it is defined with respect to the order
of epochs such that overlay_times[0] corresponds to epochs[0].</p>
</dd>
<dt><strong>combine</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str | callable</span></dt>
<dd><p class="first">If None, return one figure per pick. If not None, aggregate over
channels via the indicated method. If str, must be one of “mean”,
“median”, “std” or “gfp”, in which case the mean, the median, the
standard deviation or the GFP over channels are plotted.
array (n_epochs, n_times).
If callable, it must accept one positional input, the data
in the format <cite>(n_epochs, n_channels, n_times)</cite>. It must return an
array <cite>(n_epochs, n_times)</cite>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">combine</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Defaults to <cite>None</cite> if picks are provided, otherwise ‘gfp’.</p>
</dd>
<dt><strong>group_by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str | dict</span></dt>
<dd><p class="first">If not None, combining happens over channel groups defined by this
parameter.
If str, must be “type”, in which case one figure per channel type is
returned (combining within channel types).
If a dict, the values must be picks and one figure will be returned
for each entry, aggregating over the corresponding pick groups; keys
will become plot titles. This is useful for e.g. ROIs. Each entry must
contain only one channel type. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">group_by</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">Left_ROI</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">Right_ROI</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
</pre></div>
</div>
<p class="last">If not None, combine must not be None. Defaults to <cite>None</cite> if picks are
provided, otherwise ‘type’.</p>
</dd>
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Bool</span></dt>
<dd><p class="first last">Draw the ER[P/F] below the image or not.</p>
</dd>
<dt><strong>ts_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Arguments passed to a call to <cite>mne.viz.plot_compare_evoked</cite> to style
the evoked plot below the image. Defaults to an empty dictionary,
meaning <cite>plot_compare_evokeds</cite> will be called with default parameters
(yaxis truncation will be turned off, and inversion of the y axis
via <cite>invert_y=True</cite> will raise an error).</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str</span></dt>
<dd><p class="first last">If str, will be plotted as figure title. Else, the channels will be
indicated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>figs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">lists of matplotlib figures</span></dt>
<dd><p class="first last">One figure per channel displayed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot_projs_topomap">
<code class="descname">plot_projs_topomap</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>layout=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L286-L331"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None | List</span></dt>
<dd><p class="first last">The channel type to plot. For ‘grad’, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | Layout | List of Layouts</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axes | list | None</span></dt>
<dd><p class="first last">The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of projectors. If instance of Axes,
there must be only one projector. Defaults to None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">Figure distributing one image per channel across sensor topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot_psd">
<code class="descname">plot_psd</code><span class="sig-paren">(</span><em>fmin=0</em>, <em>fmax=inf</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>proj=False</em>, <em>bandwidth=None</em>, <em>adaptive=False</em>, <em>low_bias=True</em>, <em>normalization='length'</em>, <em>picks=None</em>, <em>ax=None</em>, <em>color='black'</em>, <em>area_mode='std'</em>, <em>area_alpha=0.33</em>, <em>dB=True</em>, <em>n_jobs=1</em>, <em>show=True</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1018-L1030"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the power spectral density across epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Start frequency to consider.</p>
</dd>
<dt><strong>fmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">End frequency to consider.</p>
</dd>
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Start time to consider.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">End time to consider.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Apply projection.</p>
</dd>
<dt><strong>bandwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The bandwidth of the multi taper windowing function in Hz. The default
value is a window half-bandwidth of 4.</p>
</dd>
<dt><strong>adaptive</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use adaptive weights to combine the tapered spectra into PSD
(slow, use n_jobs &gt;&gt; 1 to speed up computation).</p>
</dd>
<dt><strong>low_bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Only use tapers with more than 90% spectral concentration within
bandwidth.</p>
</dd>
<dt><strong>normalization</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Either “full” or “length” (default). If “full”, the PSD will
be normalized by the sampling rate as well as the length of
the signal (as in nitime).</p>
</dd>
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">List of channels to use.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib Axes | None</span></dt>
<dd><p class="first last">Axes to plot into. If None, axes will be created.</p>
</dd>
<dt><strong>color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | tuple</span></dt>
<dd><p class="first last">A matplotlib-compatible color to use.</p>
</dd>
<dt><strong>area_mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Mode for plotting area. If ‘std’, the mean +/- 1 STD (across channels)
will be plotted. If ‘range’, the min and max (across channels) will be
plotted. Bad channels will be excluded from these calculations.
If None, no area will be plotted.</p>
</dd>
<dt><strong>area_alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Alpha for the area.</p>
</dd>
<dt><strong>dB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, transform data to decibels.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of jobs to run in parallel.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">Figure distributing one image per channel across sensor topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot_psd_topomap">
<code class="descname">plot_psd_topomap</code><span class="sig-paren">(</span><em>bands=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>proj=False</em>, <em>bandwidth=None</em>, <em>adaptive=False</em>, <em>low_bias=True</em>, <em>normalization='length'</em>, <em>ch_type=None</em>, <em>layout=None</em>, <em>cmap='RdBu_r'</em>, <em>agg_fun=None</em>, <em>dB=True</em>, <em>n_jobs=1</em>, <em>normalize=False</em>, <em>cbar_fmt='%0.3f'</em>, <em>outlines='head'</em>, <em>axes=None</em>, <em>show=True</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1032-L1045"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot_psd_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the topomap of the power spectral density across epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bands</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of tuple | None</span></dt>
<dd><p class="first">The lower and upper frequency and the name for that band. If None,
(default) expands to:</p>
<dl class="last docutils">
<dt>bands = [(0, 4, ‘Delta’), (4, 8, ‘Theta’), (8, 12, ‘Alpha’),</dt>
<dd><p class="first last">(12, 30, ‘Beta’), (30, 45, ‘Gamma’)]</p>
</dd>
</dl>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | callable | None</span></dt>
<dd><p class="first last">The value specifying the lower bound of the color range.
If None np.min(data) is used. If callable, the output equals
vmin(data).</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | callable | None</span></dt>
<dd><p class="first last">The value specifying the upper bound of the color range.
If None, the maximum absolute value is used. If callable, the output
equals vmax(data). Defaults to None.</p>
</dd>
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Start time to consider.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">End time to consider.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Apply projection.</p>
</dd>
<dt><strong>bandwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The bandwidth of the multi taper windowing function in Hz. The default
value is a window half-bandwidth of 4 Hz.</p>
</dd>
<dt><strong>adaptive</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use adaptive weights to combine the tapered spectra into PSD
(slow, use n_jobs &gt;&gt; 1 to speed up computation).</p>
</dd>
<dt><strong>low_bias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Only use tapers with more than 90% spectral concentration within
bandwidth.</p>
</dd>
<dt><strong>normalization</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Either “full” or “length” (default). If “full”, the PSD will
be normalized by the sampling rate as well as the length of
the signal (as in nitime).</p>
</dd>
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None</span></dt>
<dd><p class="first last">The channel type to plot. For ‘grad’, the gradiometers are collected in
pairs and the RMS for each pair is plotted. If None, then first
available channel type from order given above is used. Defaults to
None.</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | Layout</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout
file is inferred from the data; if no appropriate layout file was
found, the layout is automatically generated from the sensor
locations.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’ | None</span></dt>
<dd><p class="first last">Colormap to use. If tuple, the first value indicates the colormap to
use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging the
colorbar with left and right mouse button. Left mouse button moves the
scale up and down and right mouse button adjusts the range. Hitting
space bar resets the range. Up and down arrows can be used to change
the colormap. If None (default), ‘Reds’ is used for all positive data,
otherwise defaults to ‘RdBu_r’. If ‘interactive’, translates to
(None, True).</p>
</dd>
<dt><strong>agg_fun</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable</span></dt>
<dd><p class="first last">The function used to aggregate over frequencies.
Defaults to np.sum. if normalize is True, else np.mean.</p>
</dd>
<dt><strong>dB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, transform data to decibels (with <code class="docutils literal notranslate"><span class="pre">10</span> <span class="pre">*</span> <span class="pre">np.log10(data)</span></code>)
following the application of <cite>agg_fun</cite>. Only valid if normalize is
False.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of jobs to run in parallel.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, each band will be divided by the total power. Defaults to
False.</p>
</dd>
<dt><strong>cbar_fmt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The colorbar format. Defaults to ‘%0.3f’.</p>
</dd>
<dt><strong>outlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘head’ | ‘skirt’ | dict | None</span></dt>
<dd><p class="first last">The outlines to be drawn. If ‘head’, the default head scheme will be
drawn. If ‘skirt’ the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in ‘mask_pos’ will
serve as image mask, and the ‘autoshrink’ (bool) field will trigger
automated shrinking of the positions due to points outside the outline.
Alternatively, a matplotlib patch object can be passed for advanced
masking options, either directly or as a function that returns patches
(required for multi-axis plots). If None, nothing will be drawn.
Defaults to ‘head’.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of axes | None</span></dt>
<dd><p class="first last">List of axes to plot consecutive topographies to. If None the axes
will be created automatically. Defaults to None.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">Figure distributing one image per channel across sensor topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot_sensors">
<code class="descname">plot_sensors</code><span class="sig-paren">(</span><em>kind='topomap'</em>, <em>ch_type=None</em>, <em>title=None</em>, <em>show_names=False</em>, <em>ch_groups=None</em>, <em>to_sphere=True</em>, <em>axes=None</em>, <em>block=False</em>, <em>show=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L503-L581"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot_sensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sensor positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Whether to plot the sensors as 3d, topomap or as an interactive
sensor selection dialog. Available options ‘topomap’, ‘3d’,
‘select’. If ‘select’, a set of channels can be selected
interactively by using lasso selector or clicking while holding
control key. The selected channels are returned along with the
figure instance. Defaults to ‘topomap’.</p>
</dd>
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str</span></dt>
<dd><p class="first last">The channel type to plot. Available options ‘mag’, ‘grad’, ‘eeg’,
‘seeg’, ‘ecog’, ‘all’. If <code class="docutils literal notranslate"><span class="pre">'all'</span></code>, all the available mag, grad,
eeg, seeg and ecog channels are plotted. If None (default), then
channels are chosen in the order given above.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Title for the figure. If None (default), equals to <code class="docutils literal notranslate"><span class="pre">'Sensor</span>
<span class="pre">positions</span> <span class="pre">(%s)'</span> <span class="pre">%</span> <span class="pre">ch_type</span></code>.</p>
</dd>
<dt><strong>show_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | array of str</span></dt>
<dd><p class="first last">Whether to display all channel names. If an array, only the channel
names in the array are shown. Defaults to False.</p>
</dd>
<dt><strong>ch_groups</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘position’ | array of shape (ch_groups, picks) | None</span></dt>
<dd><p class="first">Channel groups for coloring the sensors. If None (default), default
coloring scheme is used. If ‘position’, the sensors are divided
into 8 regions. See <code class="docutils literal notranslate"><span class="pre">order</span></code> kwarg of <a class="reference internal" href="mne.viz.plot_raw.html#mne.viz.plot_raw" title="mne.viz.plot_raw"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_raw()</span></code></a>. If
array, the channels are divided by picks given in the array.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>to_sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Whether to project the 3d locations to a sphere. When False, the
sensor array appears similar as to looking downwards straight above
the subject’s head. Has no effect when kind=‘3d’. Defaults to True.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.14.0.</span></p>
</div>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axes | instance of Axes3D | None</span></dt>
<dd><p class="first">Axes to draw the sensors to. If <code class="docutils literal notranslate"><span class="pre">kind='3d'</span></code>, axes must be an
instance of Axes3D. If None (default), a new axes will be created.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>block</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Whether to halt program execution until the figure is closed.
Defaults to False.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True. Defaults to True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">Figure containing the sensor topography.</p>
</dd>
<dt><strong>selection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of selected channels. Only returned if <code class="docutils literal notranslate"><span class="pre">kind=='select'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.viz.plot_layout.html#mne.viz.plot_layout" title="mne.viz.plot_layout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.viz.plot_layout</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function plots the sensor locations from the info structure using
matplotlib. For drawing the sensors using mayavi see
<a class="reference internal" href="mne.viz.plot_alignment.html#mne.viz.plot_alignment" title="mne.viz.plot_alignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_alignment()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.plot_topo_image">
<code class="descname">plot_topo_image</code><span class="sig-paren">(</span><em>layout=None</em>, <em>sigma=0.0</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>colorbar=True</em>, <em>order=None</em>, <em>cmap='RdBu_r'</em>, <em>layout_scale=0.95</em>, <em>title=None</em>, <em>scalings=None</em>, <em>border='none'</em>, <em>fig_facecolor='k'</em>, <em>fig_background=None</em>, <em>font_color='w'</em>, <em>show=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1047-L1058"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.plot_topo_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Event Related Potential / Fields image on topographies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>layout: instance of Layout</strong></dt>
<dd><p class="first last">System specific sensor positions.</p>
</dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The standard deviation of the Gaussian smoothing to apply along
the epoch axis to apply in the image. If 0., no smoothing is applied.</p>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The min value in the image. The unit is uV for EEG channels,
fT for magnetometers and fT/cm for gradiometers.</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The max value in the image. The unit is uV for EEG channels,
fT for magnetometers and fT/cm for gradiometers.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Display or not a colorbar.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | array of int | callable</span></dt>
<dd><p class="first last">If not None, order is used to reorder the epochs on the y-axis
of the image. If it’s an array of int it should be of length
the number of good epochs. If it’s a callable the arguments
passed are the times vector and the data as 2d array
(data.shape[1] == len(times)).</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib.pyplot.colormap</span></dt>
<dd><p class="first last">Colors to be mapped to the values.</p>
</dd>
<dt><strong>layout_scale: float</strong></dt>
<dd><p class="first last">scaling factor for adjusting the relative size of the layout
on the canvas.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Title of the figure.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The scalings of the channel types to be applied for plotting. If
None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</dd>
<dt><strong>border</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">matplotlib borders style to be used for each sensor plot.</p>
</dd>
<dt><strong>fig_facecolor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | obj</span></dt>
<dd><p class="first last">The figure face color. Defaults to black.</p>
</dd>
<dt><strong>fig_background</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | array</span></dt>
<dd><p class="first last">A background image for the figure. This must be a valid input to
<cite>matplotlib.pyplot.imshow</cite>. Defaults to None.</p>
</dd>
<dt><strong>font_color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | obj</span></dt>
<dd><p class="first last">The color of tick labels in the colorbar. Defaults to white.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">Figure distributing one image per channel across sensor topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.proj">
<code class="descname">proj</code><a class="headerlink" href="#mne.realtime.RtEpochs.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not projections are active.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.rename_channels">
<code class="descname">rename_channels</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L459-L473"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | callable</span></dt>
<dd><p class="first last">a dictionary mapping the old channel to a new channel name
e.g. {‘EEG061’ : ‘EEG161’}. Can also be a callable function
that takes and returns a string (new in version 0.10.0).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.reorder_channels">
<code class="descname">reorder_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L722-L755"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.reorder_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The desired channel order.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.realtime.RtEpochs.drop_channels" title="mne.realtime.RtEpochs.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>, <a class="reference internal" href="#mne.realtime.RtEpochs.pick_types" title="mne.realtime.RtEpochs.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>, <a class="reference internal" href="#mne.realtime.RtEpochs.pick_channels" title="mne.realtime.RtEpochs.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Channel names must be unique. Channels that are not in <code class="docutils literal notranslate"><span class="pre">ch_names</span></code>
are dropped.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>sfreq</em>, <em>npad='auto'</em>, <em>window='boxcar'</em>, <em>n_jobs=1</em>, <em>pad='edge'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/filter.py#L2049-L2112"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Data must be loaded.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sfreq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">New sample rate to use</p>
</dd>
<dt><strong>npad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Amount to pad the start and end of the data.
Can also be “auto” to use a padding that will result in
a power-of-two size (can be much faster).</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or tuple</span></dt>
<dd><p class="first last">Window to use in resampling. See <a class="reference external" href="https://scipy.github.io/devdocs/generated/scipy.signal.resample.html#scipy.signal.resample" title="(in SciPy v1.3.0.dev0+446cf44)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.resample()</span></code></a>.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of jobs to run in parallel.</p>
</dd>
<dt><strong>pad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The type of padding to use. Supports all <a class="reference external" href="https://www.numpy.org/devdocs/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.17.dev0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.pad()</span></code></a> <code class="docutils literal notranslate"><span class="pre">mode</span></code>
options. Can also be “reflect_limited”, which pads with a
reflected version of each vector mirrored on the first and last
values of the vector, followed by zeros. The default is “edge”,
which pads with the edge values of each vector.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.15.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for
more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs | instance of Evoked</span></dt>
<dd><p class="first last">The resampled epochs object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.resample" title="mne.io.Raw.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.io.Raw.resample</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use npad=0 to reduce
artifacts. This is dataset dependent – check your data!</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em>, <em>split_size='2GB'</em>, <em>fmt='single'</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1695-L1758"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save epochs in a fif file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The name of the file, which should end with -epo.fif or
-epo.fif.gz.</p>
</dd>
<dt><strong>split_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string | int</span></dt>
<dd><p class="first">Large raw files are automatically split into multiple pieces. This
parameter specifies the maximum size of each piece. If the
parameter is an integer, it specifies the size in Bytes. It is
also possible to pass a human-readable string, e.g., 100MB.
Note: Due to FIFF file limitations, the maximum split size is 2GB.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd>
<dt><strong>fmt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">Format to save data. Valid options are ‘double’ or
‘single’ for 64- or 32-bit float, or for 128- or
64-bit complex numbers respectively. Note: Data are processed with
double precision. Choosing single-precision, the saved data
will slightly differ due to the reduction in precision.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Bad epochs will be dropped before saving the epochs to disk.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.savgol_filter">
<code class="descname">savgol_filter</code><span class="sig-paren">(</span><em>h_freq</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/filter.py#L1854-L1918"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.savgol_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the data using Savitzky-Golay polynomial method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>h_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Approximate high cut-off frequency in Hz. Note that this
is not an exact cutoff, since Savitzky-Golay filtering <a class="reference internal" href="#r3f66533b90a1-1" id="id1">[1]</a> is
done using polynomial fits instead of FIR/IIR filtering.
This parameter is thus used to determine the length of the
window over which a 5th-order polynomial smoothing is used.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs or Evoked</span></dt>
<dd><p class="first last">The object with the filtering applied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.io.Raw.filter</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For Savitzky-Golay low-pass approximation, see:</p>
<blockquote>
<div><a class="reference external" href="https://gist.github.com/Eric89GXL/bbac101d50176611136b">https://gist.github.com/Eric89GXL/bbac101d50176611136b</a></div></blockquote>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3f66533b90a1-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Savitzky, A., Golay, M.J.E. (1964). “Smoothing and
Differentiation of Data by Simplified Least Squares
Procedures”. Analytical Chemistry 36 (8): 1627-39.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mne</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">path</span> <span class="k">as</span> <span class="n">op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked_fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mne</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">data_path</span><span class="p">(),</span> <span class="s1">&#39;MEG&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;sample_audvis-ave.fif&#39;</span><span class="p">)</span>  <span class="c1"># doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_evokeds</span><span class="p">(</span><span class="n">evoked_fname</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>  <span class="c1"># low-pass at around 10 Hz # doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>  <span class="c1"># doctest:+SKIP</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.selection">
<code class="descname">selection</code><a class="headerlink" href="#mne.realtime.RtEpochs.selection" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of integers of the current selection.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.set_channel_types">
<code class="descname">set_channel_types</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L399-L457"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog,
hbo, hbr</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">a dictionary mapping a channel to a sensor type (str)
{‘EEG061’: ‘eog’}.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.set_eeg_reference">
<code class="descname">set_eeg_reference</code><span class="sig-paren">(</span><em>ref_channels='average'</em>, <em>projection=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L252-L343"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.set_eeg_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify which reference to use for EEG data.</p>
<p>By default, MNE-Python will automatically re-reference the EEG signal
to use an average reference (see below). Use this function to
explicitly specify the desired reference for EEG. This can be either an
existing electrode or a new virtual channel. This function will
re-reference the data according to the desired reference and prevent
MNE-Python from automatically adding an average reference projection.</p>
<p>Some common referencing schemes and the corresponding value for the
<code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> parameter:</p>
<dl class="docutils">
<dt>No re-referencing:</dt>
<dd>If the EEG data is already using the proper reference, set
<code class="docutils literal notranslate"><span class="pre">ref_channels=[]</span></code>. This will prevent MNE-Python from
automatically adding an average reference projection.</dd>
<dt>Average reference:</dt>
<dd>A new virtual reference electrode is created by averaging the
current EEG signal by setting <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code>. Bad EEG
channels are automatically excluded if they are properly set in
<code class="docutils literal notranslate"><span class="pre">info['bads']</span></code>.</dd>
<dt>A single electrode:</dt>
<dd>Set <code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> to a list containing the name of the channel
that will act as the new reference, for example
<code class="docutils literal notranslate"><span class="pre">ref_channels=['Cz']</span></code>.</dd>
<dt>The mean of multiple electrodes:</dt>
<dd>A new virtual reference electrode is created by computing the
average of the current EEG signal recorded from two or more
selected channels. Set <code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> to a list of channel names,
indicating which channels to use. For example, to apply an average
mastoid reference, when using the 10-20 naming scheme, set
<code class="docutils literal notranslate"><span class="pre">ref_channels=['M1',</span> <span class="pre">'M2']</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ref_channels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str | str</span></dt>
<dd><p class="first last">The name(s) of the channel(s) used to construct the reference. To
apply an average reference, specify <code class="docutils literal notranslate"><span class="pre">'average'</span></code> here (default).
If an empty list is specified, the data is assumed to already have
a proper reference and MNE will not attempt any re-referencing of
the data. Defaults to an average reference.</p>
</dd>
<dt><strong>projection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code> this argument specifies if the
average reference should be computed as a projection (True) or not
(False; default). If <code class="docutils literal notranslate"><span class="pre">projection=True</span></code>, the average reference is
added as a projection and is not applied to the data (it can be
applied afterwards with the <code class="docutils literal notranslate"><span class="pre">apply_proj</span></code> method). If
<code class="docutils literal notranslate"><span class="pre">projection=False</span></code>, the average reference is directly applied to
the data. If <code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> is not <code class="docutils literal notranslate"><span class="pre">'average'</span></code>, <code class="docutils literal notranslate"><span class="pre">projection</span></code>
must be set to <code class="docutils literal notranslate"><span class="pre">False</span></code> (the default in this case).</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd><p class="first last">Data with EEG channels re-referenced. If <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code>
and <code class="docutils literal notranslate"><span class="pre">projection=True</span></code> a projection will be added instead of
directly re-referencing the data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="mne.set_bipolar_reference.html#mne.set_bipolar_reference" title="mne.set_bipolar_reference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.set_bipolar_reference</span></code></a></dt>
<dd>Convenience function for creating bipolar references.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>If a reference is requested that is not the average reference, this
function removes any pre-existing average reference projections.</li>
<li>During source localization, the EEG signal should have an average
reference.</li>
<li>In order to apply a reference, the data must be preloaded. This is
not necessary if <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code> and <code class="docutils literal notranslate"><span class="pre">projection=True</span></code>.</li>
<li>For an average reference, bad EEG channels are automatically
excluded if they are properly set in <code class="docutils literal notranslate"><span class="pre">info['bads']</span></code>.</li>
</ol>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.set_montage">
<code class="descname">set_montage</code><span class="sig-paren">(</span><em>montage</em>, <em>set_dig=True</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L475-L501"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration and head digitization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>montage</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Montage | instance of DigMontage | str | None</span></dt>
<dd><p class="first last">The montage to use (None removes any location information).</p>
</dd>
<dt><strong>set_dig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, update the digitization information (<code class="docutils literal notranslate"><span class="pre">info['dig']</span></code>)
in addition to the channel positions (<code class="docutils literal notranslate"><span class="pre">info['chs'][idx]['loc']</span></code>).</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.shift_time">
<code class="descname">shift_time</code><span class="sig-paren">(</span><em>tshift</em>, <em>relative=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L1869-L1896"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.shift_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift time scale in epoched data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tshift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The amount of time shift to be applied if relative is True
else the first time point. When relative is True, positive value
of tshift moves the data forward while negative tshift moves it
backward.</p>
</dd>
<dt><strong>relative</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, move the time backwards or forwards by specified amount.
Else, set the starting time point to the value of tshift.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Maximum accuracy of time shift is 1 / epochs.info[‘sfreq’]</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.standard_error">
<code class="descname">standard_error</code><span class="sig-paren">(</span><em>picks=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L879-L893"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.standard_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute standard error over epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">If None only MEG, EEG, SEEG, ECoG, and fNIRS channels are kept
otherwise the channels indices in picks are kept.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked</span></dt>
<dd><p class="first last">The standard error over epochs.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.start">
<code class="descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/realtime/epochs.py#L278-L291"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start receiving epochs.</p>
<p>The measurement will be started if it has not already been started.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><em>stop_receive_thread=True</em>, <em>stop_measurement=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/realtime/epochs.py#L293-L312"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop receiving epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>stop_receive_thread</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Stop the receive thread. Note: Other RtEpochs instances will also
stop receiving epochs when the receive thread is stopped. The
receive thread will always be stopped if stop_measurement is True.</p>
</dd>
<dt><strong>stop_measurement</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Also stop the measurement. Note: Other clients attached to the
server will also stop receiving data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.subtract_evoked">
<code class="descname">subtract_evoked</code><span class="sig-paren">(</span><em>evoked=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/epochs.py#L758-L828"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.subtract_evoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract an evoked response from each epoch.</p>
<p>Can be used to exclude the evoked response when analyzing induced
activity, see e.g. [1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked | None</span></dt>
<dd><p class="first last">The evoked response to subtract. If None, the evoked response
is computed from Epochs itself.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs</span></dt>
<dd><p class="first last">The modified instance (instance is also modified inplace).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>[1] David et al. “Mechanisms of evoked and induced responses in
MEG/EEG”, NeuroImage, vol. 31, no. 4, pp. 1580-1591, July 2006.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.time_as_index">
<code class="descname">time_as_index</code><span class="sig-paren">(</span><em>times</em>, <em>use_rounding=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/base.py#L214-L238"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list-like | float | int</span></dt>
<dd><p class="first last">List of numbers or a number representing points in time.</p>
</dd>
<dt><strong>use_rounding</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Indices corresponding to the times supplied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.times">
<code class="descname">times</code><a class="headerlink" href="#mne.realtime.RtEpochs.times" title="Permalink to this definition">¶</a></dt>
<dd><p>Time vector in seconds.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.tmax">
<code class="descname">tmax</code><a class="headerlink" href="#mne.realtime.RtEpochs.tmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Last time point.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.realtime.RtEpochs.tmin">
<code class="descname">tmin</code><a class="headerlink" href="#mne.realtime.RtEpochs.tmin" title="Permalink to this definition">¶</a></dt>
<dd><p>First time point.</p>
</dd></dl>

<dl class="method">
<dt id="mne.realtime.RtEpochs.to_data_frame">
<code class="descname">to_data_frame</code><span class="sig-paren">(</span><em>picks=None</em>, <em>index=None</em>, <em>scaling_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/base.py#L66-L208"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.realtime.RtEpochs.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of str | None</span></dt>
<dd><p class="first last">Column to be used as index for the data. Valid string options
are ‘epoch’, ‘time’ and ‘condition’. If None, all three info
columns will be included in the table as categorial data.</p>
</dd>
<dt><strong>scaling_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling to be applied to time units.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">Scaling to be applied to the channels picked. If None, defaults to
<code class="docutils literal notranslate"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></code>.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, data will be copied. Else data may be modified in place.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</dd>
<dt><strong>stop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of pandas.core.DataFrame</span></dt>
<dd><p class="first last">A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><img src="../_static/institutions.png" alt="Institutions"></div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-02-22.</p>
  </div>
</footer>
<script src="https://mne.tools/versionwarning.js"></script>
  </body>
</html>