<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>mne.Evoked &#8212; MNE 0.17.1 documentation</title>
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/reset-syntax.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <script type="text/javascript" src="../_static/copybutton.js"></script>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../_static/style.css " type="text/css" />
    <link rel="stylesheet" href="../_static/font-awesome.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flag-icon.css" type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  <link rel="canonical" href="https://mne.tools/stable/index.html" />
</head><body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.17.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Install</a></li>
                <li><a href="../documentation.html">Documentation</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../glossary.html">Glossary</a></li>
                <li><a href="../auto_examples/index.html">Examples</a></li>
                <li><a href="../contributing.html">Contribute</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-primary navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.17.1
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-tools.github.io/dev/index.html">Development</a></li>
    <li><a href="https://mne-tools.github.io/stable/index.html">v0.17 (stable)</a></li>
    <li><a href="https://mne-tools.github.io/0.16/index.html">v0.16</a></li>
    <li><a href="https://mne-tools.github.io/0.15/index.html">v0.15</a></li>
    <li><a href="https://mne-tools.github.io/0.14/index.html">v0.14</a></li>
    <li><a href="https://mne-tools.github.io/0.13/index.html">v0.13</a></li>
    <li><a href="https://mne-tools.github.io/0.12/index.html">v0.12</a></li>
    <li><a href="https://mne-tools.github.io/0.11/index.html">v0.11</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.Evoked</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="mne-evoked">
<h1>mne.Evoked<a class="headerlink" href="#mne-evoked" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.Evoked">
<em class="property">class </em><code class="descclassname">mne.</code><code class="descname">Evoked</code><span class="sig-paren">(</span><em>fname</em>, <em>condition=None</em>, <em>proj=True</em>, <em>kind='average'</em>, <em>allow_maxshield=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L47-L624"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Evoked data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of evoked/average FIF file to load.
If None no data is loaded.</p>
</dd>
<dt><strong>condition</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, or str</span></dt>
<dd><p class="first last">Dataset ID number (int) or comment/name (str). Optional if there is
only one data set in file.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Apply SSP projection vectors</p>
</dd>
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Either ‘average’ or ‘standard_error’. The type of data to read.
Only used if ‘condition’ is a str.</p>
</dd>
<dt><strong>allow_maxshield</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str (default False)</span></dt>
<dd><p class="first last">If True, allow loading of data that has been recorded with internal
active compensation (MaxShield). Data recorded with MaxShield should
generally not be loaded directly, but should first be processed using
SSS/tSSS to remove the compensation signals that may also affect brain
activity. Can also be “yes” to load without eliciting a warning.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Evoked objects contain a single condition only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Measurement info.</p>
</dd>
<dt><a class="reference internal" href="#mne.Evoked.ch_names" title="mne.Evoked.ch_names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ch_names</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">Channel names.</p>
</dd>
<dt><strong>nave</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of averaged epochs.</p>
</dd>
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Type of data, either average or standard_error.</p>
</dd>
<dt><strong>first</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">First time sample.</p>
</dd>
<dt><strong>last</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Last time sample.</p>
</dd>
<dt><strong>comment</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Comment on dataset. Can be the condition.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of time instants in seconds.</p>
</dd>
<dt><a class="reference internal" href="#mne.Evoked.data" title="mne.Evoked.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">array of shape (n_channels, n_times)</span></dt>
<dd><p class="first last">The data matrix.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Time vector in seconds. Goes from <cite>tmin</cite> to <cite>tmax</cite>. Time interval
between consecutive time samples is equal to the inverse of the
sampling frequency.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None.</span></dt>
<dd><p class="first last">See above.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.__contains__" title="mne.Evoked.__contains__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__contains__</span></code></a>(ch_type)</td>
<td>Check channel type membership.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.__hash__" title="mne.Evoked.__hash__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__hash__</span></code></a>()</td>
<td>Hash the object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.__neg__" title="mne.Evoked.__neg__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__neg__</span></code></a>()</td>
<td>Negate channel responses.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.add_channels" title="mne.Evoked.add_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_channels</span></code></a>(add_list[,&nbsp;force_update_info])</td>
<td>Append new channels to the instance.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.add_proj" title="mne.Evoked.add_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_proj</span></code></a>(projs[,&nbsp;remove_existing,&nbsp;verbose])</td>
<td>Add SSP projection vectors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.animate_topomap" title="mne.Evoked.animate_topomap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">animate_topomap</span></code></a>([ch_type,&nbsp;times,&nbsp;…])</td>
<td>Make animation of evoked data as topomap timeseries.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.anonymize" title="mne.Evoked.anonymize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">anonymize</span></code></a>()</td>
<td>Anonymize measurement information in place.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.apply_baseline" title="mne.Evoked.apply_baseline"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_baseline</span></code></a>([baseline,&nbsp;verbose])</td>
<td>Baseline correct evoked data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.apply_proj" title="mne.Evoked.apply_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_proj</span></code></a>()</td>
<td>Apply the signal space projection (SSP) operators to the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.as_type" title="mne.Evoked.as_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_type</span></code></a>([ch_type,&nbsp;mode])</td>
<td>Compute virtual evoked using interpolated fields.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.copy" title="mne.Evoked.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</td>
<td>Copy the instance of evoked.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.crop" title="mne.Evoked.crop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">crop</span></code></a>([tmin,&nbsp;tmax])</td>
<td>Crop data to a given time interval.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.decimate" title="mne.Evoked.decimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code></a>(decim[,&nbsp;offset])</td>
<td>Decimate the evoked data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.del_proj" title="mne.Evoked.del_proj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">del_proj</span></code></a>([idx])</td>
<td>Remove SSP projection vector.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.detrend" title="mne.Evoked.detrend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">detrend</span></code></a>([order,&nbsp;picks])</td>
<td>Detrend data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.drop_channels" title="mne.Evoked.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>(ch_names)</td>
<td>Drop some channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.filter" title="mne.Evoked.filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">filter</span></code></a>(l_freq,&nbsp;h_freq[,&nbsp;picks,&nbsp;…])</td>
<td>Filter a subset of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.get_peak" title="mne.Evoked.get_peak"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_peak</span></code></a>([ch_type,&nbsp;tmin,&nbsp;tmax,&nbsp;mode,&nbsp;…])</td>
<td>Get location and latency of peak amplitude.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.interpolate_bads" title="mne.Evoked.interpolate_bads"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_bads</span></code></a>([reset_bads,&nbsp;mode,&nbsp;origin,&nbsp;…])</td>
<td>Interpolate bad MEG and EEG channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.pick_channels" title="mne.Evoked.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a>(ch_names)</td>
<td>Pick some channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.pick_types" title="mne.Evoked.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;…])</td>
<td>Pick some channels by type and names.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot" title="mne.Evoked.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a>([picks,&nbsp;exclude,&nbsp;unit,&nbsp;show,&nbsp;ylim,&nbsp;…])</td>
<td>Plot evoked data using butterfly plots.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_field" title="mne.Evoked.plot_field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_field</span></code></a>(surf_maps[,&nbsp;time,&nbsp;time_label,&nbsp;n_jobs])</td>
<td>Plot MEG/EEG fields on head surface and helmet in 3D.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_image" title="mne.Evoked.plot_image"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_image</span></code></a>([picks,&nbsp;exclude,&nbsp;unit,&nbsp;show,&nbsp;…])</td>
<td>Plot evoked data as images.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_joint" title="mne.Evoked.plot_joint"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_joint</span></code></a>([times,&nbsp;title,&nbsp;picks,&nbsp;exclude,&nbsp;…])</td>
<td>Plot evoked data as butterfly plot and add topomaps for time points.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_projs_topomap" title="mne.Evoked.plot_projs_topomap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_projs_topomap</span></code></a>([ch_type,&nbsp;layout,&nbsp;axes])</td>
<td>Plot SSP vector.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_sensors" title="mne.Evoked.plot_sensors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_sensors</span></code></a>([kind,&nbsp;ch_type,&nbsp;title,&nbsp;…])</td>
<td>Plot sensor positions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_topo" title="mne.Evoked.plot_topo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_topo</span></code></a>([layout,&nbsp;layout_scale,&nbsp;color,&nbsp;…])</td>
<td>Plot 2D topography of evoked responses.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.plot_topomap" title="mne.Evoked.plot_topomap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_topomap</span></code></a>([times,&nbsp;ch_type,&nbsp;layout,&nbsp;vmin,&nbsp;…])</td>
<td>Plot topographic maps of specific time points of evoked data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.plot_white" title="mne.Evoked.plot_white"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_white</span></code></a>(noise_cov[,&nbsp;show,&nbsp;rank,&nbsp;…])</td>
<td>Plot whitened evoked response.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.rename_channels" title="mne.Evoked.rename_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename_channels</span></code></a>(mapping)</td>
<td>Rename channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.reorder_channels" title="mne.Evoked.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a>(ch_names)</td>
<td>Reorder channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.resample" title="mne.Evoked.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resample</span></code></a>(sfreq[,&nbsp;npad,&nbsp;window,&nbsp;n_jobs,&nbsp;pad,&nbsp;…])</td>
<td>Resample data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.save" title="mne.Evoked.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>(fname)</td>
<td>Save dataset to file.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.savgol_filter" title="mne.Evoked.savgol_filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">savgol_filter</span></code></a>(h_freq[,&nbsp;verbose])</td>
<td>Filter the data using Savitzky-Golay polynomial method.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.set_channel_types" title="mne.Evoked.set_channel_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_channel_types</span></code></a>(mapping)</td>
<td>Define the sensor type of channels.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.set_eeg_reference" title="mne.Evoked.set_eeg_reference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_eeg_reference</span></code></a>([ref_channels,&nbsp;…])</td>
<td>Specify which reference to use for EEG data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.set_montage" title="mne.Evoked.set_montage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_montage</span></code></a>(montage[,&nbsp;set_dig,&nbsp;verbose])</td>
<td>Set EEG sensor configuration and head digitization.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.shift_time" title="mne.Evoked.shift_time"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shift_time</span></code></a>(tshift[,&nbsp;relative])</td>
<td>Shift time scale in evoked data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.Evoked.time_as_index" title="mne.Evoked.time_as_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">time_as_index</span></code></a>(times[,&nbsp;use_rounding])</td>
<td>Convert time to indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.Evoked.to_data_frame" title="mne.Evoked.to_data_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_data_frame</span></code></a>([picks,&nbsp;index,&nbsp;scaling_time,&nbsp;…])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.Evoked.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>ch_type</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L163-L191"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check channel type membership.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Channel type to check for. Can be e.g. ‘meg’, ‘eeg’, ‘stim’, etc.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>in</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether or not the instance contains the given channel type.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Channel type membership can be tested as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;meg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;seeg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/utils.py#L2348-L2365"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>hash</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The hash</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.__neg__">
<code class="descname">__neg__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L497-L509"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.__neg__" title="Permalink to this definition">¶</a></dt>
<dd><p>Negate channel responses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked_neg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked</span></dt>
<dd><p class="first last">The Evoked instance with channel data negated and ‘-‘
prepended to the comment.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.add_channels">
<code class="descname">add_channels</code><span class="sig-paren">(</span><em>add_list</em>, <em>force_update_info=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L822-L910"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>add_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of objects to append to self. Must contain all the same
type as the current object</p>
</dd>
<dt><strong>force_update_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If True, force the info for objects to be appended to match the
values in <cite>self</cite>. This should generally only be used when adding
stim channels for which important metadata won’t be overwritten.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.Evoked.drop_channels" title="mne.Evoked.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">self</span></code> is a Raw instance that has been preloaded into a
<a class="reference external" href="https://www.numpy.org/devdocs/reference/generated/numpy.memmap.html#numpy.memmap" title="(in NumPy v1.17.dev0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.memmap</span></code></a> instance, the memmap will be resized.</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.add_proj">
<code class="descname">add_proj</code><span class="sig-paren">(</span><em>projs</em>, <em>remove_existing=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L150-L191"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>projs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List with projection vectors.</p>
</dd>
<dt><strong>remove_existing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Remove the projection vectors currently in the file.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd><p class="first last">The data container.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.animate_topomap">
<code class="descname">animate_topomap</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>times=None</em>, <em>frame_rate=None</em>, <em>butterfly=False</em>, <em>blit=True</em>, <em>show=True</em>, <em>time_unit='s'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L384-L433"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.animate_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Make animation of evoked data as topomap timeseries.</p>
<p>The animation can be paused/resumed with left mouse button.
Left and right arrow keys can be used to move backward or forward
in time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Channel type to plot. Accepted data types: ‘mag’, ‘grad’, ‘eeg’.
If None, first available channel type from (‘mag’, ‘grad’, ‘eeg’)
is used. Defaults to None.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of floats | None</span></dt>
<dd><p class="first last">The time points to plot. If None, 10 evenly spaced samples are
calculated over the evoked time series. Defaults to None.</p>
</dd>
<dt><strong>frame_rate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">Frame rate for the animation in Hz. If None,
frame rate = sfreq / 10. Defaults to None.</p>
</dd>
<dt><strong>butterfly</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to plot the data as butterfly plot under the topomap.
Defaults to False.</p>
</dd>
<dt><strong>blit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to use blit to optimize drawing. In general, it is
recommended to use blit in combination with <code class="docutils literal notranslate"><span class="pre">show=True</span></code>. If you
intend to save the animation it is better to disable blit.
Defaults to True.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to show the animation. Defaults to True.</p>
</dd>
<dt><strong>time_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The units for the time axis, can be “ms” (default in 0.16)
or “s” (will become the default in 0.17).</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">The figure.</p>
</dd>
<dt><strong>anim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib FuncAnimation</span></dt>
<dd><p class="first last">Animation of the topomap.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.anonymize">
<code class="descname">anonymize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L583-L595"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.anonymize" title="Permalink to this definition">¶</a></dt>
<dd><p>Anonymize measurement information in place.</p>
<p>Reset ‘subject_info’, ‘meas_date’, ‘file_id’, and ‘meas_id’ keys if they
exist in <code class="docutils literal notranslate"><span class="pre">info</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Info</span></dt>
<dd><p class="first last">Measurement information for the dataset.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.apply_baseline">
<code class="descname">apply_baseline</code><span class="sig-paren">(</span><em>baseline=(None</em>, <em>0)</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L133-L165"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.apply_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseline correct evoked data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>baseline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of length 2</span></dt>
<dd><p class="first last">The time interval to apply baseline correction. If None do not
apply it. If baseline is (a, b) the interval is between “a (s)” and
“b (s)”. If a is None the beginning of the data is used and if b is
None then b is set to the end of the interval. If baseline is equal
to (None, None) all the time interval is used. Correction is
applied by computing mean of the baseline period and subtracting it
from the data. The baseline (a, b) includes both endpoints, i.e.
all timepoints t such that a &lt;= t &lt;= b.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked</span></dt>
<dd><p class="first last">The baseline-corrected Evoked object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Baseline correction can be done multiple times.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.apply_proj">
<code class="descname">apply_proj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L193-L257"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd><p class="first last">The instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c1"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c1"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.as_type">
<code class="descname">as_type</code><span class="sig-paren">(</span><em>ch_type='grad'</em>, <em>mode='fast'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L435-L462"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.as_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute virtual evoked using interpolated fields.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Using virtual evoked to compute inverse can yield
unexpected results. The virtual channels have <cite>‘_v’</cite> appended
at the end of the names to emphasize that the data contained in
them are interpolated.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The destination channel type. It can be ‘mag’ or ‘grad’.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Either <cite>‘accurate’</cite> or <cite>‘fast’</cite>, determines the quality of the
Legendre polynomial expansion used. <cite>‘fast’</cite> should be sufficient
for most applications.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of mne.Evoked</span></dt>
<dd><p class="first last">The transformed evoked object containing only virtual channels.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="mne.Evoked.ch_names">
<code class="descname">ch_names</code><a class="headerlink" href="#mne.Evoked.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.Evoked.compensation_grade">
<code class="descname">compensation_grade</code><a class="headerlink" href="#mne.Evoked.compensation_grade" title="Permalink to this definition">¶</a></dt>
<dd><p>The current gradient compensation grade.</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L487-L495"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the instance of evoked.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>tmin=None</em>, <em>tmax=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L197-L222"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crop data to a given time interval.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Start time of selection in seconds.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">End time of selection in seconds.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked</span></dt>
<dd><p class="first last">The cropped Evoked object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Unlike Python slices, MNE time intervals include both their end points;
crop(tmin, tmax) returns the interval tmin &lt;= t &lt;= tmax.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.Evoked.data">
<code class="descname">data</code><a class="headerlink" href="#mne.Evoked.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The data matrix.</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.decimate">
<code class="descname">decimate</code><span class="sig-paren">(</span><em>decim</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L224-L265"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Decimate the evoked data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No filtering is performed. To avoid aliasing, ensure
your data are properly lowpassed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>decim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The amount to decimate data.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Apply an offset to where the decimation starts relative to the
sample corresponding to t=0. The offset is in samples at the
current sampling rate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked</span></dt>
<dd><p class="first last">The decimated Evoked object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.Epochs.html#mne.Epochs.decimate" title="mne.Epochs.decimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Epochs.decimate</span></code></a>, <a class="reference internal" href="mne.Epochs.html#mne.Epochs.resample" title="mne.Epochs.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Epochs.resample</span></code></a>, <a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.resample" title="mne.io.Raw.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.io.Raw.resample</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Decimation can be done multiple times. For example,
<code class="docutils literal notranslate"><span class="pre">evoked.decimate(2).decimate(2)</span></code> will be the same as
<code class="docutils literal notranslate"><span class="pre">evoked.decimate(4)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.del_proj">
<code class="descname">del_proj</code><span class="sig-paren">(</span><em>idx='all'</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L259-L284"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector.</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | list of int | str</span></dt>
<dd><p class="first last">Index of the projector to remove. Can also be “all” (default)
to remove all projectors.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>self</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.detrend">
<code class="descname">detrend</code><span class="sig-paren">(</span><em>order=1</em>, <em>picks=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L464-L485"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Detrend data.</p>
<p>This function operates in-place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Either 0 or 1, the order of the detrending. 0 is a constant
(DC) detrend, 1 is a linear detrend.</p>
</dd>
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">If None only MEG, EEG, SEEG, ECoG and fNIRS channels are detrended.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>evoked</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Evoked</span></dt>
<dd><p class="first last">The detrended evoked object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.drop_channels">
<code class="descname">drop_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L757-L798"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of the names of the channels to remove.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.Evoked.reorder_channels" title="mne.Evoked.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a>, <a class="reference internal" href="mne.pick_channels.html#mne.pick_channels" title="mne.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a>, <a class="reference internal" href="mne.pick_types.html#mne.pick_types" title="mne.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.filter">
<code class="descname">filter</code><span class="sig-paren">(</span><em>l_freq</em>, <em>h_freq</em>, <em>picks=None</em>, <em>filter_length='auto'</em>, <em>l_trans_bandwidth='auto'</em>, <em>h_trans_bandwidth='auto'</em>, <em>n_jobs=1</em>, <em>method='fir'</em>, <em>iir_params=None</em>, <em>phase='zero'</em>, <em>fir_window='hamming'</em>, <em>fir_design='firwin'</em>, <em>pad='edge'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/filter.py#L1920-L2047"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter a subset of channels.</p>
<p>Applies a zero-phase low-pass, high-pass, band-pass, or band-stop
filter to the channels selected by <code class="docutils literal notranslate"><span class="pre">picks</span></code>.
The data are modified inplace.</p>
<p>The object has to have the data loaded e.g. with <code class="docutils literal notranslate"><span class="pre">preload=True</span></code>
or <code class="docutils literal notranslate"><span class="pre">self.load_data()</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">l_freq</span></code> and <code class="docutils literal notranslate"><span class="pre">h_freq</span></code> are the frequencies below which and above
which, respectively, to filter out of the data. Thus the uses are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">&lt;</span> <span class="pre">h_freq</span></code>: band-pass filter</li>
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">&gt;</span> <span class="pre">h_freq</span></code>: band-stop filter</li>
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">None</span></code>: high-pass filter</li>
<li><code class="docutils literal notranslate"><span class="pre">l_freq</span> <span class="pre">is</span> <span class="pre">None</span> <span class="pre">and</span> <span class="pre">h_freq</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>: low-pass filter</li>
</ul>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">self.info['lowpass']</span></code> and <code class="docutils literal notranslate"><span class="pre">self.info['highpass']</span></code> are only
updated with picks=None.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If n_jobs &gt; 1, more memory is required as
<code class="docutils literal notranslate"><span class="pre">len(picks)</span> <span class="pre">*</span> <span class="pre">n_times</span></code> additional time points need to
be temporaily stored in memory.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>l_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Low cut-off frequency in Hz. If None the data are only low-passed.</p>
</dd>
<dt><strong>h_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">High cut-off frequency in Hz. If None the data are only
high-passed.</p>
</dd>
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">Indices of channels to filter. If None only the data (MEG/EEG)
channels will be filtered.</p>
</dd>
<dt><strong>filter_length</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | int</span></dt>
<dd><p class="first">Length of the FIR filter to use (if applicable):</p>
<ul class="last simple">
<li>‘auto’ (default): the filter length is chosen based
on the size of the transition regions (6.6 times the reciprocal
of the shortest transition band for fir_window=’hamming’
and fir_design=”firwin2”, and half that for “firwin”).</li>
<li>str: a human-readable time in
units of “s” or “ms” (e.g., “10s” or “5500ms”) will be
converted to that number of samples if <code class="docutils literal notranslate"><span class="pre">phase=&quot;zero&quot;</span></code>, or
the shortest power-of-two length at least that duration for
<code class="docutils literal notranslate"><span class="pre">phase=&quot;zero-double&quot;</span></code>.</li>
<li>int: specified length in samples. For fir_design=”firwin”,
this should not be used.</li>
</ul>
</dd>
<dt><strong>l_trans_bandwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | str</span></dt>
<dd><p class="first">Width of the transition band at the low cut-off frequency in Hz
(high pass or cutoff 1 in bandpass). Can be “auto”
(default) to use a multiple of <code class="docutils literal notranslate"><span class="pre">l_freq</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">l_freq</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">l_freq</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Only used for <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.</p>
</dd>
<dt><strong>h_trans_bandwidth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | str</span></dt>
<dd><p class="first">Width of the transition band at the high cut-off frequency in Hz
(low pass or cutoff 2 in bandpass). Can be “auto”
(default) to use a multiple of <code class="docutils literal notranslate"><span class="pre">h_freq</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">h_freq</span> <span class="o">*</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="n">h_freq</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">Only used for <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Number of jobs to run in parallel. Can be ‘cuda’ if <code class="docutils literal notranslate"><span class="pre">cupy</span></code>
is installed properly and method=’fir’.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">‘fir’ will use overlap-add FIR filtering, ‘iir’ will use IIR
forward-backward filtering (via filtfilt).</p>
</dd>
<dt><strong>iir_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">Dictionary of parameters to use for IIR filtering.
See mne.filter.construct_iir_filter for details. If iir_params
is None and method=”iir”, 4th order Butterworth will be used.</p>
</dd>
<dt><strong>phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Phase of the filter, only used if <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.
By default, a symmetric linear-phase FIR filter is constructed.
If <code class="docutils literal notranslate"><span class="pre">phase='zero'</span></code> (default), the delay of this filter
is compensated for. If <code class="docutils literal notranslate"><span class="pre">phase=='zero-double'</span></code>, then this filter
is applied twice, once forward, and once backward. If ‘minimum’,
then a minimum-phase, causal filter will be used.</p>
</dd>
<dt><strong>fir_window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The window to use in FIR design, can be “hamming” (default),
“hann” (default in 0.13), or “blackman”.</p>
</dd>
<dt><strong>fir_design</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Can be “firwin” (default) to use <a class="reference external" href="https://scipy.github.io/devdocs/generated/scipy.signal.firwin.html#scipy.signal.firwin" title="(in SciPy v1.3.0.dev0+446cf44)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.firwin()</span></code></a>,
or “firwin2” to use <a class="reference external" href="https://scipy.github.io/devdocs/generated/scipy.signal.firwin2.html#scipy.signal.firwin2" title="(in SciPy v1.3.0.dev0+446cf44)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.firwin2()</span></code></a>. “firwin” uses
a time-domain design technique that generally gives improved
attenuation using fewer samples than “firwin2”.</p>
</dd>
<dt><strong>pad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The type of padding to use. Supports all <a class="reference external" href="https://www.numpy.org/devdocs/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.17.dev0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.pad()</span></code></a> <code class="docutils literal notranslate"><span class="pre">mode</span></code>
options. Can also be “reflect_limited”, which pads with a
reflected version of each vector mirrored on the first and last
values of the vector, followed by zeros. The default is “edge”,
which pads with the edge values of each vector.
Only used for <code class="docutils literal notranslate"><span class="pre">method='fir'</span></code>.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs or Evoked</span></dt>
<dd><p class="first last">The filtered data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.15.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.get_peak">
<code class="descname">get_peak</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>mode='abs'</em>, <em>time_as_index=False</em>, <em>merge_grads=False</em>, <em>return_amplitude=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L511-L624"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.get_peak" title="Permalink to this definition">¶</a></dt>
<dd><p>Get location and latency of peak amplitude.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’, ‘grad’, ‘eeg’, ‘seeg’, ‘ecog’, ‘hbo’, hbr’, ‘misc’, None  # noqa</span></dt>
<dd><p class="first last">The channel type to use. Defaults to None. If more than one sensor
Type is present in the data the channel type has to be explicitly
set.</p>
</dd>
<dt><strong>tmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The minimum point in time to be considered for peak getting.
If None (default), the beginning of the data is used.</p>
</dd>
<dt><strong>tmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The maximum point in time to be considered for peak getting.
If None (default), the end of the data is used.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{‘pos’, ‘neg’, ‘abs’}</span></dt>
<dd><p class="first last">How to deal with the sign of the data. If ‘pos’ only positive
values will be considered. If ‘neg’ only negative values will
be considered. If ‘abs’ absolute values will be considered.
Defaults to ‘abs’.</p>
</dd>
<dt><strong>time_as_index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to return the time index instead of the latency in seconds.</p>
</dd>
<dt><strong>merge_grads</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, compute peak from merged gradiometer data.</p>
</dd>
<dt><strong>return_amplitude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If True, return also the amplitude at the maximum response.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ch_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The channel exhibiting the maximum response.</p>
</dd>
<dt><strong>latency</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | int</span></dt>
<dd><p class="first last">The time point of the maximum response, either latency in seconds
or index.</p>
</dd>
<dt><strong>amplitude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first">The amplitude of the maximum response. Only returned if
return_amplitude is True.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.interpolate_bads">
<code class="descname">interpolate_bads</code><span class="sig-paren">(</span><em>reset_bads=True</em>, <em>mode='accurate'</em>, <em>origin=(0.0</em>, <em>0.0</em>, <em>0.04)</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L916-L965"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>reset_bads</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, remove the bads from info.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Either <code class="docutils literal notranslate"><span class="pre">'accurate'</span></code> or <code class="docutils literal notranslate"><span class="pre">'fast'</span></code>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</dd>
<dt><strong>origin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like, shape (3,) | str</span></dt>
<dd><p class="first">Origin of the sphere in the head coordinate frame and in meters.
Can be <code class="docutils literal notranslate"><span class="pre">'auto'</span></code>, which means a head-digitization-based origin
fit. Default is <code class="docutils literal notranslate"><span class="pre">(0.,</span> <span class="pre">0.,</span> <span class="pre">0.04)</span></code>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.17.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.pick_channels">
<code class="descname">pick_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L692-L720"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The list of channels to select.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.Evoked.drop_channels" title="mne.Evoked.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>, <a class="reference internal" href="mne.pick_types.html#mne.pick_types" title="mne.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>, <a class="reference internal" href="#mne.Evoked.reorder_channels" title="mne.Evoked.reorder_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The channel names given are assumed to be a set, i.e. the order
does not matter. The original order of the channels is preserved.
You can use <code class="docutils literal notranslate"><span class="pre">reorder_channels</span></code> to set channel order if necessary.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.pick_types">
<code class="descname">pick_types</code><span class="sig-paren">(</span><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>dipole=False</em>, <em>gof=False</em>, <em>bio=False</em>, <em>ecog=False</em>, <em>fnirs=False</em>, <em>include=()</em>, <em>exclude='bads'</em>, <em>selection=None</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L601-L690"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>meg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">If True include all MEG channels. If False include None
If string it can be ‘mag’, ‘grad’, ‘planar1’ or ‘planar2’ to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</dd>
<dt><strong>eeg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EEG channels.</p>
</dd>
<dt><strong>stim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include stimulus channels.</p>
</dd>
<dt><strong>eog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EOG channels.</p>
</dd>
<dt><strong>ecg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include ECG channels.</p>
</dd>
<dt><strong>emg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include EMG channels.</p>
</dd>
<dt><strong>ref_meg: bool | str</strong></dt>
<dd><p class="first last">If True include CTF / 4D reference channels. If ‘auto’, the
reference channels are only included if compensations are present.</p>
</dd>
<dt><strong>misc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include miscellaneous analog channels.</p>
</dd>
<dt><strong>resp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</dd>
<dt><strong>chpi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True include continuous HPI coil channels.</p>
</dd>
<dt><strong>exci</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Flux excitation channel used to be a stimulus channel.</p>
</dd>
<dt><strong>ias</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Internal Active Shielding data (maybe on Triux only).</p>
</dd>
<dt><strong>syst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">System status channel information (on Triux systems only).</p>
</dd>
<dt><strong>seeg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Stereotactic EEG channels.</p>
</dd>
<dt><strong>dipole</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Dipole time course channels.</p>
</dd>
<dt><strong>gof</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Dipole goodness of fit channels.</p>
</dd>
<dt><strong>bio</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Bio channels.</p>
</dd>
<dt><strong>ecog</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Electrocorticography channels.</p>
</dd>
<dt><strong>fnirs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Functional near-infrared spectroscopy channels. If True include all
fNIRS channels. If False (default) include none. If string it can
be ‘hbo’ (to include channels measuring oxyhemoglobin) or ‘hbr’ (to
include channels measuring deoxyhemoglobin).</p>
</dd>
<dt><strong>include</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">List of additional channels to include. If empty do not include
any.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string | str</span></dt>
<dd><p class="first last">List of channels to exclude. If ‘bads’ (default), exclude channels
in <code class="docutils literal notranslate"><span class="pre">info['bads']</span></code>.</p>
</dd>
<dt><strong>selection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd><p class="first last">Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.pick_channels.html#mne.pick_channels" title="mne.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>picks=None</em>, <em>exclude='bads'</em>, <em>unit=True</em>, <em>show=True</em>, <em>ylim=None</em>, <em>xlim='tight'</em>, <em>proj=False</em>, <em>hline=None</em>, <em>units=None</em>, <em>scalings=None</em>, <em>titles=None</em>, <em>axes=None</em>, <em>gfp=False</em>, <em>window_title=None</em>, <em>spatial_colors=False</em>, <em>zorder='unsorted'</em>, <em>selectable=True</em>, <em>noise_cov=None</em>, <em>time_unit='s'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L295-L307"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data using butterfly plots.</p>
<p>Left click to a line shows the channel name. Selecting an area by clicking
and holding left mouse button plots a topographic map of the painted area.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If bad channels are not excluded they are shown in red.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">The indices of channels to plot. If None show all.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str | ‘bads’</span></dt>
<dd><p class="first last">Channels names to exclude from being shown. If ‘bads’, the
bad channels are excluded.</p>
</dd>
<dt><strong>unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Scale plot with channel (SI) unit.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt><strong>ylim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">ylim for plots (after scaling has been applied). e.g.
ylim = dict(eeg=[-20, 20])
Valid keys are eeg, mag, grad, misc. If None, the ylim parameter
for each channel equals the pyplot default.</p>
</dd>
<dt><strong>xlim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘tight’ | tuple | None</span></dt>
<dd><p class="first last">xlim for plots.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | ‘interactive’</span></dt>
<dd><p class="first last">If true SSP projections are applied before display. If ‘interactive’,
a check box for reversible selection of SSP projection vectors will
be shown.</p>
</dd>
<dt><strong>hline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of floats | None</span></dt>
<dd><p class="first last">The values at which to show an horizontal line.</p>
</dd>
<dt><strong>units</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The units of the channel types used for axes labels. If None,
defaults to <cite>dict(eeg=’uV’, grad=’fT/cm’, mag=’fT’)</cite>.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The scalings of the channel types to be applied for plotting. If None,
defaults to <code class="docutils literal notranslate"><span class="pre">dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15)</span></code>.</p>
</dd>
<dt><strong>titles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The titles associated with the channels. If None, defaults to
<cite>dict(eeg=’EEG’, grad=’Gradiometers’, mag=’Magnetometers’)</cite>.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axis | list | None</span></dt>
<dd><p class="first last">The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of channel types. If instance of
Axes, there must be only one channel type plotted.</p>
</dd>
<dt><strong>gfp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | ‘only’</span></dt>
<dd><p class="first last">Plot GFP in green if True or “only”. If “only”, then the individual
channel traces will not be shown.</p>
</dd>
<dt><strong>window_title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">The title to put at the top of the figure.</p>
</dd>
<dt><strong>spatial_colors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the lines are color coded by mapping physical sensor
coordinates into color values. Spatially similar channels will have
similar colors. Bad channels will be dotted. If False, the good
channels are plotted black and bad channels red. Defaults to False.</p>
</dd>
<dt><strong>zorder</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | callable</span></dt>
<dd><p class="first">Which channels to put in the front or back. Only matters if
<cite>spatial_colors</cite> is used.
If str, must be <cite>std</cite> or <cite>unsorted</cite> (defaults to <cite>unsorted</cite>). If
<cite>std</cite>, data with the lowest standard deviation (weakest effects) will
be put in front so that they are not obscured by those with stronger
effects. If <cite>unsorted</cite>, channels are z-sorted as in the evoked
instance.
If callable, must take one argument: a numpy array of the same
dimensionality as the evoked raw data; and return a list of
unique integers corresponding to the number of channels.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>selectable</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Whether to use interactive features. If True (default), it is possible
to paint an area to draw topomaps. When False, the interactive features
are disabled. Disabling interactive features reduces memory consumption
and is useful when using <code class="docutils literal notranslate"><span class="pre">axes</span></code> parameter to draw multiaxes figures.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>noise_cov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Covariance | str | None</span></dt>
<dd><p class="first">Noise covariance used to whiten the data while plotting.
Whitened data channel names are shown in italic.
Can be a string to load a covariance from disk.
See also <a class="reference internal" href="#mne.Evoked.plot_white" title="mne.Evoked.plot_white"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Evoked.plot_white()</span></code></a> for additional inspection
of noise covariance properties when whitening evoked data.
For data processed with SSS, the effective dependence between
magnetometers and gradiometers may introduce differences in scaling,
consider using <a class="reference internal" href="#mne.Evoked.plot_white" title="mne.Evoked.plot_white"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Evoked.plot_white()</span></code></a>.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd>
<dt><strong>time_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The units for the time axis, can be “ms” or “s” (default).</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib.figure.Figure</span></dt>
<dd><p class="first last">Figure containing the butterfly plots.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.viz.plot_evoked_white.html#mne.viz.plot_evoked_white" title="mne.viz.plot_evoked_white"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.viz.plot_evoked_white</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_field">
<code class="descname">plot_field</code><span class="sig-paren">(</span><em>surf_maps</em>, <em>time=None</em>, <em>time_label='t = %0.0f ms'</em>, <em>n_jobs=1</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L363-L367"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot MEG/EEG fields on head surface and helmet in 3D.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>surf_maps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The surface mapping information obtained with make_field_map.</p>
</dd>
<dt><strong>time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The time point at which the field map shall be displayed. If None,
the average peak latency (across sensor types) is used.</p>
</dd>
<dt><strong>time_label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">How to print info about the time instant visualized.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of jobs to run in parallel.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of mlab.Figure</span></dt>
<dd><p class="first last">The mayavi figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_image">
<code class="descname">plot_image</code><span class="sig-paren">(</span><em>picks=None</em>, <em>exclude='bads'</em>, <em>unit=True</em>, <em>show=True</em>, <em>clim=None</em>, <em>xlim='tight'</em>, <em>proj=False</em>, <em>units=None</em>, <em>scalings=None</em>, <em>titles=None</em>, <em>axes=None</em>, <em>cmap='RdBu_r'</em>, <em>colorbar=True</em>, <em>mask=None</em>, <em>mask_style=None</em>, <em>mask_cmap='Greys'</em>, <em>mask_alpha=0.25</em>, <em>time_unit='s'</em>, <em>show_names=None</em>, <em>group_by=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L309-L321"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data as images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">The indices of channels to plot. If None show all.
This parameter can also be used to set the order the channels
are shown in, as the channel image is sorted by the order of picks.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str | ‘bads’</span></dt>
<dd><p class="first last">Channels names to exclude from being shown. If ‘bads’, the
bad channels are excluded.</p>
</dd>
<dt><strong>unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Scale plot with channel (SI) unit.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt><strong>clim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">clim for plots (after scaling has been applied). e.g.
clim = dict(eeg=[-20, 20])
Valid keys are eeg, mag, grad, misc. If None, the clim parameter
for each channel equals the pyplot default.</p>
</dd>
<dt><strong>xlim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘tight’ | tuple | None</span></dt>
<dd><p class="first last">xlim for plots.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | ‘interactive’</span></dt>
<dd><p class="first last">If true SSP projections are applied before display. If ‘interactive’,
a check box for reversible selection of SSP projection vectors will
be shown.</p>
</dd>
<dt><strong>units</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The units of the channel types used for axes labels. If None,
defaults to <code class="docutils literal notranslate"><span class="pre">dict(eeg='uV',</span> <span class="pre">grad='fT/cm',</span> <span class="pre">mag='fT')</span></code>.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The scalings of the channel types to be applied for plotting. If None,`
defaults to <code class="docutils literal notranslate"><span class="pre">dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15)</span></code>.</p>
</dd>
<dt><strong>titles</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The titles associated with the channels. If None, defaults to
<code class="docutils literal notranslate"><span class="pre">dict(eeg='EEG',</span> <span class="pre">grad='Gradiometers',</span> <span class="pre">mag='Magnetometers')</span></code>.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axis | list | dict | None</span></dt>
<dd><p class="first last">The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of channel types. If instance of
Axes, there must be only one channel type plotted.
If <cite>group_by</cite> is a dict, this cannot be a list, but it can be a dict
of lists of axes, with the keys matching those of <cite>group_by</cite>. In that
case, the provided axes will be used for the corresponding groups.
Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’</span></dt>
<dd><p class="first last">Colormap. If tuple, the first value indicates the colormap to use and
the second value is a boolean defining interactivity. In interactive
mode the colors are adjustable by clicking and dragging the colorbar
with left and right mouse button. Left mouse button moves the scale up
and down and right mouse button adjusts the range. Hitting space bar
resets the scale. Up and down arrows can be used to change the
colormap. If ‘interactive’, translates to <code class="docutils literal notranslate"><span class="pre">('RdBu_r',</span> <span class="pre">True)</span></code>.
Defaults to <code class="docutils literal notranslate"><span class="pre">'RdBu_r'</span></code>.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">If True, plot a colorbar. Defaults to True.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray | None</span></dt>
<dd><p class="first">An array of booleans of the same shape as the data. Entries of the
data that correspond to <code class="docutils literal notranslate"><span class="pre">`False</span></code> in the mask are masked (see
<cite>do_mask</cite> below). Useful for, e.g., masking for statistical
significance.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
<dt><strong>mask_style: None | ‘both’ | ‘contour’ | ‘mask’</strong></dt>
<dd><p class="first">If <cite>mask</cite> is not None: if ‘contour’, a contour line is drawn around
the masked areas (<code class="docutils literal notranslate"><span class="pre">True</span></code> in <cite>mask</cite>). If ‘mask’, entries not
<code class="docutils literal notranslate"><span class="pre">True</span></code> in <cite>mask</cite> are shown transparently. If ‘both’, both a contour
and transparency are used.
If <code class="docutils literal notranslate"><span class="pre">None</span></code>, defaults to ‘both’ if <cite>mask</cite> is not None, and is ignored
otherwise.</p>
<blockquote class="last">
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</div></blockquote>
</dd>
<dt><strong>mask_cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’</span></dt>
<dd><p class="first last">The colormap chosen for masked parts of the image (see below), if
<cite>mask</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>. If None, <cite>cmap</cite> is reused. Defaults to
<code class="docutils literal notranslate"><span class="pre">Greys</span></code>. Not interactive. Otherwise, as <cite>cmap</cite>.</p>
</dd>
<dt><strong>mask_alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first">A float between 0 and 1. If <cite>mask</cite> is not None, this sets the
alpha level (degree of transparency) for the masked-out segments.
I.e., if 0, masked-out segments are not visible at all.
Defaults to .25.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
<dt><strong>time_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The units for the time axis, can be “ms” or “s” (default).</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
<dt><strong>show_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Determines if channel names should be plotted on the y axis. If False,
no names are shown. If True, ticks are set automatically and the
corresponding channel names are shown. If str, must be “auto” or “all”.
If “all”, all channel names are shown.
If “auto”, is set to False if <cite>picks</cite> is <code class="docutils literal notranslate"><span class="pre">None</span></code>; to <code class="docutils literal notranslate"><span class="pre">True</span></code> if
<cite>picks</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code> and fewer than 25 picks are shown; to “all”
if <cite>picks</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code> and contains fewer than 25 entries.</p>
</dd>
<dt><strong>group_by</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | dict</span></dt>
<dd><p class="first">If a dict, the values must be picks, and <cite>axes</cite> must also be a dict
with matching keys, or None. If <cite>axes</cite> is None, one figure and one axis
will be created for each entry in <cite>group_by</cite>.
Then, for each entry, the picked channels will be plotted
to the corresponding axis. If <cite>titles</cite> are None, keys will become plot
titles. This is useful for e.g. ROIs. Each entry must contain only
one channel type. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">group_by</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">Left_ROI</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">Right_ROI</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
</pre></div>
</div>
<p class="last">If None, all picked channels are plotted to the same axis.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib.figure.Figure</span></dt>
<dd><p class="first last">Figure containing the images.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_joint">
<code class="descname">plot_joint</code><span class="sig-paren">(</span><em>times='peaks'</em>, <em>title=''</em>, <em>picks=None</em>, <em>exclude='bads'</em>, <em>show=True</em>, <em>ts_args=None</em>, <em>topomap_args=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L376-L382"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot evoked data as butterfly plot and add topomaps for time points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | array of floats | “auto” | “peaks”</span></dt>
<dd><p class="first last">The time point(s) to plot. If “auto”, 5 evenly spaced topographies
between the first and last time instant will be shown. If “peaks”,
finds time points automatically by checking for 3 local maxima in
Global Field Power. Defaults to “peaks”.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">The title. If <cite>None</cite>, suppress printing channel type. If an empty
string, a default title is created. Defaults to ‘’.</p>
</dd>
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">The indices of channels to plot. If None show all. Defaults to None.</p>
</dd>
<dt><strong>exclude</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | list of str | ‘bads’</span></dt>
<dd><p class="first last">Channels names to exclude from being shown. If ‘bads’, the
bad channels are excluded. Defaults to None.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True. Defaults to True.</p>
</dd>
<dt><strong>ts_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | dict</span></dt>
<dd><p class="first last">A dict of <cite>kwargs</cite> that are forwarded to <a class="reference internal" href="#mne.Evoked.plot" title="mne.Evoked.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Evoked.plot()</span></code></a> to
style the butterfly plot. If they are not in this dict, the following
defaults are passed: <code class="docutils literal notranslate"><span class="pre">spatial_colors=True</span></code>, <code class="docutils literal notranslate"><span class="pre">zorder='std'</span></code>.
<code class="docutils literal notranslate"><span class="pre">show</span></code> and <code class="docutils literal notranslate"><span class="pre">exclude</span></code> are illegal.
If None, no customizable arguments will be passed.
Defaults to <cite>None</cite>.</p>
</dd>
<dt><strong>topomap_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | dict</span></dt>
<dd><p class="first last">A dict of <cite>kwargs</cite> that are forwarded to
<a class="reference internal" href="#mne.Evoked.plot_topomap" title="mne.Evoked.plot_topomap"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mne.Evoked.plot_topomap()</span></code></a> to style the topomaps.
If it is not in this dict, <code class="docutils literal notranslate"><span class="pre">outlines='skirt'</span></code>
will be passed. <cite>show</cite>, <cite>times</cite>, <cite>colorbar</cite> are illegal`
If None, no customizable arguments will be passed.
Defaults to <cite>None</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib.figure.Figure | list</span></dt>
<dd><p class="first last">The figure object containing the plot. If <cite>evoked</cite> has multiple
channel types, a list of figures, one for each channel type, is
returned.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_projs_topomap">
<code class="descname">plot_projs_topomap</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>layout=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/proj.py#L286-L331"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None | List</span></dt>
<dd><p class="first last">The channel type to plot. For ‘grad’, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | Layout | List of Layouts</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axes | list | None</span></dt>
<dd><p class="first last">The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of projectors. If instance of Axes,
there must be only one projector. Defaults to None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">Figure distributing one image per channel across sensor topography.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_sensors">
<code class="descname">plot_sensors</code><span class="sig-paren">(</span><em>kind='topomap'</em>, <em>ch_type=None</em>, <em>title=None</em>, <em>show_names=False</em>, <em>ch_groups=None</em>, <em>to_sphere=True</em>, <em>axes=None</em>, <em>block=False</em>, <em>show=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L503-L581"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_sensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sensor positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Whether to plot the sensors as 3d, topomap or as an interactive
sensor selection dialog. Available options ‘topomap’, ‘3d’,
‘select’. If ‘select’, a set of channels can be selected
interactively by using lasso selector or clicking while holding
control key. The selected channels are returned along with the
figure instance. Defaults to ‘topomap’.</p>
</dd>
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | str</span></dt>
<dd><p class="first last">The channel type to plot. Available options ‘mag’, ‘grad’, ‘eeg’,
‘seeg’, ‘ecog’, ‘all’. If <code class="docutils literal notranslate"><span class="pre">'all'</span></code>, all the available mag, grad,
eeg, seeg and ecog channels are plotted. If None (default), then
channels are chosen in the order given above.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Title for the figure. If None (default), equals to <code class="docutils literal notranslate"><span class="pre">'Sensor</span>
<span class="pre">positions</span> <span class="pre">(%s)'</span> <span class="pre">%</span> <span class="pre">ch_type</span></code>.</p>
</dd>
<dt><strong>show_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | array of str</span></dt>
<dd><p class="first last">Whether to display all channel names. If an array, only the channel
names in the array are shown. Defaults to False.</p>
</dd>
<dt><strong>ch_groups</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘position’ | array of shape (ch_groups, picks) | None</span></dt>
<dd><p class="first">Channel groups for coloring the sensors. If None (default), default
coloring scheme is used. If ‘position’, the sensors are divided
into 8 regions. See <code class="docutils literal notranslate"><span class="pre">order</span></code> kwarg of <a class="reference internal" href="mne.viz.plot_raw.html#mne.viz.plot_raw" title="mne.viz.plot_raw"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_raw()</span></code></a>. If
array, the channels are divided by picks given in the array.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>to_sphere</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Whether to project the 3d locations to a sphere. When False, the
sensor array appears similar as to looking downwards straight above
the subject’s head. Has no effect when kind=‘3d’. Defaults to True.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.14.0.</span></p>
</div>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axes | instance of Axes3D | None</span></dt>
<dd><p class="first">Axes to draw the sensors to. If <code class="docutils literal notranslate"><span class="pre">kind='3d'</span></code>, axes must be an
instance of Axes3D. If None (default), a new axes will be created.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>block</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first">Whether to halt program execution until the figure is closed.
Defaults to False.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True. Defaults to True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib figure</span></dt>
<dd><p class="first last">Figure containing the sensor topography.</p>
</dd>
<dt><strong>selection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of selected channels. Only returned if <code class="docutils literal notranslate"><span class="pre">kind=='select'</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.viz.plot_layout.html#mne.viz.plot_layout" title="mne.viz.plot_layout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.viz.plot_layout</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function plots the sensor locations from the info structure using
matplotlib. For drawing the sensors using mayavi see
<a class="reference internal" href="mne.viz.plot_alignment.html#mne.viz.plot_alignment" title="mne.viz.plot_alignment"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.viz.plot_alignment()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_topo">
<code class="descname">plot_topo</code><span class="sig-paren">(</span><em>layout=None, layout_scale=0.945, color=None, border='none', ylim=None, scalings=None, title=None, proj=False, vline=[0.0], fig_background=None, merge_grads=False, legend=True, axes=None, background_color='w', noise_cov=None, show=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L323-L340"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_topo" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot 2D topography of evoked responses.</p>
<p>Clicking on the plot of an individual sensor opens a new figure showing
the evoked response for the selected sensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Layout | None</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout is
inferred from the data.</p>
</dd>
<dt><strong>layout_scale: float</strong></dt>
<dd><p class="first last">Scaling factor for adjusting the relative size of the layout
on the canvas</p>
</dd>
<dt><strong>color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of color objects | color object | None</span></dt>
<dd><p class="first last">Everything matplotlib accepts to specify colors. If not list-like,
the color specified will be repeated. If None, colors are
automatically drawn.</p>
</dd>
<dt><strong>border</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">matplotlib borders style to be used for each sensor plot.</p>
</dd>
<dt><strong>ylim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">ylim for plots (after scaling has been applied). The value
determines the upper and lower subplot limits. e.g.
ylim = dict(eeg=[-20, 20]). Valid keys are eeg, mag, grad, misc.
If None, the ylim parameter for each channel is determined by
the maximum absolute peak.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">The scalings of the channel types to be applied for plotting. If None,`
defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Title of the figure.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | ‘interactive’</span></dt>
<dd><p class="first last">If true SSP projections are applied before display. If ‘interactive’,
a check box for reversible selection of SSP projection vectors will
be shown.</p>
</dd>
<dt><strong>vline</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of floats | None</span></dt>
<dd><p class="first last">The values at which to show a vertical line.</p>
</dd>
<dt><strong>fig_background</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | numpy ndarray</span></dt>
<dd><p class="first last">A background image for the figure. This must work with a call to
plt.imshow. Defaults to None.</p>
</dd>
<dt><strong>merge_grads</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to use RMS value of gradiometer pairs. Only works for Neuromag
data. Defaults to False.</p>
</dd>
<dt><strong>legend</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | int | string | tuple</span></dt>
<dd><p class="first last">If True, create a legend based on evoked.comment. If False, disable the
legend. Otherwise, the legend is created and the parameter value is
passed as the location parameter to the matplotlib legend call. It can
be an integer (e.g. 0 corresponds to upper right corner of the plot),
a string (e.g. ‘upper right’), or a tuple (x, y coordinates of the
lower left corner of the legend in the axes coordinate system).
See matplotlib documentation for more details.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib Axes | None</span></dt>
<dd><p class="first last">Axes to plot into. If None, axes will be created.</p>
</dd>
<dt><strong>background_color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | obj</span></dt>
<dd><p class="first">Background color. Typically ‘k’ (black) or ‘w’ (white; default).</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.15.0.</span></p>
</div>
</dd>
<dt><strong>noise_cov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Covariance | str | None</span></dt>
<dd><p class="first">Noise covariance used to whiten the data while plotting.
Whitened data channel names are shown in italic.
Can be a string to load a covariance from disk.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib.figure.Figure</span></dt>
<dd><p class="first last">Images of evoked responses at sensor locations</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_topomap">
<code class="descname">plot_topomap</code><span class="sig-paren">(</span><em>times='auto'</em>, <em>ch_type=None</em>, <em>layout=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>cmap=None</em>, <em>sensors=True</em>, <em>colorbar=True</em>, <em>scalings=None</em>, <em>units=None</em>, <em>res=64</em>, <em>size=1</em>, <em>cbar_fmt='%3.1f'</em>, <em>time_unit='s'</em>, <em>time_format=None</em>, <em>proj=False</em>, <em>show=True</em>, <em>show_names=False</em>, <em>title=None</em>, <em>mask=None</em>, <em>mask_params=None</em>, <em>outlines='head'</em>, <em>contours=6</em>, <em>image_interp='bilinear'</em>, <em>average=None</em>, <em>head_pos=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L342-L361"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot topographic maps of specific time points of evoked data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | array of floats | “auto” | “peaks” | “interactive”</span></dt>
<dd><p class="first last">The time point(s) to plot. If “auto”, the number of <code class="docutils literal notranslate"><span class="pre">axes</span></code> determines
the amount of time point(s). If <code class="docutils literal notranslate"><span class="pre">axes</span></code> is also None, at most 10
topographies will be shown with a regular time spacing between the
first and last time instant. If “peaks”, finds time points
automatically by checking for local maxima in global field power. If
“interactive”, the time can be set interactively at run-time by using a
slider.</p>
</dd>
<dt><strong>ch_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None</span></dt>
<dd><p class="first last">The channel type to plot. For ‘grad’, the gradiometers are collected in
pairs and the RMS for each pair is plotted.
If None, then channels are chosen in the order given above.</p>
</dd>
<dt><strong>layout</strong> <span class="classifier-delimiter">:</span> <span class="classifier">None | Layout</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout file
is inferred from the data; if no appropriate layout file was found, the
layout is automatically generated from the sensor locations.</p>
</dd>
<dt><strong>vmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | callable | None</span></dt>
<dd><p class="first last">The value specifying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data). Defaults to None.</p>
</dd>
<dt><strong>vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | callable | None</span></dt>
<dd><p class="first last">The value specifying the upper bound of the color range.
If None, the maximum absolute value is used. If callable, the output
equals vmax(data). Defaults to None.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’ | None</span></dt>
<dd><p class="first">Colormap to use. If tuple, the first value indicates the colormap to
use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging the
colorbar with left and right mouse button. Left mouse button moves the
scale up and down and right mouse button adjusts the range (zoom).
The mouse scroll can also be used to adjust the range. Hitting space
bar resets the range. Up and down arrows can be used to change the
colormap. If None (default), ‘Reds’ is used for all positive data,
otherwise defaults to ‘RdBu_r’. If ‘interactive’, translates to
(None, True).</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Interactive mode works smoothly only for a small amount
of topomaps. Interactive mode is disabled by default for more than
2 topomaps.</p>
</div>
</dd>
<dt><strong>sensors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Add markers for sensor locations to the plot. Accepts matplotlib plot
format string (e.g., ‘r+’ for red plusses). If True (default),
circles will be used.</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | None</span></dt>
<dd><p class="first last">Plot a colorbar in the rightmost column of the figure.
None (default) is the same as True, but emits a warning if custom
<code class="docutils literal notranslate"><span class="pre">axes</span></code> are provided to remind the user that the colorbar will
occupy the last <a class="reference external" href="https://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v3.0.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.axes.Axes</span></code></a> instance.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | float | None</span></dt>
<dd><p class="first last">The scalings of the channel types to be applied for plotting.
If None, defaults to <code class="docutils literal notranslate"><span class="pre">dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15)</span></code>.</p>
</dd>
<dt><strong>units</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | str | None</span></dt>
<dd><p class="first last">The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</dd>
<dt><strong>res</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The resolution of the topomap image (n pixels along each side).</p>
</dd>
<dt><strong>size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Side length per topomap in inches.</p>
</dd>
<dt><strong>cbar_fmt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">String format for colorbar values.</p>
</dd>
<dt><strong>time_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The units for the time axis, can be “ms” or “s” (default).</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
<dt><strong>time_format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">String format for topomap values. Defaults (None) to “%01d ms” if
<code class="docutils literal notranslate"><span class="pre">time_unit='ms'</span></code>, “%0.3f s” if <code class="docutils literal notranslate"><span class="pre">time_unit='s'</span></code>, and
“%g” otherwise.</p>
</dd>
<dt><strong>proj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | ‘interactive’</span></dt>
<dd><p class="first last">If true SSP projections are applied before display. If ‘interactive’,
a check box for reversible selection of SSP projection vectors will
be show.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt><strong>show_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool | callable</span></dt>
<dd><p class="first last">If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g., to
delete the prefix ‘MEG ‘ from all channel names, pass the function
lambda x: x.replace(‘MEG ‘, ‘’). If <cite>mask</cite> is not None, only
significant sensors will be shown.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Title. If None (default), no title is displayed.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of bool, shape (n_channels, n_times) | None</span></dt>
<dd><p class="first last">The channels to be marked as significant at a given time point.
Indices set to <cite>True</cite> will be considered. Defaults to None.</p>
</dd>
<dt><strong>mask_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first">Additional plotting parameters for plotting significant sensors.
Default (None) equals:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt><strong>outlines</strong> <span class="classifier-delimiter">:</span> <span class="classifier">‘head’ | ‘skirt’ | dict | None</span></dt>
<dd><p class="first last">The outlines to be drawn. If ‘head’, the default head scheme will be
drawn. If ‘skirt’ the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in ‘mask_pos’ will
serve as image mask, and the ‘autoshrink’ (bool) field will trigger
automated shrinking of the positions due to points outside the outline.
Alternatively, a matplotlib patch object can be passed for advanced
masking options, either directly or as a function that returns patches
(required for multi-axis plots). If None, nothing will be drawn.
Defaults to ‘head’.</p>
</dd>
<dt><strong>contours</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | array of float</span></dt>
<dd><p class="first last">The number of contour lines to draw. If 0, no contours will be drawn.
When an integer, matplotlib ticker locator is used to find suitable
values for the contour thresholds (may sometimes be inaccurate, use
array for accuracy). If an array, the values represent the levels for
the contours. The values are in uV for EEG, fT for magnetometers and
fT/m for gradiometers. If colorbar=True, the ticks in colorbar
correspond to the contour levels. Defaults to 6.</p>
</dd>
<dt><strong>image_interp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The image interpolation to be used. All matplotlib options are
accepted.</p>
</dd>
<dt><strong>average</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The time window around a given time to be used for averaging (seconds).
For example, 0.01 would translate into window that starts 5 ms before
and ends 5 ms after a given time point. Defaults to None, which means
no averaging.</p>
</dd>
<dt><strong>head_pos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries ‘center’ (tuple) and
‘scale’ (tuple) for what the center and scale of the head should be
relative to the electrode locations.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Axes | list | None</span></dt>
<dd><p class="first last">The axes to plot to. If list, the list must be a list of Axes of the
same length as <code class="docutils literal notranslate"><span class="pre">times</span></code> (unless <code class="docutils literal notranslate"><span class="pre">times</span></code> is None). If instance of
Axes, <code class="docutils literal notranslate"><span class="pre">times</span></code> must be a float or a list of one float.
Defaults to None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.plot_white">
<code class="descname">plot_white</code><span class="sig-paren">(</span><em>noise_cov</em>, <em>show=True</em>, <em>rank=None</em>, <em>time_unit='s'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L369-L374"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.plot_white" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot whitened evoked response.</p>
<p>Plots the whitened evoked response and the whitened GFP as described in
<a class="reference internal" href="#r784e39fd1473-1" id="id1">[1]</a>. This function is especially useful for investigating noise
covariance properties to determine if data are properly whitened (e.g.,
achieving expected values in line with model assumptions, see Notes below).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>noise_cov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list | instance of Covariance | str</span></dt>
<dd><p class="first last">The noise covariance. Can be a string to load a covariance from disk.</p>
</dd>
<dt><strong>show</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt><strong>rank</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict of int | None</span></dt>
<dd><p class="first last">Dict of ints where keys are ‘eeg’, ‘meg’, mag’ or ‘grad’. If None,
the rank is detected automatically. Defaults to None. ‘mag’ or
‘grad’ cannot be specified jointly with ‘meg’. For SSS’d data,
only ‘meg’ is valid. For non-SSS’d data, ‘mag’ and/or ‘grad’ must be
specified separately. If only one is specified, the other one gets
estimated. Note. The rank estimation will be printed by the logger for
each noise covariance estimator that is passed.</p>
</dd>
<dt><strong>time_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The units for the time axis, can be “ms” or “s” (default).</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.16.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see <a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a>
and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of matplotlib.figure.Figure</span></dt>
<dd><p class="first last">The figure object containing the plot.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.Evoked.plot" title="mne.Evoked.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.Evoked.plot</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>If baseline signals match the assumption of Gaussian white noise,
values should be centered at 0, and be within 2 standard deviations
(±1.96) for 95% of the time points. For the global field power (GFP),
we expect it to fluctuate around a value of 1.</p>
<p>If one single covariance object is passed, the GFP panel (bottom)
will depict different sensor types. If multiple covariance objects are
passed as a list, the left column will display the whitened evoked
responses for each channel based on the whitener from the noise covariance
that has the highest log-likelihood. The left column will depict the
whitened GFPs based on each estimator separately for each sensor type.
Instead of numbers of channels the GFP display shows the estimated rank.
Note. The rank estimation will be printed by the logger
(if <code class="docutils literal notranslate"><span class="pre">verbose=True</span></code>) for each noise covariance estimator that is passed.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r784e39fd1473-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Engemann D. and Gramfort A. (2015) Automated model selection in
covariance estimation and spatial whitening of MEG and EEG
signals, vol. 108, 328-342, NeuroImage.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="mne.Evoked.proj">
<code class="descname">proj</code><a class="headerlink" href="#mne.Evoked.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether or not projections are active.</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.rename_channels">
<code class="descname">rename_channels</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L459-L473"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | callable</span></dt>
<dd><p class="first last">a dictionary mapping the old channel to a new channel name
e.g. {‘EEG061’ : ‘EEG161’}. Can also be a callable function
that takes and returns a string (new in version 0.10.0).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.reorder_channels">
<code class="descname">reorder_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L722-L755"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.reorder_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ch_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The desired channel order.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw, Epochs, or Evoked</span></dt>
<dd><p class="first last">The modified instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.Evoked.drop_channels" title="mne.Evoked.drop_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_channels</span></code></a>, <a class="reference internal" href="mne.pick_types.html#mne.pick_types" title="mne.pick_types"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_types</span></code></a>, <a class="reference internal" href="mne.pick_channels.html#mne.pick_channels" title="mne.pick_channels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>Channel names must be unique. Channels that are not in <code class="docutils literal notranslate"><span class="pre">ch_names</span></code>
are dropped.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.16.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>sfreq</em>, <em>npad='auto'</em>, <em>window='boxcar'</em>, <em>n_jobs=1</em>, <em>pad='edge'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/filter.py#L2049-L2112"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Data must be loaded.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sfreq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">New sample rate to use</p>
</dd>
<dt><strong>npad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | str</span></dt>
<dd><p class="first last">Amount to pad the start and end of the data.
Can also be “auto” to use a padding that will result in
a power-of-two size (can be much faster).</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or tuple</span></dt>
<dd><p class="first last">Window to use in resampling. See <a class="reference external" href="https://scipy.github.io/devdocs/generated/scipy.signal.resample.html#scipy.signal.resample" title="(in SciPy v1.3.0.dev0+446cf44)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.resample()</span></code></a>.</p>
</dd>
<dt><strong>n_jobs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of jobs to run in parallel.</p>
</dd>
<dt><strong>pad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first">The type of padding to use. Supports all <a class="reference external" href="https://www.numpy.org/devdocs/reference/generated/numpy.pad.html#numpy.pad" title="(in NumPy v1.17.dev0)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.pad()</span></code></a> <code class="docutils literal notranslate"><span class="pre">mode</span></code>
options. Can also be “reflect_limited”, which pads with a
reflected version of each vector mirrored on the first and last
values of the vector, followed by zeros. The default is “edge”,
which pads with the edge values of each vector.</p>
<div class="last versionadded">
<p><span class="versionmodified">New in version 0.15.</span></p>
</div>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a> for
more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs | instance of Evoked</span></dt>
<dd><p class="first last">The resampled epochs object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.resample" title="mne.io.Raw.resample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.io.Raw.resample</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use npad=0 to reduce
artifacts. This is dataset dependent – check your data!</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L167-L181"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save dataset to file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the file, which should end with -ave.fif or
-ave.fif.gz.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>To write multiple conditions into a single file, use
<a class="reference internal" href="mne.write_evokeds.html#mne.write_evokeds" title="mne.write_evokeds"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.write_evokeds()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.savgol_filter">
<code class="descname">savgol_filter</code><span class="sig-paren">(</span><em>h_freq</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/filter.py#L1854-L1918"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.savgol_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the data using Savitzky-Golay polynomial method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>h_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Approximate high cut-off frequency in Hz. Note that this
is not an exact cutoff, since Savitzky-Golay filtering <a class="reference internal" href="#r057a06512d87-1" id="id3">[1]</a> is
done using polynomial fits instead of FIR/IIR filtering.
This parameter is thus used to determine the length of the
window over which a 5th-order polynomial smoothing is used.</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more). Defaults to self.verbose.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Epochs or Evoked</span></dt>
<dd><p class="first last">The object with the filtering applied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.io.Raw.filter</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For Savitzky-Golay low-pass approximation, see:</p>
<blockquote>
<div><a class="reference external" href="https://gist.github.com/Eric89GXL/bbac101d50176611136b">https://gist.github.com/Eric89GXL/bbac101d50176611136b</a></div></blockquote>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r057a06512d87-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> Savitzky, A., Golay, M.J.E. (1964). “Smoothing and
Differentiation of Data by Simplified Least Squares
Procedures”. Analytical Chemistry 36 (8): 1627-39.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mne</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">path</span> <span class="k">as</span> <span class="n">op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked_fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mne</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">data_path</span><span class="p">(),</span> <span class="s1">&#39;MEG&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;sample_audvis-ave.fif&#39;</span><span class="p">)</span>  <span class="c1"># doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_evokeds</span><span class="p">(</span><span class="n">evoked_fname</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>  <span class="c1"># low-pass at around 10 Hz # doctest:+SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>  <span class="c1"># doctest:+SKIP</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.set_channel_types">
<code class="descname">set_channel_types</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L399-L457"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog,
hbo, hbr</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>mapping</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">a dictionary mapping a channel to a sensor type (str)
{‘EEG061’: ‘eog’}.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.set_eeg_reference">
<code class="descname">set_eeg_reference</code><span class="sig-paren">(</span><em>ref_channels='average'</em>, <em>projection=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L252-L343"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.set_eeg_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify which reference to use for EEG data.</p>
<p>By default, MNE-Python will automatically re-reference the EEG signal
to use an average reference (see below). Use this function to
explicitly specify the desired reference for EEG. This can be either an
existing electrode or a new virtual channel. This function will
re-reference the data according to the desired reference and prevent
MNE-Python from automatically adding an average reference projection.</p>
<p>Some common referencing schemes and the corresponding value for the
<code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> parameter:</p>
<dl class="docutils">
<dt>No re-referencing:</dt>
<dd>If the EEG data is already using the proper reference, set
<code class="docutils literal notranslate"><span class="pre">ref_channels=[]</span></code>. This will prevent MNE-Python from
automatically adding an average reference projection.</dd>
<dt>Average reference:</dt>
<dd>A new virtual reference electrode is created by averaging the
current EEG signal by setting <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code>. Bad EEG
channels are automatically excluded if they are properly set in
<code class="docutils literal notranslate"><span class="pre">info['bads']</span></code>.</dd>
<dt>A single electrode:</dt>
<dd>Set <code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> to a list containing the name of the channel
that will act as the new reference, for example
<code class="docutils literal notranslate"><span class="pre">ref_channels=['Cz']</span></code>.</dd>
<dt>The mean of multiple electrodes:</dt>
<dd>A new virtual reference electrode is created by computing the
average of the current EEG signal recorded from two or more
selected channels. Set <code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> to a list of channel names,
indicating which channels to use. For example, to apply an average
mastoid reference, when using the 10-20 naming scheme, set
<code class="docutils literal notranslate"><span class="pre">ref_channels=['M1',</span> <span class="pre">'M2']</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ref_channels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str | str</span></dt>
<dd><p class="first last">The name(s) of the channel(s) used to construct the reference. To
apply an average reference, specify <code class="docutils literal notranslate"><span class="pre">'average'</span></code> here (default).
If an empty list is specified, the data is assumed to already have
a proper reference and MNE will not attempt any re-referencing of
the data. Defaults to an average reference.</p>
</dd>
<dt><strong>projection</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code> this argument specifies if the
average reference should be computed as a projection (True) or not
(False; default). If <code class="docutils literal notranslate"><span class="pre">projection=True</span></code>, the average reference is
added as a projection and is not applied to the data (it can be
applied afterwards with the <code class="docutils literal notranslate"><span class="pre">apply_proj</span></code> method). If
<code class="docutils literal notranslate"><span class="pre">projection=False</span></code>, the average reference is directly applied to
the data. If <code class="docutils literal notranslate"><span class="pre">ref_channels</span></code> is not <code class="docutils literal notranslate"><span class="pre">'average'</span></code>, <code class="docutils literal notranslate"><span class="pre">projection</span></code>
must be set to <code class="docutils literal notranslate"><span class="pre">False</span></code> (the default in this case).</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>inst</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Raw | Epochs | Evoked</span></dt>
<dd><p class="first last">Data with EEG channels re-referenced. If <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code>
and <code class="docutils literal notranslate"><span class="pre">projection=True</span></code> a projection will be added instead of
directly re-referencing the data.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="mne.set_bipolar_reference.html#mne.set_bipolar_reference" title="mne.set_bipolar_reference"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mne.set_bipolar_reference</span></code></a></dt>
<dd>Convenience function for creating bipolar references.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>If a reference is requested that is not the average reference, this
function removes any pre-existing average reference projections.</li>
<li>During source localization, the EEG signal should have an average
reference.</li>
<li>In order to apply a reference, the data must be preloaded. This is
not necessary if <code class="docutils literal notranslate"><span class="pre">ref_channels='average'</span></code> and <code class="docutils literal notranslate"><span class="pre">projection=True</span></code>.</li>
<li>For an average reference, bad EEG channels are automatically
excluded if they are properly set in <code class="docutils literal notranslate"><span class="pre">info['bads']</span></code>.</li>
</ol>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.set_montage">
<code class="descname">set_montage</code><span class="sig-paren">(</span><em>montage</em>, <em>set_dig=True</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/channels/channels.py#L475-L501"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration and head digitization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>montage</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of Montage | instance of DigMontage | str | None</span></dt>
<dd><p class="first last">The montage to use (None removes any location information).</p>
</dd>
<dt><strong>set_dig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, update the digitization information (<code class="docutils literal notranslate"><span class="pre">info['dig']</span></code>)
in addition to the channel positions (<code class="docutils literal notranslate"><span class="pre">info['chs'][idx]['loc']</span></code>).</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, str, int, or None</span></dt>
<dd><p class="first last">If not None, override default verbose level (see
<a class="reference internal" href="mne.verbose.html#mne.verbose" title="mne.verbose"><code class="xref py py-func docutils literal notranslate"><span class="pre">mne.verbose()</span></code></a> and <a class="reference internal" href="../auto_tutorials/plot_configuration.html#tut-logging"><span class="std std-ref">Logging documentation</span></a>
for more).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.shift_time">
<code class="descname">shift_time</code><span class="sig-paren">(</span><em>tshift</em>, <em>relative=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/evoked.py#L267-L293"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.shift_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift time scale in evoked data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tshift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The amount of time shift to be applied if relative is True
else the first time point. When relative is True, positive value
of tshift moves the data forward while negative tshift moves it
backward.</p>
</dd>
<dt><strong>relative</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, move the time backwards or forwards by specified amount.
Else, set the starting time point to the value of tshift.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Maximum accuracy of time shift is 1 / evoked.info[‘sfreq’]</p>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.time_as_index">
<code class="descname">time_as_index</code><span class="sig-paren">(</span><em>times</em>, <em>use_rounding=False</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/base.py#L214-L238"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list-like | float | int</span></dt>
<dd><p class="first last">List of numbers or a number representing points in time.</p>
</dd>
<dt><strong>use_rounding</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Indices corresponding to the times supplied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.Evoked.to_data_frame">
<code class="descname">to_data_frame</code><span class="sig-paren">(</span><em>picks=None</em>, <em>index=None</em>, <em>scaling_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.17/mne/io/base.py#L66-L208"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.Evoked.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>picks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array-like of int | None</span></dt>
<dd><p class="first last">If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple of str | None</span></dt>
<dd><p class="first last">Column to be used as index for the data. Valid string options
are ‘epoch’, ‘time’ and ‘condition’. If None, all three info
columns will be included in the table as categorial data.</p>
</dd>
<dt><strong>scaling_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling to be applied to time units.</p>
</dd>
<dt><strong>scalings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">Scaling to be applied to the channels picked. If None, defaults to
<code class="docutils literal notranslate"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></code>.</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, data will be copied. Else data may be modified in place.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</dd>
<dt><strong>stop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int | None</span></dt>
<dd><p class="first last">If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance of pandas.core.DataFrame</span></dt>
<dd><p class="first last">A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><img src="../_static/institutions.png" alt="Institutions"></div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2019, MNE Developers. Last updated on 2019-02-22.</p>
  </div>
</footer>
<script src="https://mne.tools/versionwarning.js"></script>
  </body>
</html>