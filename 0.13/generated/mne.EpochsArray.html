<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.EpochsArray &#8212; MNE 0.13.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.6/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.13.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="MNE 0.13.1 documentation" href="../index.html" />
    <link rel="up" title="Python API Reference" href="../python_reference.html" />
    <link rel="next" title="mne.create_info" href="mne.create_info.html" />
    <link rel="prev" title="mne.EvokedArray" href="mne.EvokedArray.html" />

<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="http://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  <link rel="canonical" href="https://mne.tools/stable/index.html" />
</head>
  <body role="document">





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.13.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get started</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Gallery</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../auto_examples/index.html">Examples Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contribute to MNE</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../python_reference.html">Python API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/index.html">User Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whats_new.html">What&#8217;s new</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../cite.html">How to cite MNE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../references.html">Related publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cited.html">Publications from MNE users</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">mne.EpochsArray</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.EpochsArray</a></li>
</ul>

  <li>
    <a href="mne.EvokedArray.html" title="Previous Chapter: mne.EvokedArray"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; mne.EvokedArray</span>
    </a>
  </li>
  <li>
    <a href="mne.create_info.html" title="Next Chapter: mne.create_info"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">mne.create_info &raquo;</span>
    </a>
  </li>
<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="mne-epochsarray">
<h1>mne.EpochsArray<a class="headerlink" href="#mne-epochsarray" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.EpochsArray">
<em class="property">class </em><code class="descclassname">mne.</code><code class="descname">EpochsArray</code><span class="sig-paren">(</span><em>data</em>, <em>info</em>, <em>events=None</em>, <em>tmin=0</em>, <em>event_id=None</em>, <em>reject=None</em>, <em>flat=None</em>, <em>reject_tmin=None</em>, <em>reject_tmax=None</em>, <em>baseline=None</em>, <em>proj=True</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Epochs object from numpy array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array, shape (n_epochs, n_channels, n_times)</p>
<blockquote>
<div><p>The channels&#8217; time series for each epoch.</p>
</div></blockquote>
<p><strong>info</strong> : instance of Info</p>
<blockquote>
<div><p>Info dictionary. Consider using <code class="docutils literal"><span class="pre">create_info</span></code> to populate
this structure.</p>
</div></blockquote>
<p><strong>events</strong> : None | array of int, shape (n_events, 3)</p>
<blockquote>
<div><p>The events typically returned by the read_events function.
If some events don&#8217;t match the events of interest as specified
by event_id, they will be marked as &#8216;IGNORED&#8217; in the drop log.
If None (default), all event values are set to 1 and event time-samples
are set to range(n_epochs).</p>
</div></blockquote>
<p><strong>tmin</strong> : float</p>
<blockquote>
<div><p>Start time before event. If nothing provided, defaults to -0.2.</p>
</div></blockquote>
<p><strong>event_id</strong> : int | list of int | dict | None</p>
<blockquote>
<div><p>The id of the event to consider. If dict,
the keys can later be used to access associated events. Example:
dict(auditory=1, visual=3). If int, a dict will be created with
the id as string. If a list, all events with the IDs specified
in the list are used. If None, all events will be used with
and a dict is created with string integer names corresponding
to the event id integers.</p>
</div></blockquote>
<p><strong>reject</strong> : dict | None</p>
<blockquote>
<div><p>Rejection parameters based on peak-to-peak amplitude.
Valid keys are &#8216;grad&#8217; | &#8216;mag&#8217; | &#8216;eeg&#8217; | &#8216;eog&#8217; | &#8216;ecg&#8217;.
If reject is None then no rejection is done. Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">reject</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">grad</span><span class="o">=</span><span class="mi">4000</span><span class="n">e</span><span class="o">-</span><span class="mi">13</span><span class="p">,</span> <span class="c1"># T / m (gradiometers)</span>
              <span class="n">mag</span><span class="o">=</span><span class="mi">4</span><span class="n">e</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="c1"># T (magnetometers)</span>
              <span class="n">eeg</span><span class="o">=</span><span class="mi">40</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="c1"># V (EEG channels)</span>
              <span class="n">eog</span><span class="o">=</span><span class="mi">250</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span> <span class="c1"># V (EOG channels)</span>
              <span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>flat</strong> : dict | None</p>
<blockquote>
<div><p>Rejection parameters based on flatness of signal.
Valid keys are &#8216;grad&#8217; | &#8216;mag&#8217; | &#8216;eeg&#8217; | &#8216;eog&#8217; | &#8216;ecg&#8217;, and values
are floats that set the minimum acceptable peak-to-peak amplitude.
If flat is None then no rejection is done.</p>
</div></blockquote>
<p><strong>reject_tmin</strong> : scalar | None</p>
<blockquote>
<div><p>Start of the time window used to reject epochs (with the default None,
the window will start with tmin).</p>
</div></blockquote>
<p><strong>reject_tmax</strong> : scalar | None</p>
<blockquote>
<div><p>End of the time window used to reject epochs (with the default None,
the window will end with tmax).</p>
</div></blockquote>
<p><strong>baseline</strong> : None or tuple of length 2 (default None)</p>
<blockquote>
<div><p>The time interval to apply baseline correction. If None do not apply
it. If baseline is (a, b) the interval is between &#8220;a (s)&#8221; and &#8220;b (s)&#8221;.
If a is None the beginning of the data is used and if b is None then b
is set to the end of the interval. If baseline is equal to (None, None)
all the time interval is used. Correction is applied by computing mean
of the baseline period and subtracting it from the data. The baseline
(a, b) includes both endpoints, i.e. all timepoints t such that
a &lt;= t &lt;= b.</p>
</div></blockquote>
<p><strong>proj</strong> : bool | &#8216;delayed&#8217;</p>
<blockquote>
<div><p>Apply SSP projection vectors. See <a class="reference internal" href="mne.Epochs.html#mne.Epochs" title="mne.Epochs"><code class="xref py py-class docutils literal"><span class="pre">mne.Epochs</span></code></a> for details.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to raw.verbose.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.RawArray.html#mne.io.RawArray" title="mne.io.RawArray"><code class="xref py py-obj docutils literal"><span class="pre">io.RawArray</span></code></a>, <a class="reference internal" href="mne.EvokedArray.html#mne.EvokedArray" title="mne.EvokedArray"><code class="xref py py-obj docutils literal"><span class="pre">EvokedArray</span></code></a>, <a class="reference internal" href="mne.create_info.html#mne.create_info" title="mne.create_info"><code class="xref py py-obj docutils literal"><span class="pre">create_info</span></code></a></p>
</div>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.ch_names" title="mne.EpochsArray.ch_names"><code class="xref py py-obj docutils literal"><span class="pre">ch_names</span></code></a></td>
<td>Channel names</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.compensation_grade" title="mne.EpochsArray.compensation_grade"><code class="xref py py-obj docutils literal"><span class="pre">compensation_grade</span></code></a></td>
<td>The current gradient compensation grade</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">proj</span></code></td>
<td></td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal"><span class="pre">tmax</span></code></td>
<td></td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">tmin</span></code></td>
<td></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.__contains__" title="mne.EpochsArray.__contains__"><code class="xref py py-obj docutils literal"><span class="pre">__contains__</span></code></a>(ch_type)</td>
<td>Check channel type membership</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.__getitem__" title="mne.EpochsArray.__getitem__"><code class="xref py py-obj docutils literal"><span class="pre">__getitem__</span></code></a>(item)</td>
<td>Return an Epochs object with a copied subset of epochs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.__hash__" title="mne.EpochsArray.__hash__"><code class="xref py py-obj docutils literal"><span class="pre">__hash__</span></code></a>()</td>
<td>Hash the object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.__iter__" title="mne.EpochsArray.__iter__"><code class="xref py py-obj docutils literal"><span class="pre">__iter__</span></code></a>()</td>
<td>Function to make iteration over epochs easy</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.__len__" title="mne.EpochsArray.__len__"><code class="xref py py-obj docutils literal"><span class="pre">__len__</span></code></a>()</td>
<td>The number of epochs</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.add_channels" title="mne.EpochsArray.add_channels"><code class="xref py py-obj docutils literal"><span class="pre">add_channels</span></code></a>(add_list[,&nbsp;force_update_info])</td>
<td>Append new channels to the instance.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.add_eeg_average_proj" title="mne.EpochsArray.add_eeg_average_proj"><code class="xref py py-obj docutils literal"><span class="pre">add_eeg_average_proj</span></code></a>(\*args,&nbsp;\*\*kwargs)</td>
<td><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: This function is deprecated and will be removed in 0.14. Use set_eeg_reference() instead.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.add_proj" title="mne.EpochsArray.add_proj"><code class="xref py py-obj docutils literal"><span class="pre">add_proj</span></code></a>(projs[,&nbsp;remove_existing,&nbsp;verbose])</td>
<td>Add SSP projection vectors</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.anonymize" title="mne.EpochsArray.anonymize"><code class="xref py py-obj docutils literal"><span class="pre">anonymize</span></code></a>()</td>
<td>Anonymize measurement information in place.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.apply_baseline" title="mne.EpochsArray.apply_baseline"><code class="xref py py-obj docutils literal"><span class="pre">apply_baseline</span></code></a>([baseline,&nbsp;verbose])</td>
<td>Baseline correct epochs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.apply_proj" title="mne.EpochsArray.apply_proj"><code class="xref py py-obj docutils literal"><span class="pre">apply_proj</span></code></a>()</td>
<td>Apply the signal space projection (SSP) operators to the data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.average" title="mne.EpochsArray.average"><code class="xref py py-obj docutils literal"><span class="pre">average</span></code></a>([picks])</td>
<td>Compute average of epochs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.copy" title="mne.EpochsArray.copy"><code class="xref py py-obj docutils literal"><span class="pre">copy</span></code></a>()</td>
<td>Return copy of Epochs instance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.crop" title="mne.EpochsArray.crop"><code class="xref py py-obj docutils literal"><span class="pre">crop</span></code></a>([tmin,&nbsp;tmax])</td>
<td>Crops a time interval from epochs object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.decimate" title="mne.EpochsArray.decimate"><code class="xref py py-obj docutils literal"><span class="pre">decimate</span></code></a>(decim[,&nbsp;offset])</td>
<td>Decimate the epochs</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.del_proj" title="mne.EpochsArray.del_proj"><code class="xref py py-obj docutils literal"><span class="pre">del_proj</span></code></a>(idx)</td>
<td>Remove SSP projection vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.drop" title="mne.EpochsArray.drop"><code class="xref py py-obj docutils literal"><span class="pre">drop</span></code></a>(indices[,&nbsp;reason,&nbsp;verbose])</td>
<td>Drop epochs based on indices or boolean mask</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.drop_bad" title="mne.EpochsArray.drop_bad"><code class="xref py py-obj docutils literal"><span class="pre">drop_bad</span></code></a>([reject,&nbsp;flat,&nbsp;verbose])</td>
<td>Drop bad epochs without retaining the epochs data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.drop_channels" title="mne.EpochsArray.drop_channels"><code class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></code></a>(ch_names)</td>
<td>Drop some channels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.drop_log_stats" title="mne.EpochsArray.drop_log_stats"><code class="xref py py-obj docutils literal"><span class="pre">drop_log_stats</span></code></a>([ignore])</td>
<td>Compute the channel stats based on a drop_log from Epochs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.equalize_event_counts" title="mne.EpochsArray.equalize_event_counts"><code class="xref py py-obj docutils literal"><span class="pre">equalize_event_counts</span></code></a>(event_ids[,&nbsp;method,&nbsp;copy])</td>
<td>Equalize the number of trials in each condition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.get_data" title="mne.EpochsArray.get_data"><code class="xref py py-obj docutils literal"><span class="pre">get_data</span></code></a>()</td>
<td>Get all epochs as a 3D array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.interpolate_bads" title="mne.EpochsArray.interpolate_bads"><code class="xref py py-obj docutils literal"><span class="pre">interpolate_bads</span></code></a>([reset_bads,&nbsp;mode])</td>
<td>Interpolate bad MEG and EEG channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.iter_evoked" title="mne.EpochsArray.iter_evoked"><code class="xref py py-obj docutils literal"><span class="pre">iter_evoked</span></code></a>()</td>
<td>Iterate over epochs as a sequence of Evoked objects</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.load_data" title="mne.EpochsArray.load_data"><code class="xref py py-obj docutils literal"><span class="pre">load_data</span></code></a>()</td>
<td>Load the data if not already preloaded</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.next" title="mne.EpochsArray.next"><code class="xref py py-obj docutils literal"><span class="pre">next</span></code></a>([return_event_id])</td>
<td>Iterate over epoch data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.pick_channels" title="mne.EpochsArray.pick_channels"><code class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></code></a>(ch_names)</td>
<td>Pick some channels</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.pick_types" title="mne.EpochsArray.pick_types"><code class="xref py py-obj docutils literal"><span class="pre">pick_types</span></code></a>([meg,&nbsp;eeg,&nbsp;stim,&nbsp;eog,&nbsp;ecg,&nbsp;emg,&nbsp;...])</td>
<td>Pick some channels by type and names</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.plot" title="mne.EpochsArray.plot"><code class="xref py py-obj docutils literal"><span class="pre">plot</span></code></a>([picks,&nbsp;scalings,&nbsp;n_epochs,&nbsp;...])</td>
<td>Visualize epochs</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.plot_drop_log" title="mne.EpochsArray.plot_drop_log"><code class="xref py py-obj docutils literal"><span class="pre">plot_drop_log</span></code></a>([threshold,&nbsp;n_max_plot,&nbsp;...])</td>
<td>Show the channel stats based on a drop_log from Epochs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.plot_image" title="mne.EpochsArray.plot_image"><code class="xref py py-obj docutils literal"><span class="pre">plot_image</span></code></a>([picks,&nbsp;sigma,&nbsp;vmin,&nbsp;vmax,&nbsp;...])</td>
<td>Plot Event Related Potential / Fields image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.plot_projs_topomap" title="mne.EpochsArray.plot_projs_topomap"><code class="xref py py-obj docutils literal"><span class="pre">plot_projs_topomap</span></code></a>([ch_type,&nbsp;layout,&nbsp;axes])</td>
<td>Plot SSP vector</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.plot_psd" title="mne.EpochsArray.plot_psd"><code class="xref py py-obj docutils literal"><span class="pre">plot_psd</span></code></a>([fmin,&nbsp;fmax,&nbsp;tmin,&nbsp;tmax,&nbsp;proj,&nbsp;...])</td>
<td>Plot the power spectral density across epochs</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.plot_psd_topomap" title="mne.EpochsArray.plot_psd_topomap"><code class="xref py py-obj docutils literal"><span class="pre">plot_psd_topomap</span></code></a>([bands,&nbsp;vmin,&nbsp;vmax,&nbsp;tmin,&nbsp;...])</td>
<td>Plot the topomap of the power spectral density across epochs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.plot_sensors" title="mne.EpochsArray.plot_sensors"><code class="xref py py-obj docutils literal"><span class="pre">plot_sensors</span></code></a>([kind,&nbsp;ch_type,&nbsp;title,&nbsp;...])</td>
<td>Plot sensors positions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.plot_topo_image" title="mne.EpochsArray.plot_topo_image"><code class="xref py py-obj docutils literal"><span class="pre">plot_topo_image</span></code></a>([layout,&nbsp;sigma,&nbsp;vmin,&nbsp;vmax,&nbsp;...])</td>
<td>Plot Event Related Potential / Fields image on topographies</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.rename_channels" title="mne.EpochsArray.rename_channels"><code class="xref py py-obj docutils literal"><span class="pre">rename_channels</span></code></a>(mapping)</td>
<td>Rename channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.resample" title="mne.EpochsArray.resample"><code class="xref py py-obj docutils literal"><span class="pre">resample</span></code></a>(sfreq[,&nbsp;npad,&nbsp;window,&nbsp;n_jobs,&nbsp;verbose])</td>
<td>Resample preloaded data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.save" title="mne.EpochsArray.save"><code class="xref py py-obj docutils literal"><span class="pre">save</span></code></a>(fname[,&nbsp;split_size])</td>
<td>Save epochs in a fif file</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.savgol_filter" title="mne.EpochsArray.savgol_filter"><code class="xref py py-obj docutils literal"><span class="pre">savgol_filter</span></code></a>(h_freq[,&nbsp;copy])</td>
<td>Filter the data using Savitzky-Golay polynomial method</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.set_channel_types" title="mne.EpochsArray.set_channel_types"><code class="xref py py-obj docutils literal"><span class="pre">set_channel_types</span></code></a>(mapping)</td>
<td>Define the sensor type of channels.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.set_eeg_reference" title="mne.EpochsArray.set_eeg_reference"><code class="xref py py-obj docutils literal"><span class="pre">set_eeg_reference</span></code></a>([ref_channels])</td>
<td>Rereference EEG channels to new reference channel(s).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.set_montage" title="mne.EpochsArray.set_montage"><code class="xref py py-obj docutils literal"><span class="pre">set_montage</span></code></a>(montage[,&nbsp;verbose])</td>
<td>Set EEG sensor configuration</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.standard_error" title="mne.EpochsArray.standard_error"><code class="xref py py-obj docutils literal"><span class="pre">standard_error</span></code></a>([picks])</td>
<td>Compute standard error over epochs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.subtract_evoked" title="mne.EpochsArray.subtract_evoked"><code class="xref py py-obj docutils literal"><span class="pre">subtract_evoked</span></code></a>([evoked])</td>
<td>Subtract an evoked response from each epoch</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.EpochsArray.time_as_index" title="mne.EpochsArray.time_as_index"><code class="xref py py-obj docutils literal"><span class="pre">time_as_index</span></code></a>(times[,&nbsp;use_rounding])</td>
<td>Convert time to indices</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.EpochsArray.to_data_frame" title="mne.EpochsArray.to_data_frame"><code class="xref py py-obj docutils literal"><span class="pre">to_data_frame</span></code></a>([picks,&nbsp;index,&nbsp;scale_time,&nbsp;...])</td>
<td>Export data in tabular structure as a pandas DataFrame.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mne.EpochsArray.__contains__">
<code class="descname">__contains__</code><span class="sig-paren">(</span><em>ch_type</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>Check channel type membership</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : str</p>
<blockquote>
<div><p>Channel type to check for. Can be e.g. &#8216;meg&#8217;, &#8216;eeg&#8217;, &#8216;stim&#8217;, etc.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>in</strong> : bool</p>
<blockquote class="last">
<div><p>Whether or not the instance contains the given channel type.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Channel type membership can be tested as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;meg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;seeg&#39;</span> <span class="ow">in</span> <span class="n">inst</span>  
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.__getitem__">
<code class="descname">__getitem__</code><span class="sig-paren">(</span><em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an Epochs object with a copied subset of epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>item</strong> : slice, array-like, str, or list</p>
<blockquote>
<div><p>See below for use cases.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>See below for use cases.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Epochs can be accessed as <code class="docutils literal"><span class="pre">epochs[...]</span></code> in several ways:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">epochs[idx]</span></code>: Return <code class="docutils literal"><span class="pre">Epochs</span></code> object with a subset of
epochs (supports single index and python-style slicing).</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">epochs['name']</span></code>: Return <code class="docutils literal"><span class="pre">Epochs</span></code> object with a copy of the
subset of epochs corresponding to an experimental condition as
specified by &#8216;name&#8217;.</p>
<p>If conditions are tagged by names separated by &#8216;/&#8217; (e.g.
&#8216;audio/left&#8217;, &#8216;audio/right&#8217;), and &#8216;name&#8217; is not in itself an
event key, this selects every event whose condition contains
the &#8216;name&#8217; tag (e.g., &#8216;left&#8217; matches &#8216;audio/left&#8217; and
&#8216;visual/left&#8217;; but not &#8216;audio_left&#8217;). Note that tags like
&#8216;auditory/left&#8217; and &#8216;left/auditory&#8217; will be treated the
same way when accessed using tags.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">epochs[['name_1',</span> <span class="pre">'name_2',</span> <span class="pre">...</span> <span class="pre">]]</span></code>: Return <code class="docutils literal"><span class="pre">Epochs</span></code> object
with a copy of the subset of epochs corresponding to multiple
experimental conditions as specified by
<code class="docutils literal"><span class="pre">'name_1',</span> <span class="pre">'name_2',</span> <span class="pre">...</span></code> .</p>
<p>If conditions are separated by &#8216;/&#8217;, selects every item
containing every list tag (e.g. [&#8216;audio&#8217;, &#8216;left&#8217;] selects
&#8216;audio/left&#8217; and &#8216;audio/center/left&#8217;, but not &#8216;audio/right&#8217;).</p>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.__hash__" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hash</strong> : int</p>
<blockquote class="last">
<div><p>The hash</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.__iter__">
<code class="descname">__iter__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to make iteration over epochs easy</p>
<p class="rubric">Notes</p>
<p>This enables the use of this Python pattern:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">epochs</span><span class="p">:</span>  
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>  
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">epoch</span></code> is given by successive outputs of
<a class="reference internal" href="mne.Epochs.html#mne.Epochs.next" title="mne.Epochs.next"><code class="xref py py-func docutils literal"><span class="pre">mne.Epochs.next()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.__len__">
<code class="descname">__len__</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>n_epochs</strong> : int</p>
<blockquote class="last">
<div><p>The number of remaining epochs.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function only works if bad epochs have been dropped.</p>
<p class="rubric">Examples</p>
<p>This can be used as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">epochs</span><span class="o">.</span><span class="n">drop_bad</span><span class="p">()</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>  
<span class="go">43</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>  
<span class="go">43</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.add_channels">
<code class="descname">add_channels</code><span class="sig-paren">(</span><em>add_list</em>, <em>force_update_info=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.add_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Append new channels to the instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>add_list</strong> : list</p>
<blockquote>
<div><p>A list of objects to append to self. Must contain all the same
type as the current object</p>
</div></blockquote>
<p><strong>force_update_info</strong> : bool</p>
<blockquote>
<div><p>If True, force the info for objects to be appended to match the
values in <cite>self</cite>. This should generally only be used when adding
stim channels for which important metadata won&#8217;t be overwritten.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.add_eeg_average_proj">
<code class="descname">add_eeg_average_proj</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.add_eeg_average_proj" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: This function is deprecated and will be removed in 0.14. Use set_eeg_reference() instead.</p>
</div>
<p>Add an average EEG reference projector if one does not exist.</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.add_proj">
<code class="descname">add_proj</code><span class="sig-paren">(</span><em>projs</em>, <em>remove_existing=False</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.add_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Add SSP projection vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>projs</strong> : list</p>
<blockquote>
<div><p>List with projection vectors.</p>
</div></blockquote>
<p><strong>remove_existing</strong> : bool</p>
<blockquote>
<div><p>Remove the projection vectors currently in the file.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The data container.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.anonymize">
<code class="descname">anonymize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.anonymize" title="Permalink to this definition">¶</a></dt>
<dd><p>Anonymize measurement information in place.</p>
<p>Reset &#8216;subject_info&#8217;, &#8216;meas_date&#8217;, &#8216;file_id&#8217;, and &#8216;meas_id&#8217; keys if they
exist in <code class="docutils literal"><span class="pre">info</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>info</strong> : instance of Info</p>
<blockquote class="last">
<div><p>Measurement information for the dataset.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.apply_baseline">
<code class="descname">apply_baseline</code><span class="sig-paren">(</span><em>baseline=(None</em>, <em>0)</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.apply_baseline" title="Permalink to this definition">¶</a></dt>
<dd><p>Baseline correct epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>baseline</strong> : tuple of length 2</p>
<blockquote>
<div><p>The time interval to apply baseline correction. If None do not
apply it. If baseline is (a, b) the interval is between &#8220;a (s)&#8221; and
&#8220;b (s)&#8221;. If a is None the beginning of the data is used and if b is
None then b is set to the end of the interval. If baseline is equal
to (None, None) all the time interval is used. Correction is
applied by computing mean of the baseline period and subtracting it
from the data. The baseline (a, b) includes both endpoints, i.e.
all timepoints t such that a &lt;= t &lt;= b.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The baseline-corrected Epochs object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Baseline correction can be done multiple times.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.apply_proj">
<code class="descname">apply_proj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.apply_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the signal space projection (SSP) operators to the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>The instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Once the projectors have been applied, they can no longer be
removed. It is usually not recommended to apply the projectors at
too early stages, as they are applied automatically later on
(e.g. when computing inverse solutions).
Hint: using the copy method individual projection vectors
can be tested without affecting the original data.
With evoked data, consider the following example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">projs_a</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_a.fif&#39;</span><span class="p">)</span>
<span class="n">projs_b</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_proj</span><span class="p">(</span><span class="s1">&#39;proj_b.fif&#39;</span><span class="p">)</span>
<span class="c1"># add the first, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># add the second, copy, apply and see ...</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">add_proj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1"># drop the first and see again</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">del_proj</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">evoked</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>  <span class="c1"># finally keep both</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.average">
<code class="descname">average</code><span class="sig-paren">(</span><em>picks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute average of epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG, EEG, SEEG, ECoG, and fNIRS channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>evoked</strong> : instance of Evoked</p>
<blockquote class="last">
<div><p>The averaged epochs.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Computes an average of all epochs in the instance, even if
they correspond to different conditions. To average by condition,
do <code class="docutils literal"><span class="pre">epochs[condition].average()</span></code> for each condition separately.</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.EpochsArray.ch_names">
<code class="descname">ch_names</code><a class="headerlink" href="#mne.EpochsArray.ch_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Channel names</p>
</dd></dl>

<dl class="attribute">
<dt id="mne.EpochsArray.compensation_grade">
<code class="descname">compensation_grade</code><a class="headerlink" href="#mne.EpochsArray.compensation_grade" title="Permalink to this definition">¶</a></dt>
<dd><p>The current gradient compensation grade</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return copy of Epochs instance</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.crop">
<code class="descname">crop</code><span class="sig-paren">(</span><em>tmin=None</em>, <em>tmax=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Crops a time interval from epochs object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Start time of selection in seconds.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>End time of selection in seconds.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The cropped epochs.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Unlike Python slices, MNE time intervals include both their end points;
crop(tmin, tmax) returns the interval tmin &lt;= t &lt;= tmax.</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.decimate">
<code class="descname">decimate</code><span class="sig-paren">(</span><em>decim</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Decimate the epochs</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">No filtering is performed. To avoid aliasing, ensure
your data are properly lowpassed.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>decim</strong> : int</p>
<blockquote>
<div><p>The amount to decimate data.</p>
</div></blockquote>
<p><strong>offset</strong> : int</p>
<blockquote>
<div><p>Apply an offset to where the decimation starts relative to the
sample corresponding to t=0. The offset is in samples at the
current sampling rate.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.</span></p>
</div>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The decimated Epochs object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.Evoked.html#mne.Evoked.decimate" title="mne.Evoked.decimate"><code class="xref py py-obj docutils literal"><span class="pre">Evoked.decimate</span></code></a>, <a class="reference internal" href="mne.Epochs.html#mne.Epochs.resample" title="mne.Epochs.resample"><code class="xref py py-obj docutils literal"><span class="pre">Epochs.resample</span></code></a>, <code class="xref py py-obj docutils literal"><span class="pre">Raw.resample</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>Decimation can be done multiple times. For example,
<code class="docutils literal"><span class="pre">epochs.decimate(2).decimate(2)</span></code> will be the same as
<code class="docutils literal"><span class="pre">epochs.decimate(4)</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.del_proj">
<code class="descname">del_proj</code><span class="sig-paren">(</span><em>idx</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.del_proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove SSP projection vector</p>
<dl class="docutils">
<dt>Note: The projection vector can only be removed if it is inactive</dt>
<dd>(has not been applied to the data).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>idx</strong> : int</p>
<blockquote>
<div><p>Index of the projector to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>self</strong> : instance of Raw | Epochs | Evoked</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.drop">
<code class="descname">drop</code><span class="sig-paren">(</span><em>indices</em>, <em>reason='USER'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop epochs based on indices or boolean mask</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The indices refer to the current set of undropped epochs
rather than the complete set of dropped and undropped epochs.
They are therefore not necessarily consistent with any
external indices (e.g., behavioral logs). To drop epochs
based on external criteria, do not use the <code class="docutils literal"><span class="pre">preload=True</span></code>
flag when constructing an Epochs object, and call this
method before calling the <a class="reference internal" href="mne.Epochs.html#mne.Epochs.drop_bad" title="mne.Epochs.drop_bad"><code class="xref py py-func docutils literal"><span class="pre">mne.Epochs.drop_bad()</span></code></a> or
<a class="reference internal" href="mne.Epochs.html#mne.Epochs.load_data" title="mne.Epochs.load_data"><code class="xref py py-func docutils literal"><span class="pre">mne.Epochs.load_data()</span></code></a> methods.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> : array of ints or bools</p>
<blockquote>
<div><p>Set epochs to remove by specifying indices to remove or a boolean
mask to apply (where True values get removed). Events are
correspondingly modified.</p>
</div></blockquote>
<p><strong>reason</strong> : str</p>
<blockquote>
<div><p>Reason for dropping the epochs (&#8216;ECG&#8217;, &#8216;timeout&#8217;, &#8216;blink&#8217; etc).
Default: &#8216;USER&#8217;.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The epochs with indices dropped. Operates in-place.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.drop_bad">
<code class="descname">drop_bad</code><span class="sig-paren">(</span><em>reject='existing'</em>, <em>flat='existing'</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.drop_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop bad epochs without retaining the epochs data.</p>
<p>Should be used before slicing operations.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This operation is slow since all epochs have to be read
from disk. To avoid reading epochs from disk multiple
times, use <a class="reference internal" href="mne.Epochs.html#mne.Epochs.load_data" title="mne.Epochs.load_data"><code class="xref py py-func docutils literal"><span class="pre">mne.Epochs.load_data()</span></code></a>.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reject</strong> : dict | str | None</p>
<blockquote>
<div><p>Rejection parameters based on peak-to-peak amplitude.
Valid keys are &#8216;grad&#8217; | &#8216;mag&#8217; | &#8216;eeg&#8217; | &#8216;eog&#8217; | &#8216;ecg&#8217;.
If reject is None then no rejection is done. If &#8216;existing&#8217;,
then the rejection parameters set at instantiation are used.</p>
</div></blockquote>
<p><strong>flat</strong> : dict | str | None</p>
<blockquote>
<div><p>Rejection parameters based on flatness of signal.
Valid keys are &#8216;grad&#8217; | &#8216;mag&#8217; | &#8216;eeg&#8217; | &#8216;eog&#8217; | &#8216;ecg&#8217;, and values
are floats that set the minimum acceptable peak-to-peak amplitude.
If flat is None then no rejection is done. If &#8216;existing&#8217;,
then the flat parameters set at instantiation are used.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The epochs with bad epochs dropped. Operates in-place.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Dropping bad epochs can be done multiple times with different
<code class="docutils literal"><span class="pre">reject</span></code> and <code class="docutils literal"><span class="pre">flat</span></code> parameters. However, once an epoch is
dropped, it is dropped forever, so if more lenient thresholds may
subsequently be applied, <cite>epochs.copy</cite> should be used.</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.drop_channels">
<code class="descname">drop_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.drop_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>List of the names of the channels to remove.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.pick_channels.html#mne.pick_channels" title="mne.pick_channels"><code class="xref py py-obj docutils literal"><span class="pre">pick_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.drop_log_stats">
<code class="descname">drop_log_stats</code><span class="sig-paren">(</span><em>ignore=('IGNORED'</em>, <em>)</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.drop_log_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the channel stats based on a drop_log from Epochs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ignore</strong> : list</p>
<blockquote>
<div><p>The drop reasons to ignore.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>perc</strong> : float</p>
<blockquote class="last">
<div><p>Total percentage of epochs dropped.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.EpochsArray.plot_drop_log" title="mne.EpochsArray.plot_drop_log"><code class="xref py py-obj docutils literal"><span class="pre">plot_drop_log</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.equalize_event_counts">
<code class="descname">equalize_event_counts</code><span class="sig-paren">(</span><em>event_ids</em>, <em>method='mintime'</em>, <em>copy=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.equalize_event_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Equalize the number of trials in each condition</p>
<p>It tries to make the remaining epochs occurring as close as possible in
time. This method works based on the idea that if there happened to be
some time-varying (like on the scale of minutes) noise characteristics
during a recording, they could be compensated for (to some extent) in
the equalization process. This method thus seeks to reduce any of
those effects by minimizing the differences in the times of the events
in the two sets of epochs. For example, if one had event times
[1, 2, 3, 4, 120, 121] and the other one had [3.5, 4.5, 120.5, 121.5],
it would remove events at times [1, 2] in the first epochs and not
[20, 21].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>event_ids</strong> : list</p>
<blockquote>
<div><p>The event types to equalize. Each entry in the list can either be
a str (single event) or a list of str. In the case where one of
the entries is a list of str, event_ids in that list will be
grouped together before equalizing trial counts across conditions.
In the case where partial matching is used (using &#8216;/&#8217; in
<cite>event_ids</cite>), <cite>event_ids</cite> will be matched according to the
provided tags, that is, processing works as if the event_ids
matched by the provided tags had been supplied instead.
The event_ids must identify nonoverlapping subsets of the epochs.</p>
</div></blockquote>
<p><strong>method</strong> : str</p>
<blockquote>
<div><p>If &#8216;truncate&#8217;, events will be truncated from the end of each event
list. If &#8216;mintime&#8217;, timing differences between each event list
will be minimized.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>This parameter has been deprecated and will be removed in 0.14.
Use inst.copy() instead.
Whether to return a new instance or modify in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote>
<div><p>The modified Epochs instance.</p>
</div></blockquote>
<p><strong>indices</strong> : array of int</p>
<blockquote class="last">
<div><p>Indices from the original events list that were dropped.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For example (if epochs.event_id was {&#8216;Left&#8217;: 1, &#8216;Right&#8217;: 2,
&#8216;Nonspatial&#8217;:3}:</p>
<blockquote>
<div>epochs.equalize_event_counts([[&#8216;Left&#8217;, &#8216;Right&#8217;], &#8216;Nonspatial&#8217;])</div></blockquote>
<p>would equalize the number of trials in the &#8216;Nonspatial&#8217; condition with
the total number of trials in the &#8216;Left&#8217; and &#8216;Right&#8217; conditions.</p>
<p>If multiple indices are provided (e.g. &#8216;Left&#8217; and &#8216;Right&#8217; in the
example above), it is not guaranteed that after equalization, the
conditions will contribute evenly. E.g., it is possible to end up
with 70 &#8216;Nonspatial&#8217; trials, 69 &#8216;Left&#8217; and 1 &#8216;Right&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all epochs as a 3D array</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> : array of shape (n_epochs, n_channels, n_times)</p>
<blockquote class="last">
<div><p>A copy of the epochs data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.interpolate_bads">
<code class="descname">interpolate_bads</code><span class="sig-paren">(</span><em>reset_bads=True</em>, <em>mode='accurate'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.interpolate_bads" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate bad MEG and EEG channels.</p>
<p>Operates in place.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>reset_bads</strong> : bool</p>
<blockquote>
<div><p>If True, remove the bads from info.</p>
</div></blockquote>
<p><strong>mode</strong> : str</p>
<blockquote>
<div><p>Either <cite>&#8216;accurate&#8217;</cite> or <cite>&#8216;fast&#8217;</cite>, determines the quality of the
Legendre polynomial expansion used for interpolation of MEG
channels.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.iter_evoked">
<code class="descname">iter_evoked</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.iter_evoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over epochs as a sequence of Evoked objects</p>
<p>The Evoked objects yielded will each contain a single epoch (i.e., no
averaging is performed).</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.load_data">
<code class="descname">load_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the data if not already preloaded</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The epochs object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function operates in-place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.next">
<code class="descname">next</code><span class="sig-paren">(</span><em>return_event_id=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over epoch data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>return_event_id</strong> : bool</p>
<blockquote>
<div><p>If True, return both the epoch data and an event_id.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epoch</strong> : array of shape (n_channels, n_times)</p>
<blockquote>
<div><p>The epoch data.</p>
</div></blockquote>
<p><strong>event_id</strong> : int</p>
<blockquote class="last">
<div><p>The event id. Only returned if <code class="docutils literal"><span class="pre">return_event_id</span></code> is <code class="docutils literal"><span class="pre">True</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.pick_channels">
<code class="descname">pick_channels</code><span class="sig-paren">(</span><em>ch_names</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.pick_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_names</strong> : list</p>
<blockquote>
<div><p>The list of channels to select.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#mne.EpochsArray.drop_channels" title="mne.EpochsArray.drop_channels"><code class="xref py py-obj docutils literal"><span class="pre">drop_channels</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.pick_types">
<code class="descname">pick_types</code><span class="sig-paren">(</span><em>meg=True</em>, <em>eeg=False</em>, <em>stim=False</em>, <em>eog=False</em>, <em>ecg=False</em>, <em>emg=False</em>, <em>ref_meg='auto'</em>, <em>misc=False</em>, <em>resp=False</em>, <em>chpi=False</em>, <em>exci=False</em>, <em>ias=False</em>, <em>syst=False</em>, <em>seeg=False</em>, <em>dipole=False</em>, <em>gof=False</em>, <em>bio=False</em>, <em>ecog=False</em>, <em>fnirs=False</em>, <em>include=[]</em>, <em>exclude='bads'</em>, <em>selection=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.pick_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Pick some channels by type and names</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>meg</strong> : bool | str</p>
<blockquote>
<div><p>If True include all MEG channels. If False include None
If string it can be &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;planar1&#8217; or &#8216;planar2&#8217; to select
only magnetometers, all gradiometers, or a specific type of
gradiometer.</p>
</div></blockquote>
<p><strong>eeg</strong> : bool</p>
<blockquote>
<div><p>If True include EEG channels.</p>
</div></blockquote>
<p><strong>stim</strong> : bool</p>
<blockquote>
<div><p>If True include stimulus channels.</p>
</div></blockquote>
<p><strong>eog</strong> : bool</p>
<blockquote>
<div><p>If True include EOG channels.</p>
</div></blockquote>
<p><strong>ecg</strong> : bool</p>
<blockquote>
<div><p>If True include ECG channels.</p>
</div></blockquote>
<p><strong>emg</strong> : bool</p>
<blockquote>
<div><p>If True include EMG channels.</p>
</div></blockquote>
<p><strong>ref_meg: bool | str</strong></p>
<blockquote>
<div><p>If True include CTF / 4D reference channels. If &#8216;auto&#8217;, the
reference channels are only included if compensations are present.</p>
</div></blockquote>
<p><strong>misc</strong> : bool</p>
<blockquote>
<div><p>If True include miscellaneous analog channels.</p>
</div></blockquote>
<p><strong>resp</strong> : bool</p>
<blockquote>
<div><p>If True include response-trigger channel. For some MEG systems this
is separate from the stim channel.</p>
</div></blockquote>
<p><strong>chpi</strong> : bool</p>
<blockquote>
<div><p>If True include continuous HPI coil channels.</p>
</div></blockquote>
<p><strong>exci</strong> : bool</p>
<blockquote>
<div><p>Flux excitation channel used to be a stimulus channel.</p>
</div></blockquote>
<p><strong>ias</strong> : bool</p>
<blockquote>
<div><p>Internal Active Shielding data (maybe on Triux only).</p>
</div></blockquote>
<p><strong>syst</strong> : bool</p>
<blockquote>
<div><p>System status channel information (on Triux systems only).</p>
</div></blockquote>
<p><strong>seeg</strong> : bool</p>
<blockquote>
<div><p>Stereotactic EEG channels.</p>
</div></blockquote>
<p><strong>dipole</strong> : bool</p>
<blockquote>
<div><p>Dipole time course channels.</p>
</div></blockquote>
<p><strong>gof</strong> : bool</p>
<blockquote>
<div><p>Dipole goodness of fit channels.</p>
</div></blockquote>
<p><strong>bio</strong> : bool</p>
<blockquote>
<div><p>Bio channels.</p>
</div></blockquote>
<p><strong>ecog</strong> : bool</p>
<blockquote>
<div><p>Electrocorticography channels.</p>
</div></blockquote>
<p><strong>fnirs</strong> : bool | str</p>
<blockquote>
<div><p>Functional near-infrared spectroscopy channels. If True include all
fNIRS channels. If False (default) include none. If string it can
be &#8216;hbo&#8217; (to include channels measuring oxyhemoglobin) or &#8216;hbr&#8217; (to
include channels measuring deoxyhemoglobin).</p>
</div></blockquote>
<p><strong>include</strong> : list of string</p>
<blockquote>
<div><p>List of additional channels to include. If empty do not include
any.</p>
</div></blockquote>
<p><strong>exclude</strong> : list of string | str</p>
<blockquote>
<div><p>List of channels to exclude. If &#8216;bads&#8217; (default), exclude channels
in <code class="docutils literal"><span class="pre">info['bads']</span></code>.</p>
</div></blockquote>
<p><strong>selection</strong> : list of string</p>
<blockquote>
<div><p>Restrict sensor channels (MEG, EEG) to this list of channel names.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw, Epochs, or Evoked</p>
<blockquote class="last">
<div><p>The modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot">
<code class="descname">plot</code><span class="sig-paren">(</span><em>picks=None</em>, <em>scalings=None</em>, <em>n_epochs=20</em>, <em>n_channels=20</em>, <em>title=None</em>, <em>show=True</em>, <em>block=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize epochs</p>
<p>Bad epochs can be marked with a left click on top of the epoch. Bad
channels can be selected by clicking the channel name on the left side of
the main axes. Calling this function drops all the selected bad epochs as
well as bad epochs marked beforehand with rejection parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>Channels to be included. If None only good data channels are used.
Defaults to None</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | &#8216;auto&#8217; | None</p>
<blockquote>
<div><p>Scaling factors for the traces. If any fields in scalings are &#8216;auto&#8217;,
the scaling factor is set to match the 99.5th percentile of a subset of
the corresponding data. If scalings == &#8216;auto&#8217;, all scalings fields are
set to &#8216;auto&#8217;. If any fields are &#8216;auto&#8217; and data is not preloaded,
a subset of epochs up to 100mb will be loaded. If None, defaults to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">mag</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="n">grad</span><span class="o">=</span><span class="mi">4</span><span class="n">e</span><span class="o">-</span><span class="mi">11</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="mi">20</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="mi">150</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="mi">5</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span>
     <span class="n">emg</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">ref_meg</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="n">misc</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">resp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chpi</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>n_epochs</strong> : int</p>
<blockquote>
<div><p>The number of epochs per view. Defaults to 20.</p>
</div></blockquote>
<p><strong>n_channels</strong> : int</p>
<blockquote>
<div><p>The number of channels per view. Defaults to 20.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>The title of the window. If None, epochs name will be displayed.
Defaults to None.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True</p>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
Useful for rejecting bad trials on the fly by clicking on an epoch.
Defaults to False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The arrow keys (up/down/left/right) can be used to navigate between
channels and epochs and the scaling can be adjusted with - and + (or =)
keys, but this depends on the backend matplotlib is configured to use
(e.g., mpl.use(<code class="docutils literal"><span class="pre">TkAgg</span></code>) should work). Full screen mode can be toggled
with f11 key. The amount of epochs and channels per view can be adjusted
with home/end and page down/page up keys. Butterfly plot can be toggled
with <code class="docutils literal"><span class="pre">b</span></code> key. Right mouse click adds a vertical line to the plot.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot_drop_log">
<code class="descname">plot_drop_log</code><span class="sig-paren">(</span><em>threshold=0</em>, <em>n_max_plot=20</em>, <em>subject='Unknown'</em>, <em>color=(0.9</em>, <em>0.9</em>, <em>0.9)</em>, <em>width=0.8</em>, <em>ignore=('IGNORED'</em>, <em>)</em>, <em>show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot_drop_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the channel stats based on a drop_log from Epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : float</p>
<blockquote>
<div><p>The percentage threshold to use to decide whether or not to
plot. Default is zero (always plot).</p>
</div></blockquote>
<p><strong>n_max_plot</strong> : int</p>
<blockquote>
<div><p>Maximum number of channels to show stats for.</p>
</div></blockquote>
<p><strong>subject</strong> : str</p>
<blockquote>
<div><p>The subject name to use in the title of the plot.</p>
</div></blockquote>
<p><strong>color</strong> : tuple | str</p>
<blockquote>
<div><p>Color to use for the bars.</p>
</div></blockquote>
<p><strong>width</strong> : float</p>
<blockquote>
<div><p>Width of the bars.</p>
</div></blockquote>
<p><strong>ignore</strong> : list</p>
<blockquote>
<div><p>The drop reasons to ignore.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : Instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot_image">
<code class="descname">plot_image</code><span class="sig-paren">(</span><em>picks=None</em>, <em>sigma=0.0</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>colorbar=True</em>, <em>order=None</em>, <em>show=True</em>, <em>units=None</em>, <em>scalings=None</em>, <em>cmap='RdBu_r'</em>, <em>fig=None</em>, <em>axes=None</em>, <em>overlay_times=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Event Related Potential / Fields image</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : int | array-like of int | None</p>
<blockquote>
<div><p>The indices of the channels to consider. If None, the first
five good channels are plotted.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>The standard deviation of the Gaussian smoothing to apply along
the epoch axis to apply in the image. If 0., no smoothing is applied.</p>
</div></blockquote>
<p><strong>vmin</strong> : float</p>
<blockquote>
<div><p>The min value in the image. The unit is uV for EEG channels,
fT for magnetometers and fT/cm for gradiometers.</p>
</div></blockquote>
<p><strong>vmax</strong> : float</p>
<blockquote>
<div><p>The max value in the image. The unit is uV for EEG channels,
fT for magnetometers and fT/cm for gradiometers.</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Display or not a colorbar.</p>
</div></blockquote>
<p><strong>order</strong> : None | array of int | callable</p>
<blockquote>
<div><p>If not None, order is used to reorder the epochs on the y-axis
of the image. If it&#8217;s an array of int it should be of length
the number of good epochs. If it&#8217;s a callable the arguments
passed are the times vector and the data as 2d array
(data.shape[1] == len(times).</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
<p><strong>units</strong> : dict | None</p>
<blockquote>
<div><p>The units of the channel types used for axes lables. If None,
defaults to <cite>units=dict(eeg=&#8217;uV&#8217;, grad=&#8217;fT/cm&#8217;, mag=&#8217;fT&#8217;)</cite>.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting.
If None, defaults to <cite>scalings=dict(eeg=1e6, grad=1e13, mag=1e15,
eog=1e6)</cite>.</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap | (colormap, bool) | &#8216;interactive&#8217;</p>
<blockquote>
<div><p>Colormap. If tuple, the first value indicates the colormap to use and
the second value is a boolean defining interactivity. In interactive
mode the colors are adjustable by clicking and dragging the colorbar
with left and right mouse button. Left mouse button moves the scale up
and down and right mouse button adjusts the range. Hitting space bar
resets the scale. Up and down arrows can be used to change the
colormap. If &#8216;interactive&#8217;, translates to (&#8216;RdBu_r&#8217;, True). Defaults to
&#8216;RdBu_r&#8217;.</p>
</div></blockquote>
<p><strong>fig</strong> : matplotlib figure | None</p>
<blockquote>
<div><p>Figure instance to draw the image to. Figure must contain two axes for
drawing the single trials and evoked responses. If None a new figure is
created. Defaults to None.</p>
</div></blockquote>
<p><strong>axes</strong> : list of matplotlib axes | None</p>
<blockquote>
<div><p>List of axes instances to draw the image, erp and colorbar to.
Must be of length three if colorbar is True (with the last list element
being the colorbar axes) or two if colorbar is False. If both fig and
axes are passed an error is raised. Defaults to None.</p>
</div></blockquote>
<p><strong>overlay_times</strong> : array-like, shape (n_epochs,) | None</p>
<blockquote>
<div><p>If not None the parameter is interpreted as time instants in seconds
and is added to the image. It is typically useful to display reaction
times. Note that it is defined with respect to the order
of epochs such that overlay_times[0] corresponds to epochs[0].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>figs</strong> : lists of matplotlib figures</p>
<blockquote class="last">
<div><p>One figure per channel displayed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot_projs_topomap">
<code class="descname">plot_projs_topomap</code><span class="sig-paren">(</span><em>ch_type=None</em>, <em>layout=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot_projs_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot SSP vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None | List</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collec-
ted in pairs and the RMS for each pair is plotted. If None
(default), it will return all channel types present. If a list of
ch_types is provided, it will return multiple figures.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout | List of Layouts</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct
layout file is inferred from the data; if no appropriate layout
file was found, the layout is automatically generated from the
sensor locations. Or a list of Layout if projections
are from different sensor types.</p>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | list | None</p>
<blockquote>
<div><p>The axes to plot to. If list, the list must be a list of Axes of
the same length as the number of projectors. If instance of Axes,
there must be only one projector. Defaults to None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot_psd">
<code class="descname">plot_psd</code><span class="sig-paren">(</span><em>fmin=0</em>, <em>fmax=inf</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>proj=False</em>, <em>bandwidth=None</em>, <em>adaptive=False</em>, <em>low_bias=True</em>, <em>normalization='length'</em>, <em>picks=None</em>, <em>ax=None</em>, <em>color='black'</em>, <em>area_mode='std'</em>, <em>area_alpha=0.33</em>, <em>dB=True</em>, <em>n_jobs=1</em>, <em>show=True</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot_psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the power spectral density across epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fmin</strong> : float</p>
<blockquote>
<div><p>Start frequency to consider.</p>
</div></blockquote>
<p><strong>fmax</strong> : float</p>
<blockquote>
<div><p>End frequency to consider.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Start time to consider.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>End time to consider.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection.</p>
</div></blockquote>
<p><strong>bandwidth</strong> : float</p>
<blockquote>
<div><p>The bandwidth of the multi taper windowing function in Hz. The default
value is a window half-bandwidth of 4.</p>
</div></blockquote>
<p><strong>adaptive</strong> : bool</p>
<blockquote>
<div><p>Use adaptive weights to combine the tapered spectra into PSD
(slow, use n_jobs &gt;&gt; 1 to speed up computation).</p>
</div></blockquote>
<p><strong>low_bias</strong> : bool</p>
<blockquote>
<div><p>Only use tapers with more than 90% spectral concentration within
bandwidth.</p>
</div></blockquote>
<p><strong>normalization</strong> : str</p>
<blockquote>
<div><p>Either &#8220;full&#8221; or &#8220;length&#8221; (default). If &#8220;full&#8221;, the PSD will
be normalized by the sampling rate as well as the length of
the signal (as in nitime).</p>
</div></blockquote>
<p><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>List of channels to use.</p>
</div></blockquote>
<p><strong>ax</strong> : instance of matplotlib Axes | None</p>
<blockquote>
<div><p>Axes to plot into. If None, axes will be created.</p>
</div></blockquote>
<p><strong>color</strong> : str | tuple</p>
<blockquote>
<div><p>A matplotlib-compatible color to use.</p>
</div></blockquote>
<p><strong>area_mode</strong> : str | None</p>
<blockquote>
<div><p>Mode for plotting area. If &#8216;std&#8217;, the mean +/- 1 STD (across channels)
will be plotted. If &#8216;range&#8217;, the min and max (across channels) will be
plotted. Bad channels will be excluded from these calculations.
If None, no area will be plotted.</p>
</div></blockquote>
<p><strong>area_alpha</strong> : float</p>
<blockquote>
<div><p>Alpha for the area.</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot_psd_topomap">
<code class="descname">plot_psd_topomap</code><span class="sig-paren">(</span><em>bands=None</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>tmin=None</em>, <em>tmax=None</em>, <em>proj=False</em>, <em>bandwidth=None</em>, <em>adaptive=False</em>, <em>low_bias=True</em>, <em>normalization='length'</em>, <em>ch_type=None</em>, <em>layout=None</em>, <em>cmap='RdBu_r'</em>, <em>agg_fun=None</em>, <em>dB=True</em>, <em>n_jobs=1</em>, <em>normalize=False</em>, <em>cbar_fmt='%0.3f'</em>, <em>outlines='head'</em>, <em>axes=None</em>, <em>show=True</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot_psd_topomap" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the topomap of the power spectral density across epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bands</strong> : list of tuple | None</p>
<blockquote>
<div><p>The lower and upper frequency and the name for that band. If None,
(default) expands to:</p>
<dl class="docutils">
<dt>bands = [(0, 4, &#8216;Delta&#8217;), (4, 8, &#8216;Theta&#8217;), (8, 12, &#8216;Alpha&#8217;),</dt>
<dd><p class="first last">(12, 30, &#8216;Beta&#8217;), (30, 45, &#8216;Gamma&#8217;)]</p>
</dd>
</dl>
</div></blockquote>
<p><strong>vmin</strong> : float | callable | None</p>
<blockquote>
<div><p>The value specifying the lower bound of the color range.
If None np.min(data) is used. If callable, the output equals
vmin(data).</p>
</div></blockquote>
<p><strong>vmax</strong> : float | callable | None</p>
<blockquote>
<div><p>The value specifying the upper bound of the color range.
If None, the maximum absolute value is used. If callable, the output
equals vmax(data). Defaults to None.</p>
</div></blockquote>
<p><strong>tmin</strong> : float | None</p>
<blockquote>
<div><p>Start time to consider.</p>
</div></blockquote>
<p><strong>tmax</strong> : float | None</p>
<blockquote>
<div><p>End time to consider.</p>
</div></blockquote>
<p><strong>proj</strong> : bool</p>
<blockquote>
<div><p>Apply projection.</p>
</div></blockquote>
<p><strong>bandwidth</strong> : float</p>
<blockquote>
<div><p>The bandwidth of the multi taper windowing function in Hz. The default
value is a window half-bandwidth of 4 Hz.</p>
</div></blockquote>
<p><strong>adaptive</strong> : bool</p>
<blockquote>
<div><p>Use adaptive weights to combine the tapered spectra into PSD
(slow, use n_jobs &gt;&gt; 1 to speed up computation).</p>
</div></blockquote>
<p><strong>low_bias</strong> : bool</p>
<blockquote>
<div><p>Only use tapers with more than 90% spectral concentration within
bandwidth.</p>
</div></blockquote>
<p><strong>normalization</strong> : str</p>
<blockquote>
<div><p>Either &#8220;full&#8221; or &#8220;length&#8221; (default). If &#8220;full&#8221;, the PSD will
be normalized by the sampling rate as well as the length of
the signal (as in nitime).</p>
</div></blockquote>
<p><strong>ch_type</strong> : &#8216;mag&#8217; | &#8216;grad&#8217; | &#8216;planar1&#8217; | &#8216;planar2&#8217; | &#8216;eeg&#8217; | None</p>
<blockquote>
<div><p>The channel type to plot. For &#8216;grad&#8217;, the gradiometers are collected in
pairs and the RMS for each pair is plotted. If None, then first
available channel type from order given above is used. Defaults to
None.</p>
</div></blockquote>
<p><strong>layout</strong> : None | Layout</p>
<blockquote>
<div><p>Layout instance specifying sensor positions (does not need to
be specified for Neuromag data). If possible, the correct layout
file is inferred from the data; if no appropriate layout file was
found, the layout is automatically generated from the sensor
locations.</p>
</div></blockquote>
<p><strong>cmap</strong> : matplotlib colormap | (colormap, bool) | &#8216;interactive&#8217; | None</p>
<blockquote>
<div><p>Colormap to use. If tuple, the first value indicates the colormap to
use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging the
colorbar with left and right mouse button. Left mouse button moves the
scale up and down and right mouse button adjusts the range. Hitting
space bar resets the range. Up and down arrows can be used to change
the colormap. If None (default), &#8216;Reds&#8217; is used for all positive data,
otherwise defaults to &#8216;RdBu_r&#8217;. If &#8216;interactive&#8217;, translates to
(None, True).</p>
</div></blockquote>
<p><strong>agg_fun</strong> : callable</p>
<blockquote>
<div><p>The function used to aggregate over frequencies.
Defaults to np.sum. if normalize is True, else np.mean.</p>
</div></blockquote>
<p><strong>dB</strong> : bool</p>
<blockquote>
<div><p>If True, transform data to decibels (with <code class="docutils literal"><span class="pre">10</span> <span class="pre">*</span> <span class="pre">np.log10(data)</span></code>)
following the application of <cite>agg_fun</cite>. Only valid if normalize is
False.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>normalize</strong> : bool</p>
<blockquote>
<div><p>If True, each band will be divided by the total power. Defaults to
False.</p>
</div></blockquote>
<p><strong>cbar_fmt</strong> : str</p>
<blockquote>
<div><p>The colorbar format. Defaults to &#8216;%0.3f&#8217;.</p>
</div></blockquote>
<p><strong>outlines</strong> : &#8216;head&#8217; | &#8216;skirt&#8217; | dict | None</p>
<blockquote>
<div><p>The outlines to be drawn. If &#8216;head&#8217;, the default head scheme will be
drawn. If &#8216;skirt&#8217; the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in &#8216;mask_pos&#8217; will
serve as image mask, and the &#8216;autoshrink&#8217; (bool) field will trigger
automated shrinking of the positions due to points outside the outline.
Alternatively, a matplotlib patch object can be passed for advanced
masking options, either directly or as a function that returns patches
(required for multi-axis plots). If None, nothing will be drawn.
Defaults to &#8216;head&#8217;.</p>
</div></blockquote>
<p><strong>axes</strong> : list of axes | None</p>
<blockquote>
<div><p>List of axes to plot consecutive topographies to. If None the axes
will be created automatically. Defaults to None.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot_sensors">
<code class="descname">plot_sensors</code><span class="sig-paren">(</span><em>kind='topomap'</em>, <em>ch_type=None</em>, <em>title=None</em>, <em>show_names=False</em>, <em>ch_groups=None</em>, <em>axes=None</em>, <em>block=False</em>, <em>show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot_sensors" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot sensors positions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>kind</strong> : str</p>
<blockquote>
<div><p>Whether to plot the sensors as 3d, topomap or as an interactive
sensor selection dialog. Available options &#8216;topomap&#8217;, &#8216;3d&#8217;,
&#8216;select&#8217;. If &#8216;select&#8217;, a set of channels can be selected
interactively by using lasso selector or clicking while holding
control key. The selected channels are returned along with the
figure instance. Defaults to &#8216;topomap&#8217;.</p>
</div></blockquote>
<p><strong>ch_type</strong> : None | str</p>
<blockquote>
<div><p>The channel type to plot. Available options &#8216;mag&#8217;, &#8216;grad&#8217;, &#8216;eeg&#8217;,
&#8216;seeg&#8217;, &#8216;ecog&#8217;, &#8216;all&#8217;. If <code class="docutils literal"><span class="pre">'all'</span></code>, all the available mag, grad,
eeg, seeg and ecog channels are plotted. If None (default), then
channels are chosen in the order given above.</p>
</div></blockquote>
<p><strong>title</strong> : str | None</p>
<blockquote>
<div><p>Title for the figure. If None (default), equals to <code class="docutils literal"><span class="pre">'Sensor</span>
<span class="pre">positions</span> <span class="pre">(%s)'</span> <span class="pre">%</span> <span class="pre">ch_type</span></code>.</p>
</div></blockquote>
<p><strong>show_names</strong> : bool</p>
<blockquote>
<div><p>Whether to display all channel names. Defaults to False.</p>
</div></blockquote>
<p><strong>ch_groups</strong> : &#8216;position&#8217; | array of shape (ch_groups, picks) | None</p>
<blockquote>
<div><p>Channel groups for coloring the sensors. If None (default), default
coloring scheme is used. If &#8216;position&#8217;, the sensors are divided
into 8 regions. See <code class="docutils literal"><span class="pre">order</span></code> kwarg of <a class="reference internal" href="mne.viz.plot_raw.html#mne.viz.plot_raw" title="mne.viz.plot_raw"><code class="xref py py-func docutils literal"><span class="pre">mne.viz.plot_raw()</span></code></a>. If
array, the channels are divided by picks given in the array.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
<p><strong>axes</strong> : instance of Axes | instance of Axes3D | None</p>
<blockquote>
<div><p>Axes to draw the sensors to. If <code class="docutils literal"><span class="pre">kind='3d'</span></code>, axes must be an
instance of Axes3D. If None (default), a new axes will be created.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
<p><strong>block</strong> : bool</p>
<blockquote>
<div><p>Whether to halt program execution until the figure is closed.
Defaults to False.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True. Defaults to True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote>
<div><p>Figure containing the sensor topography.</p>
</div></blockquote>
<p><strong>selection</strong> : list</p>
<blockquote class="last">
<div><p>A list of selected channels. Only returned if <code class="docutils literal"><span class="pre">kind=='select'</span></code>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.viz.plot_layout.html#mne.viz.plot_layout" title="mne.viz.plot_layout"><code class="xref py py-obj docutils literal"><span class="pre">mne.viz.plot_layout</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>This function plots the sensor locations from the info structure using
matplotlib. For drawing the sensors using mayavi see
<a class="reference internal" href="mne.viz.plot_trans.html#mne.viz.plot_trans" title="mne.viz.plot_trans"><code class="xref py py-func docutils literal"><span class="pre">mne.viz.plot_trans()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.12.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.plot_topo_image">
<code class="descname">plot_topo_image</code><span class="sig-paren">(</span><em>layout=None</em>, <em>sigma=0.0</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>colorbar=True</em>, <em>order=None</em>, <em>cmap='RdBu_r'</em>, <em>layout_scale=0.95</em>, <em>title=None</em>, <em>scalings=None</em>, <em>border='none'</em>, <em>fig_facecolor='k'</em>, <em>fig_background=None</em>, <em>font_color='w'</em>, <em>show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.plot_topo_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot Event Related Potential / Fields image on topographies</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>layout: instance of Layout</strong></p>
<blockquote>
<div><p>System specific sensor positions.</p>
</div></blockquote>
<p><strong>sigma</strong> : float</p>
<blockquote>
<div><p>The standard deviation of the Gaussian smoothing to apply along
the epoch axis to apply in the image. If 0., no smoothing is applied.</p>
</div></blockquote>
<p><strong>vmin</strong> : float</p>
<blockquote>
<div><p>The min value in the image. The unit is uV for EEG channels,
fT for magnetometers and fT/cm for gradiometers.</p>
</div></blockquote>
<p><strong>vmax</strong> : float</p>
<blockquote>
<div><p>The max value in the image. The unit is uV for EEG channels,
fT for magnetometers and fT/cm for gradiometers.</p>
</div></blockquote>
<p><strong>colorbar</strong> : bool</p>
<blockquote>
<div><p>Display or not a colorbar.</p>
</div></blockquote>
<p><strong>order</strong> : None | array of int | callable</p>
<blockquote>
<div><p>If not None, order is used to reorder the epochs on the y-axis
of the image. If it&#8217;s an array of int it should be of length
the number of good epochs. If it&#8217;s a callable the arguments
passed are the times vector and the data as 2d array
(data.shape[1] == len(times)).</p>
</div></blockquote>
<p><strong>cmap</strong> : instance of matplotlib.pyplot.colormap</p>
<blockquote>
<div><p>Colors to be mapped to the values.</p>
</div></blockquote>
<p><strong>layout_scale: float</strong></p>
<blockquote>
<div><p>scaling factor for adjusting the relative size of the layout
on the canvas.</p>
</div></blockquote>
<p><strong>title</strong> : str</p>
<blockquote>
<div><p>Title of the figure.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>The scalings of the channel types to be applied for plotting. If
None, defaults to <cite>dict(eeg=1e6, grad=1e13, mag=1e15)</cite>.</p>
</div></blockquote>
<p><strong>border</strong> : str</p>
<blockquote>
<div><p>matplotlib borders style to be used for each sensor plot.</p>
</div></blockquote>
<p><strong>fig_facecolor</strong> : str | obj</p>
<blockquote>
<div><p>The figure face color. Defaults to black.</p>
</div></blockquote>
<p><strong>fig_background</strong> : None | array</p>
<blockquote>
<div><p>A background image for the figure. This must be a valid input to
<cite>matplotlib.pyplot.imshow</cite>. Defaults to None.</p>
</div></blockquote>
<p><strong>font_color</strong> : str | obj</p>
<blockquote>
<div><p>The color of tick labels in the colorbar. Defaults to white.</p>
</div></blockquote>
<p><strong>show</strong> : bool</p>
<blockquote>
<div><p>Show figure if True.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib figure</p>
<blockquote class="last">
<div><p>Figure distributing one image per channel across sensor topography.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.rename_channels">
<code class="descname">rename_channels</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.rename_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>Rename channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict | callable</p>
<blockquote class="last">
<div><p>a dictionary mapping the old channel to a new channel name
e.g. {&#8216;EEG061&#8217; : &#8216;EEG161&#8217;}. Can also be a callable function
that takes and returns a string (new in version 0.10.0).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.resample">
<code class="descname">resample</code><span class="sig-paren">(</span><em>sfreq</em>, <em>npad='auto'</em>, <em>window='boxcar'</em>, <em>n_jobs=1</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample preloaded data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sfreq</strong> : float</p>
<blockquote>
<div><p>New sample rate to use</p>
</div></blockquote>
<p><strong>npad</strong> : int | str</p>
<blockquote>
<div><p>Amount to pad the start and end of the data.
Can also be &#8220;auto&#8221; to use a padding that will result in
a power-of-two size (can be much faster).</p>
</div></blockquote>
<p><strong>window</strong> : string or tuple</p>
<blockquote>
<div><p>Window to use in resampling. See scipy.signal.resample.</p>
</div></blockquote>
<p><strong>n_jobs</strong> : int</p>
<blockquote>
<div><p>Number of jobs to run in parallel.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote>
<div><p>If not None, override default verbose level (see mne.verbose).
Defaults to self.verbose.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>epochs</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The resampled epochs object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.Epochs.html#mne.Epochs.savgol_filter" title="mne.Epochs.savgol_filter"><code class="xref py py-obj docutils literal"><span class="pre">mne.Epochs.savgol_filter</span></code></a>, <a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.resample" title="mne.io.Raw.resample"><code class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.resample</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For some data, it may be more accurate to use npad=0 to reduce
artifacts. This is dataset dependent &#8211; check your data!</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>fname</em>, <em>split_size='2GB'</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save epochs in a fif file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : str</p>
<blockquote>
<div><p>The name of the file, which should end with -epo.fif or
-epo.fif.gz.</p>
</div></blockquote>
<p><strong>split_size</strong> : string | int</p>
<blockquote class="last">
<div><p>Large raw files are automatically split into multiple pieces. This
parameter specifies the maximum size of each piece. If the
parameter is an integer, it specifies the size in Bytes. It is
also possible to pass a human-readable string, e.g., 100MB.
Note: Due to FIFF file limitations, the maximum split size is 2GB.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.0.</span></p>
</div>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Bad epochs will be dropped before saving the epochs to disk.</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.savgol_filter">
<code class="descname">savgol_filter</code><span class="sig-paren">(</span><em>h_freq</em>, <em>copy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.savgol_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter the data using Savitzky-Golay polynomial method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h_freq</strong> : float</p>
<blockquote>
<div><p>Approximate high cut-off frequency in Hz. Note that this
is not an exact cutoff, since Savitzky-Golay filtering <a class="reference internal" href="#r3" id="id1">[R3]</a> is
done using polynomial fits instead of FIR/IIR filtering.
This parameter is thus used to determine the length of the
window over which a 5th-order polynomial smoothing is used.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If True, a copy of the object, filtered, is returned.
If False (default), it operates on the object in place.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Epochs or Evoked</p>
<blockquote class="last">
<div><p>The object with the filtering applied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.io.Raw.html#mne.io.Raw.filter" title="mne.io.Raw.filter"><code class="xref py py-obj docutils literal"><span class="pre">mne.io.Raw.filter</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>For Savitzky-Golay low-pass approximation, see:</p>
<blockquote>
<div><a class="reference external" href="https://gist.github.com/Eric89GXL/bbac101d50176611136b">https://gist.github.com/Eric89GXL/bbac101d50176611136b</a></div></blockquote>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R3]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Savitzky, A., Golay, M.J.E. (1964). &#8220;Smoothing and
Differentiation of Data by Simplified Least Squares
Procedures&#8221;. Analytical Chemistry 36 (8): 1627-39.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">mne</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">os</span> <span class="k">import</span> <span class="n">path</span> <span class="k">as</span> <span class="n">op</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked_fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mne</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">sample</span><span class="o">.</span><span class="n">data_path</span><span class="p">(),</span> <span class="s1">&#39;MEG&#39;</span><span class="p">,</span> <span class="s1">&#39;sample&#39;</span><span class="p">,</span> <span class="s1">&#39;sample_audvis-ave.fif&#39;</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">read_evokeds</span><span class="p">(</span><span class="n">evoked_fname</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>  <span class="c1"># low-pass at around 10 Hz </span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">evoked</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>  
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.set_channel_types">
<code class="descname">set_channel_types</code><span class="sig-paren">(</span><em>mapping</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.set_channel_types" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the sensor type of channels.</p>
<dl class="docutils">
<dt>Note: The following sensor types are accepted:</dt>
<dd>ecg, eeg, emg, eog, exci, ias, misc, resp, seeg, stim, syst, ecog,
hbo, hbr</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mapping</strong> : dict</p>
<blockquote class="last">
<div><p>a dictionary mapping a channel to a sensor type (str)
{&#8216;EEG061&#8217;: &#8216;eog&#8217;}.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.set_eeg_reference">
<code class="descname">set_eeg_reference</code><span class="sig-paren">(</span><em>ref_channels=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.set_eeg_reference" title="Permalink to this definition">¶</a></dt>
<dd><p>Rereference EEG channels to new reference channel(s).</p>
<p>If multiple reference channels are specified, they will be averaged. If
no reference channels are specified, an average reference will be
applied.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>ref_channels</strong> : list of str | None</p>
<blockquote>
<div><p>The names of the channels to use to construct the reference. If
None (default), an average reference will be added as an SSP
projector but not immediately applied to the data. If an empty list
is specified, the data is assumed to already have a proper
reference and MNE will not attempt any re-referencing of the data.
Defaults to an average reference (None).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : instance of Raw | Epochs | Evoked</p>
<blockquote class="last">
<div><p>Data with EEG channels re-referenced. For <code class="docutils literal"><span class="pre">ref_channels=None</span></code>,
an average projector will be added instead of directly subtarcting
data.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.set_bipolar_reference.html#mne.set_bipolar_reference" title="mne.set_bipolar_reference"><code class="xref py py-obj docutils literal"><span class="pre">mne.set_bipolar_reference</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<ol class="arabic simple">
<li>If a reference is requested that is not the average reference, this
function removes any pre-existing average reference projections.</li>
<li>During source localization, the EEG signal should have an average
reference.</li>
<li>In order to apply a reference other than an average reference, the
data must be preloaded.</li>
</ol>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.13.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.set_montage">
<code class="descname">set_montage</code><span class="sig-paren">(</span><em>montage</em>, <em>verbose=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.set_montage" title="Permalink to this definition">¶</a></dt>
<dd><p>Set EEG sensor configuration</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>montage</strong> : instance of Montage or DigMontage</p>
<blockquote>
<div><p>The montage to use.</p>
</div></blockquote>
<p><strong>verbose</strong> : bool, str, int, or None</p>
<blockquote class="last">
<div><p>If not None, override default verbose level (see mne.verbose).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Operates in place.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.9.0.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.standard_error">
<code class="descname">standard_error</code><span class="sig-paren">(</span><em>picks=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.standard_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute standard error over epochs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG, EEG, SEEG, ECoG, and fNIRS channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>evoked</strong> : instance of Evoked</p>
<blockquote class="last">
<div><p>The standard error over epochs.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.subtract_evoked">
<code class="descname">subtract_evoked</code><span class="sig-paren">(</span><em>evoked=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.subtract_evoked" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract an evoked response from each epoch</p>
<p>Can be used to exclude the evoked response when analyzing induced
activity, see e.g. [1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>evoked</strong> : instance of Evoked | None</p>
<blockquote>
<div><p>The evoked response to subtract. If None, the evoked response
is computed from Epochs itself.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of Epochs</p>
<blockquote class="last">
<div><p>The modified instance (instance is also modified inplace).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>[1] David et al. &#8220;Mechanisms of evoked and induced responses in
MEG/EEG&#8221;, NeuroImage, vol. 31, no. 4, pp. 1580-1591, July 2006.</p>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.time_as_index">
<code class="descname">time_as_index</code><span class="sig-paren">(</span><em>times</em>, <em>use_rounding=False</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.time_as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert time to indices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>times</strong> : list-like | float | int</p>
<blockquote>
<div><p>List of numbers or a number representing points in time.</p>
</div></blockquote>
<p><strong>use_rounding</strong> : boolean</p>
<blockquote>
<div><p>If True, use rounding (instead of truncation) when converting
times to indices. This can help avoid non-unique indices.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>index</strong> : ndarray</p>
<blockquote class="last">
<div><p>Indices corresponding to the times supplied.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.EpochsArray.to_data_frame">
<code class="descname">to_data_frame</code><span class="sig-paren">(</span><em>picks=None</em>, <em>index=None</em>, <em>scale_time=1000.0</em>, <em>scalings=None</em>, <em>copy=True</em>, <em>start=None</em>, <em>stop=None</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.EpochsArray.to_data_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Export data in tabular structure as a pandas DataFrame.</p>
<p>Columns and indices will depend on the object being converted.
Generally this will include as much relevant information as
possible for the data type being converted. This makes it easy
to convert data for use in packages that utilize dataframes,
such as statsmodels or seaborn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>picks</strong> : array-like of int | None</p>
<blockquote>
<div><p>If None only MEG and EEG channels are kept
otherwise the channels indices in picks are kept.</p>
</div></blockquote>
<p><strong>index</strong> : tuple of str | None</p>
<blockquote>
<div><p>Column to be used as index for the data. Valid string options
are &#8216;epoch&#8217;, &#8216;time&#8217; and &#8216;condition&#8217;. If None, all three info
columns will be included in the table as categorial data.</p>
</div></blockquote>
<p><strong>scale_time</strong> : float</p>
<blockquote>
<div><p>Scaling to be applied to time units.</p>
</div></blockquote>
<p><strong>scalings</strong> : dict | None</p>
<blockquote>
<div><p>Scaling to be applied to the channels picked. If None, defaults to
<code class="docutils literal"><span class="pre">scalings=dict(eeg=1e6,</span> <span class="pre">grad=1e13,</span> <span class="pre">mag=1e15,</span> <span class="pre">misc=1.0)</span></code>.</p>
</div></blockquote>
<p><strong>copy</strong> : bool</p>
<blockquote>
<div><p>If true, data will be copied. Else data may be modified in place.</p>
</div></blockquote>
<p><strong>start</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a starting index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
<p><strong>stop</strong> : int | None</p>
<blockquote>
<div><p>If it is a Raw object, this defines a stop index for creating
the dataframe from a slice. The times will be interpolated from the
index and the sampling rate of the signal.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : instance of pandas.core.DataFrame</p>
<blockquote class="last">
<div><p>A dataframe suitable for usage with other
statistical/plotting/analysis packages. Column/Index values will
depend on the object type being converted, but should be
human-readable.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2012-2016, MNE Developers. Last updated on 2016-11-21.<br/>
    </p>
  </div>
</footer>
<script src="https://mne.tools/versionwarning.js"></script>
  </body>
</html>