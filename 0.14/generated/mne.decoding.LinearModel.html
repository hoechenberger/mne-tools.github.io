<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.decoding.LinearModel &#8212; MNE 0.14.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.3.6/flatly/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.14.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

<link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700' rel='stylesheet' type='text/css'>


    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37225609-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>


    <link rel="stylesheet" href="../_static/style.css " type="text/css" />



    <script type="text/javascript">
    !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);
    js.id=id;js.src="https://platform.twitter.com/widgets.js";
    fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
    </script>



    <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
    </script>


  <link rel="canonical" href="https://mne.tools/stable/index.html" />
</head>
  <body>





  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><span><img src="../_static/mne_logo_small.png"></span>
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.14.1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../getting_started.html">Get started</a></li>
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../auto_examples/index.html">Examples</a></li>
                <li><a href="../python_reference.html">API</a></li>
                <li><a href="../manual/index.html">Manual</a></li>
                <li><a href="../contributing.html">Contribute</a></li>
                <li><a href="../faq.html">FAQ</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mne_logo_small.png" alt="Logo"/>
            </a></p><ul>
<li><a class="reference internal" href="#">mne.decoding.LinearModel</a></li>
</ul>

<form action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
    <div class="col-md-12 content">
      
  <div class="section" id="mne-decoding-linearmodel">
<h1>mne.decoding.LinearModel<a class="headerlink" href="#mne-decoding-linearmodel" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="mne.decoding.LinearModel">
<em class="property">class </em><code class="descclassname">mne.decoding.</code><code class="descname">LinearModel</code><span class="sig-paren">(</span><em>model=None</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/decoding/base.py#L15-L490"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute and store patterns from linear models.</p>
<p>The linear model coefficients (filters) are used to extract discriminant
neural sources from the measured data. This class computes the
corresponding patterns of these linear filters to make them more
interpretable <a class="reference internal" href="#r38" id="id1">[R38]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model</strong> : object | None</p>
<blockquote class="last">
<div><p>A linear model from scikit-learn with a fit method
that updates a <code class="docutils literal"><span class="pre">coef_</span></code> attribute.
If None the model will be LogisticRegression.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="mne.decoding.CSP.html#mne.decoding.CSP" title="mne.decoding.CSP"><code class="xref py py-obj docutils literal"><span class="pre">CSP</span></code></a>, <a class="reference internal" href="mne.preprocessing.ICA.html#mne.preprocessing.ICA" title="mne.preprocessing.ICA"><code class="xref py py-obj docutils literal"><span class="pre">mne.preprocessing.ICA</span></code></a>, <a class="reference internal" href="mne.preprocessing.Xdawn.html#mne.preprocessing.Xdawn" title="mne.preprocessing.Xdawn"><code class="xref py py-obj docutils literal"><span class="pre">mne.preprocessing.Xdawn</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.10.</span></p>
</div>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R38]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Haufe, S., Meinecke, F., Gorgen, K., Dahne, S., Haynes, J.-D.,
Blankertz, B., &amp; Biebmann, F. (2014). On the interpretation of
weight vectors of linear models in multivariate neuroimaging.
NeuroImage, 87, 96-110.</td></tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">filters_</span></code></td>
<td>(ndarray) If fit, the filters used to decompose the data.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">patterns_</span></code></td>
<td>(ndarray) If fit, the patterns used to restore M/EEG signals.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.LinearModel.__hash__" title="mne.decoding.LinearModel.__hash__"><code class="xref py py-obj docutils literal"><span class="pre">__hash__</span></code></a>()&nbsp;&lt;==&gt;&nbsp;hash(x)</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.LinearModel.fit" title="mne.decoding.LinearModel.fit"><code class="xref py py-obj docutils literal"><span class="pre">fit</span></code></a>(X,&nbsp;y)</td>
<td>Estimate the coefficients of the linear model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.LinearModel.fit_transform" title="mne.decoding.LinearModel.fit_transform"><code class="xref py py-obj docutils literal"><span class="pre">fit_transform</span></code></a>(X,&nbsp;y)</td>
<td>Fit the data and transform it using the linear model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.LinearModel.get_params" title="mne.decoding.LinearModel.get_params"><code class="xref py py-obj docutils literal"><span class="pre">get_params</span></code></a>([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.LinearModel.plot_filters" title="mne.decoding.LinearModel.plot_filters"><code class="xref py py-obj docutils literal"><span class="pre">plot_filters</span></code></a>(*args,&nbsp;**kwargs)</td>
<td><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: plot_filters is deprecated and will be removed in 0.15, use EvokedArray instead.</p>
</div>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.LinearModel.plot_patterns" title="mne.decoding.LinearModel.plot_patterns"><code class="xref py py-obj docutils literal"><span class="pre">plot_patterns</span></code></a>(*args,&nbsp;**kwargs)</td>
<td><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: plot_filters is deprecated and will be removed in 0.15, use EvokedArray instead.</p>
</div>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.LinearModel.predict" title="mne.decoding.LinearModel.predict"><code class="xref py py-obj docutils literal"><span class="pre">predict</span></code></a>(X)</td>
<td>Compute predictions of y from X.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.LinearModel.score" title="mne.decoding.LinearModel.score"><code class="xref py py-obj docutils literal"><span class="pre">score</span></code></a>(X,&nbsp;y)</td>
<td>Score the linear model computed on the given test data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#mne.decoding.LinearModel.set_params" title="mne.decoding.LinearModel.set_params"><code class="xref py py-obj docutils literal"><span class="pre">set_params</span></code></a>(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#mne.decoding.LinearModel.transform" title="mne.decoding.LinearModel.transform"><code class="xref py py-obj docutils literal"><span class="pre">transform</span></code></a>(X)</td>
<td>Transform the data using the linear model.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="mne.decoding.LinearModel.__hash__">
<code class="descname">__hash__</code><span class="sig-paren">(</span><em>) &lt;==&gt; hash(x</em><span class="sig-paren">)</span><a class="headerlink" href="#mne.decoding.LinearModel.__hash__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/decoding/base.py#L62-L101"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the coefficients of the linear model.</p>
<p>Save the coefficients in the attribute <code class="docutils literal"><span class="pre">filters_</span></code> and
computes the attribute <code class="docutils literal"><span class="pre">patterns_</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, shape (n_samples, n_features)</p>
<blockquote>
<div><p>The training input samples to estimate the linear coefficients.</p>
</div></blockquote>
<p><strong>y</strong> : array, shape (n_samples,)</p>
<blockquote>
<div><p>The target values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> : instance of LinearModel</p>
<blockquote class="last">
<div><p>Returns the modified instance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.fit_transform">
<code class="descname">fit_transform</code><span class="sig-paren">(</span><em>X</em>, <em>y</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/decoding/base.py#L118-L134"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.fit_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the data and transform it using the linear model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, shape (n_samples, n_features)</p>
<blockquote>
<div><p>The training input samples to estimate the linear coefficients.</p>
</div></blockquote>
<p><strong>y</strong> : array, shape (n_samples,)</p>
<blockquote>
<div><p>The target values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_pred</strong> : array, shape (n_samples,)</p>
<blockquote class="last">
<div><p>The predicted targets.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.get_params">
<code class="descname">get_params</code><span class="sig-paren">(</span><em>deep=True</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/fixes.py#L1107-L1142"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Get parameters for this estimator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>deep</strong> : boolean, optional</p>
<blockquote>
<div><p>If True, will return the parameters for this estimator and
contained subobjects that are estimators.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>params</strong> : mapping of string to any</p>
<blockquote class="last">
<div><p>Parameter names mapped to their values.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.plot_filters">
<code class="descname">plot_filters</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/utils.py#L637-L639"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.plot_filters" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: plot_filters is deprecated and will be removed in 0.15, use EvokedArray instead.</p>
</div>
<p>Plot topographic filters of the linear model.</p>
<blockquote>
<div>The filters are used to extract discriminant neural sources from
the measured data (a.k.a. the backward model).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : instance of Info</p>
<blockquote>
<div><blockquote>
<div><p>Info dictionary of the epochs used to fit the linear model.
If not possible, consider using <code class="docutils literal"><span class="pre">create_info</span></code>.</p>
</div></blockquote>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">float | array of floats | None.</span></dt>
<dd><p class="first last">The time point(s) to plot. If None, the number of <code class="docutils literal"><span class="pre">axes</span></code>
determines the amount of time point(s). If <code class="docutils literal"><span class="pre">axes</span></code> is also None,
10 topographies will be shown with a regular time spacing between
the first and last time instant.</p>
</dd>
<dt>ch_type <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None</span></dt>
<dd><p class="first last">The channel type to plot. For ‘grad’, the gradiometers are
collected in pairs and the RMS for each pair is plotted.
If None, then first available channel type from order given
above is used. Defaults to None.</p>
</dd>
<dt>layout <span class="classifier-delimiter">:</span> <span class="classifier">None | Layout</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to be
specified for Neuromag data). If possible, the correct layout file
is inferred from the data; if no appropriate layout file was found
the layout is automatically generated from the sensor locations.</p>
</dd>
<dt>vmin <span class="classifier-delimiter">:</span> <span class="classifier">float | callable</span></dt>
<dd><p class="first last">The value specfying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data).</p>
</dd>
<dt>vmax <span class="classifier-delimiter">:</span> <span class="classifier">float | callable</span></dt>
<dd><p class="first last">The value specfying the upper bound of the color range.
If None, the maximum absolute value is used. If vmin is None,
but vmax is not, defaults to np.min(data).
If callable, the output equals vmax(data).</p>
</dd>
<dt>cmap <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’ | None</span></dt>
<dd><p class="first">Colormap to use. If tuple, the first value indicates the colormap
to use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging
the colorbar with left and right mouse button. Left mouse button
moves the scale up and down and right mouse button adjusts the
range. Hitting space bar resets the range. Up and down arrows can
be used to change the colormap. If None, ‘Reds’ is used for all
positive data, otherwise defaults to ‘RdBu_r’. If ‘interactive’,
translates to (None, True). Defaults to ‘RdBu_r’.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Interactive mode works smoothly only for a small
amount of topomaps.</p>
</div>
</dd>
<dt>sensors <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., ‘r+’ for red plusses). If True,
a circle will be used (via .add_artist). Defaults to True.</p>
</dd>
<dt>colorbar <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Plot a colorbar.</p>
</dd>
<dt>scale <span class="classifier-delimiter">:</span> <span class="classifier">dict | float | None</span></dt>
<dd><p class="first last">Scale the data for plotting. If None, defaults to 1e6 for eeg, 1e13
for grad and 1e15 for mag.</p>
</dd>
<dt>scale_time <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Scale the time labels. Defaults to 1e3.</p>
</dd>
<dt>unit <span class="classifier-delimiter">:</span> <span class="classifier">dict | str | None</span></dt>
<dd><p class="first last">The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</dd>
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The resolution of the topomap image (n pixels along each side).</p>
</dd>
<dt>size <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Side length per topomap in inches.</p>
</dd>
<dt>cbar_fmt <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">String format for colorbar values.</p>
</dd>
<dt>name_format <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">String format for topomap values. Defaults to “%03f ms”</p>
</dd>
<dt>proj <span class="classifier-delimiter">:</span> <span class="classifier">bool | ‘interactive’</span></dt>
<dd><p class="first last">If true SSP projections are applied before display.
If ‘interactive’, a check box for reversible selection
of SSP projection vectors will be show.</p>
</dd>
<dt>show <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt>show_names <span class="classifier-delimiter">:</span> <span class="classifier">bool | callable</span></dt>
<dd><p class="first last">If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g.,
to delete the prefix ‘MEG ‘ from all channel names, pass the
function lambda x: x.replace(‘MEG ‘, ”). If <cite>mask</cite> is not None,
only significant sensors will be shown.</p>
</dd>
<dt>title <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Title. If None (default), no title is displayed.</p>
</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of bool, shape (n_channels, n_times) | None</span></dt>
<dd><p class="first last">The channels to be marked as significant at a given time point.
Indices set to <cite>True</cite> will be considered. Defaults to None.</p>
</dd>
<dt>mask_params <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first">Additional plotting parameters for plotting significant sensors.
Default (None) equals:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>outlines <span class="classifier-delimiter">:</span> <span class="classifier">‘head’ | ‘skirt’ | dict | None</span></dt>
<dd><p class="first last">The outlines to be drawn. If ‘head’, the default head scheme will
be drawn. If ‘skirt’ the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in ‘mask_pos’
will serve as image mask, and the ‘autoshrink’ (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to ‘head’.</p>
</dd>
<dt>contours <span class="classifier-delimiter">:</span> <span class="classifier">int | False | None</span></dt>
<dd><p class="first last">The number of contour lines to draw.
If 0, no contours will be drawn.</p>
</dd>
<dt>image_interp <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The image interpolation to be used.
All matplotlib options are accepted.</p>
</dd>
<dt>average <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The time window around a given time to be used for averaging
(seconds). For example, 0.01 would translate into window that
starts 5 ms before and ends 5 ms after a given time point.
Defaults to None, which means no averaging.</p>
</dd>
<dt>head_pos <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries ‘center’ (tuple) and
‘scale’ (tuple) for what the center and scale of the head
should be relative to the electrode locations.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.plot_patterns">
<code class="descname">plot_patterns</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/utils.py#L637-L639"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.plot_patterns" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">DEPRECATED: plot_filters is deprecated and will be removed in 0.15, use EvokedArray instead.</p>
</div>
<p>Plot topographic patterns of the linear model.</p>
<blockquote>
<div>The patterns explain how the measured data was generated
from the neural sources (a.k.a. the forward model).</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>info</strong> : instance of Info</p>
<blockquote>
<div><blockquote>
<div><p>Info dictionary of the epochs used to fit the linear model.
If not possible, consider using <code class="docutils literal"><span class="pre">create_info</span></code>.</p>
</div></blockquote>
<dl class="docutils">
<dt>times <span class="classifier-delimiter">:</span> <span class="classifier">float | array of floats | None.</span></dt>
<dd><p class="first last">The time point(s) to plot. If None, the number of <code class="docutils literal"><span class="pre">axes</span></code>
determines the amount of time point(s). If <code class="docutils literal"><span class="pre">axes</span></code> is also None,
10 topographies will be shown with a regular time spacing between
the first and last time instant.</p>
</dd>
<dt>ch_type <span class="classifier-delimiter">:</span> <span class="classifier">‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None</span></dt>
<dd><p class="first last">The channel type to plot. For ‘grad’, the gradiometers are
collected in pairs and the RMS for each pair is plotted.
If None, then first available channel type from order given
above is used. Defaults to None.</p>
</dd>
<dt>layout <span class="classifier-delimiter">:</span> <span class="classifier">None | Layout</span></dt>
<dd><p class="first last">Layout instance specifying sensor positions (does not need to be
specified for Neuromag data). If possible, the correct layout file
is inferred from the data; if no appropriate layout file was found
the layout is automatically generated from the sensor locations.</p>
</dd>
<dt>vmin <span class="classifier-delimiter">:</span> <span class="classifier">float | callable</span></dt>
<dd><p class="first last">The value specfying the lower bound of the color range.
If None, and vmax is None, -vmax is used. Else np.min(data).
If callable, the output equals vmin(data).</p>
</dd>
<dt>vmax <span class="classifier-delimiter">:</span> <span class="classifier">float | callable</span></dt>
<dd><p class="first last">The value specfying the upper bound of the color range.
If None, the maximum absolute value is used. If vmin is None,
but vmax is not, defaults to np.min(data).
If callable, the output equals vmax(data).</p>
</dd>
<dt>cmap <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib colormap | (colormap, bool) | ‘interactive’ | None</span></dt>
<dd><p class="first">Colormap to use. If tuple, the first value indicates the colormap
to use and the second value is a boolean defining interactivity. In
interactive mode the colors are adjustable by clicking and dragging
the colorbar with left and right mouse button. Left mouse button
moves the scale up and down and right mouse button adjusts the
range. Hitting space bar resets the range. Up and down arrows can
be used to change the colormap. If None, ‘Reds’ is used for all
positive data, otherwise defaults to ‘RdBu_r’. If ‘interactive’,
translates to (None, True). Defaults to ‘RdBu_r’.</p>
<div class="last admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Interactive mode works smoothly only for a small
amount of topomaps.</p>
</div>
</dd>
<dt>sensors <span class="classifier-delimiter">:</span> <span class="classifier">bool | str</span></dt>
<dd><p class="first last">Add markers for sensor locations to the plot. Accepts matplotlib
plot format string (e.g., ‘r+’ for red plusses). If True,
a circle will be used (via .add_artist). Defaults to True.</p>
</dd>
<dt>colorbar <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Plot a colorbar.</p>
</dd>
<dt>scale <span class="classifier-delimiter">:</span> <span class="classifier">dict | float | None</span></dt>
<dd><p class="first last">Scale the data for plotting. If None, defaults to 1e6 for eeg, 1e13
for grad and 1e15 for mag.</p>
</dd>
<dt>scale_time <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">Scale the time labels. Defaults to 1e3.</p>
</dd>
<dt>unit <span class="classifier-delimiter">:</span> <span class="classifier">dict | str | None</span></dt>
<dd><p class="first last">The unit of the channel type used for colorbar label. If
scale is None the unit is automatically determined.</p>
</dd>
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The resolution of the topomap image (n pixels along each side).</p>
</dd>
<dt>size <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Side length per topomap in inches.</p>
</dd>
<dt>cbar_fmt <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">String format for colorbar values.</p>
</dd>
<dt>name_format <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">String format for topomap values. Defaults to “%03f ms”</p>
</dd>
<dt>proj <span class="classifier-delimiter">:</span> <span class="classifier">bool | ‘interactive’</span></dt>
<dd><p class="first last">If true SSP projections are applied before display.
If ‘interactive’, a check box for reversible selection
of SSP projection vectors will be show.</p>
</dd>
<dt>show <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Show figure if True.</p>
</dd>
<dt>show_names <span class="classifier-delimiter">:</span> <span class="classifier">bool | callable</span></dt>
<dd><p class="first last">If True, show channel names on top of the map. If a callable is
passed, channel names will be formatted using the callable; e.g.,
to delete the prefix ‘MEG ‘ from all channel names, pass the
function lambda x: x.replace(‘MEG ‘, ”). If <cite>mask</cite> is not None,
only significant sensors will be shown.</p>
</dd>
<dt>title <span class="classifier-delimiter">:</span> <span class="classifier">str | None</span></dt>
<dd><p class="first last">Title. If None (default), no title is displayed.</p>
</dd>
<dt>mask <span class="classifier-delimiter">:</span> <span class="classifier">ndarray of bool, shape (n_channels, n_times) | None</span></dt>
<dd><p class="first last">The channels to be marked as significant at a given time point.
Indices set to <cite>True</cite> will be considered. Defaults to None.</p>
</dd>
<dt>mask_params <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first">Additional plotting parameters for plotting significant sensors.
Default (None) equals:</p>
<div class="last highlight-default"><div class="highlight"><pre><span></span><span class="nb">dict</span><span class="p">(</span><span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span>
     <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>outlines <span class="classifier-delimiter">:</span> <span class="classifier">‘head’ | ‘skirt’ | dict | None</span></dt>
<dd><p class="first last">The outlines to be drawn. If ‘head’, the default head scheme will
be drawn. If ‘skirt’ the head scheme will be drawn, but sensors are
allowed to be plotted outside of the head circle. If dict, each key
refers to a tuple of x and y positions, the values in ‘mask_pos’
will serve as image mask, and the ‘autoshrink’ (bool) field will
trigger automated shrinking of the positions due to points outside
the outline. Alternatively, a matplotlib patch object can be passed
for advanced masking options, either directly or as a function that
returns patches (required for multi-axis plots). If None, nothing
will be drawn. Defaults to ‘head’.</p>
</dd>
<dt>contours <span class="classifier-delimiter">:</span> <span class="classifier">int | False | None</span></dt>
<dd><p class="first last">The number of contour lines to draw.
If 0, no contours will be drawn.</p>
</dd>
<dt>image_interp <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">The image interpolation to be used.
All matplotlib options are accepted.</p>
</dd>
<dt>average <span class="classifier-delimiter">:</span> <span class="classifier">float | None</span></dt>
<dd><p class="first last">The time window around a given time to be used for averaging
(seconds). For example, 0.01 would translate into window that
starts 5 ms before and ends 5 ms after a given time point.
Defaults to None, which means no averaging.</p>
</dd>
<dt>head_pos <span class="classifier-delimiter">:</span> <span class="classifier">dict | None</span></dt>
<dd><p class="first last">If None (default), the sensors are positioned such that they span
the head circle. If dict, can have entries ‘center’ (tuple) and
‘scale’ (tuple) for what the center and scale of the head
should be relative to the electrode locations.</p>
</dd>
</dl>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>fig</strong> : instance of matplotlib.figure.Figure</p>
<blockquote class="last">
<div><p>The figure.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/decoding/base.py#L136-L149"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute predictions of y from X.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, shape (n_samples, n_features)</p>
<blockquote>
<div><p>The data used to compute the predictions.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_pred</strong> : array, shape (n_samples,)</p>
<blockquote class="last">
<div><p>The predictions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.score">
<code class="descname">score</code><span class="sig-paren">(</span><em>X</em>, <em>y</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/decoding/base.py#L151-L166"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the linear model computed on the given test data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, shape (n_samples, n_features)</p>
<blockquote>
<div><p>The data to transform.</p>
</div></blockquote>
<p><strong>y</strong> : array, shape (n_samples,)</p>
<blockquote>
<div><p>The target values.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>score</strong> : float</p>
<blockquote class="last">
<div><p>Score of the linear model</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.set_params">
<code class="descname">set_params</code><span class="sig-paren">(</span><em>**params</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/fixes.py#L1144-L1178"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.set_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the parameters of this estimator.
The method works on simple estimators as well as on nested objects
(such as pipelines). The latter have parameters of the form
<code class="docutils literal"><span class="pre">&lt;component&gt;__&lt;parameter&gt;</span></code> so that it’s possible to update each
component of a nested object.
Returns
——-
self</p>
</dd></dl>

<dl class="method">
<dt id="mne.decoding.LinearModel.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference external" href="http://github.com/mne-tools/mne-python/blob/maint/0.14/mne/decoding/base.py#L103-L116"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#mne.decoding.LinearModel.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the data using the linear model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>X</strong> : array, shape (n_samples, n_features)</p>
<blockquote>
<div><p>The data to transform.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y_pred</strong> : array, shape (n_samples,)</p>
<blockquote class="last">
<div><p>The predicted targets.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
    
  </div>
</div>
<footer class="footer">
  <div class="container"><img src="../_static/institutions.png" alt="Institutions"></div>
  <div class="container">
    <ul class="list-inline">
      <li><a href="https://github.com/mne-tools/mne-python">GitHub</a></li>
      <li>·</li>
      <li><a href="https://mail.nmr.mgh.harvard.edu/mailman/listinfo/mne_analysis">Mailing list</a></li>
      <li>·</li>
      <li><a href="https://gitter.im/mne-tools/mne-python">Gitter</a></li>
      <li>·</li>
      <li><a href="whats_new.html">What's new</a></li>
      <li>·</li>
      <li><a href="faq.html#cite">Cite MNE</a></li>
      <li class="pull-right"><a href="#">Back to top</a></li>
    </ul>
    <p>&copy; Copyright 2012-2017, MNE Developers. Last updated on 2017-08-15.</p>
  </div>
</footer>
<script src="https://mne.tools/versionwarning.js"></script>
  </body>
</html>